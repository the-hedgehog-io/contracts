{
  "address": "0x25eab32920A9E4b5a6403502D176E7ac5BB3314F",
  "abi": [
    {
      "inputs": [],
      "name": "MainOracleDisabled",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_lastGoodPrice",
          "type": "uint256"
        }
      ],
      "name": "LastGoodPriceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum PriceFeed.Status",
          "name": "newStatus",
          "type": "uint8"
        }
      ],
      "name": "PriceFeedStatusChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DECIMAL_PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "NAME",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TARGET_DIGITS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TIMEOUT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "backupOracle",
      "outputs": [
        {
          "internalType": "contract IBaseFeeOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fetchPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastGoodPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mainOracle",
      "outputs": [
        {
          "internalType": "contract IBaseFeeOracle",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_mainOracleAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_backupOracleAddress",
          "type": "address"
        }
      ],
      "name": "setAddresses",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "status",
      "outputs": [
        {
          "internalType": "enum PriceFeed.Status",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xce5ea27ccde7fb07cdf82138841cc6a362137d3dab61a5b24f5fba2124f4b5f3",
  "receipt": {
    "to": null,
    "from": "0x3BFc9CA7FA5D94461Dc96225D88CBb300B108d9E",
    "contractAddress": "0x25eab32920A9E4b5a6403502D176E7ac5BB3314F",
    "transactionIndex": 2,
    "gasUsed": "1067234",
    "logsBloom": "0x00000800000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000001000000000000000000001000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000020000000000000000000000000000000000000000000000000000000000000040000",
    "blockHash": "0x777c4c01998fe18723a519903a293b6f4cdd3766267b8aef2f7b362a647fa6b4",
    "transactionHash": "0xce5ea27ccde7fb07cdf82138841cc6a362137d3dab61a5b24f5fba2124f4b5f3",
    "logs": [
      {
        "transactionIndex": 2,
        "blockNumber": 8409445,
        "transactionHash": "0xce5ea27ccde7fb07cdf82138841cc6a362137d3dab61a5b24f5fba2124f4b5f3",
        "address": "0x25eab32920A9E4b5a6403502D176E7ac5BB3314F",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000003bfc9ca7fa5d94461dc96225d88cbb300b108d9e"
        ],
        "data": "0x",
        "logIndex": 3,
        "blockHash": "0x777c4c01998fe18723a519903a293b6f4cdd3766267b8aef2f7b362a647fa6b4"
      }
    ],
    "blockNumber": 8409445,
    "cumulativeGasUsed": "1237773",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "26b7e46187074ecdc3b4eda7be7ea101",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MainOracleDisabled\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastGoodPrice\",\"type\":\"uint256\"}],\"name\":\"LastGoodPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum PriceFeed.Status\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"PriceFeedStatusChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TARGET_DIGITS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backupOracle\",\"outputs\":[{\"internalType\":\"contract IBaseFeeOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastGoodPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainOracle\",\"outputs\":[{\"internalType\":\"contract IBaseFeeOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mainOracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_backupOracleAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum PriceFeed.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PriceFeed.sol\":\"PriceFeed\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"contracts/PriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/IBaseFeeOracle.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./dependencies/BaseMath.sol\\\";\\nimport \\\"./dependencies/LiquityMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nerror MainOracleDisabled();\\n\\n/*\\n * PriceFeed for production deployment, to be connected to Main Oracle's live BaseFee:stWStETH aggregator reference\\n * contract, and a Backup oracle contract.\\n *\\n * The PriceFeed uses \\\"Main Oracle\\\" as primary oracle, and \\\"Back Up\\\" as fallback. It contains logic for\\n * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\\n * \\\"Main Oracle\\\" oracle.\\n *\\n * Based on Liquity Protocol.\\n */\\ncontract PriceFeed is Ownable, BaseMath {\\n    string public constant NAME = \\\"PriceFeed\\\";\\n\\n    IBaseFeeOracle public mainOracle; // Main Oracle aggregator\\n    IBaseFeeOracle public backupOracle; // Backup Oracle\\n\\n    // HEDGEHOG UPDATES: decrease to 1\\n    uint public constant TARGET_DIGITS = 1;\\n\\n    // Maximum time period allowed since Main Oracle's latest round data blockNumber, beyond which Main Oracle is considered frozen.\\n    uint public constant TIMEOUT = 69;\\n\\n    // HEDGEHOG UPDATES: decrease to 176\\n    // Maximum deviation allowed between two consecutive Main oracle prices. Hedgehog oracles are getting updated in case there is a 5% diviation price\\n    // Meaning that there might be max 17.5% price diviation between rounds\\n    uint public constant MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND =\\n        176;\\n\\n    /*\\n     * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\\n     * to return to using the Main oracle. 18-digit precision.\\n     */\\n    uint public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\\n\\n    // The last good price seen from an oracle by Hedgehog\\n    uint256 public lastGoodPrice;\\n\\n    struct Response {\\n        int256 answer;\\n        uint64 blockNumber;\\n        uint80 roundId;\\n    }\\n\\n    enum Status {\\n        mainOracleWorking,\\n        usingBackupMainUntrusted,\\n        bothOraclesUntrusted,\\n        usingBackupMainFrozen,\\n        usingMainBackupUntrusted\\n    }\\n\\n    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt\\n    Status public status;\\n\\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\\n    event PriceFeedStatusChanged(Status newStatus);\\n\\n    // --- Dependency setters ---\\n\\n    function setAddresses(\\n        address _mainOracleAddress,\\n        address _backupOracleAddress\\n    ) external onlyOwner {\\n        Address.isContract(_mainOracleAddress);\\n        Address.isContract(_backupOracleAddress);\\n\\n        mainOracle = IBaseFeeOracle(_mainOracleAddress);\\n        backupOracle = IBaseFeeOracle(_backupOracleAddress);\\n\\n        // Explicitly set initial system status\\n        status = Status.mainOracleWorking;\\n\\n        // Get an initial price from Main Oracle to serve as first reference for lastGoodPrice\\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\\n            mainOracleResponse.roundId\\n        );\\n\\n        if (\\n            _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse) ||\\n            _mainOracleIsFrozen(mainOracleResponse)\\n        ) {\\n            revert MainOracleDisabled();\\n        }\\n\\n        _storeGoodPrice(mainOracleResponse, mainOracle.decimals());\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Functions ---\\n\\n    /*\\n     * fetchPrice():\\n     * Returns the latest price obtained from the Oracle. Called by Hedgehog functions that require a current price.\\n     *\\n     * Also callable by anyone externally.\\n     *\\n     * Non-view function - it stores the last good price seen by Liquity.\\n     *\\n     * Uses a main oracle and a fallback oracle in case main one fails. If both fail,\\n     * it uses the last good price seen by Hedgehog.\\n     *\\n     * Hedgehog updates: now both oracles are not allowed to have a price diviation of more then 12.5% between consecutive block\\n     */\\n    function fetchPrice() external returns (uint256) {\\n        // Get current and previous price data from Main oracle, and current price data from Backup\\n        uint8 decimals = mainOracle.decimals();\\n\\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\\n            mainOracleResponse.roundId\\n        );\\n        Response memory backupOracleResponse = _getCurrentBackupResponse();\\n        Response memory prevBackupOracleResponse = _getPrevBackupOracleResponse(\\n            backupOracleResponse.roundId\\n        );\\n        uint8 backupDecimals = backupOracle.decimals();\\n\\n        // --- CASE 1: System fetched last price from Main Oracle  ---\\n        if (status == Status.mainOracleWorking) {\\n            // If Main Oracle is broken, try backup\\n\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                // If backup is broken then both oracles are untrusted, so return the last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n                /*\\n                 * If Backup is only frozen but otherwise returning valid data, return the last good price.\\n                 */\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    _changeStatus(Status.usingBackupMainUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Main Oracle is broken and Backup is working, switch to Backup and return current Backup price\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If Main oracle is frozen, try Backup\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                // If Backup is broken too, remember Backup broke, and return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.usingMainBackupUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is frozen or working, remember Main Oracle froze, and switch to backup\\n                _changeStatus(Status.usingBackupMainFrozen);\\n\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is working, use it\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If MainOracle price has changed by > 12,5% between two consecutive rounds, compare it to Backup's price\\n            if (\\n                _priceChangeAboveMax(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    decimals\\n                )\\n            ) {\\n                // If Backup is broken, both oracles are untrusted, and return last good price\\n                if (\\n                    _backupOracleIsBroken(backupOracleResponse) ||\\n                    _priceChangeAboveMax(\\n                        backupOracleResponse,\\n                        prevBackupOracleResponse,\\n                        decimals\\n                    )\\n                ) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                if (\\n                    _backupIsFrozen(backupOracleResponse)\\n                ) // If backup is frozen, switch to backup and return last good price\\n                {\\n                    _changeStatus(Status.usingBackupMainUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n                return _storeGoodPrice(backupOracleResponse, decimals);\\n            }\\n\\n            // If Main oracle is working and Backup is broken, remember Backup is broken\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.usingMainBackupUntrusted);\\n            }\\n\\n            // If MainOracle is working, return MainOracle current price (no status change)\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n\\n        // --- CASE 2: The system fetched last price from Backup ---\\n        if (status == Status.usingBackupMainUntrusted) {\\n            if (\\n                _priceChangeAboveMax(\\n                    backupOracleResponse,\\n                    prevBackupOracleResponse,\\n                    decimals\\n                )\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n            // If both Backup and Main oracle are live, unbroken, and reporting similar prices, switch back to Main\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            /*\\n             * If Backup is only frozen but otherwise returning valid data, just return the last good price.\\n             * Backup may need to be tipped to return current data.\\n             */\\n            if (_backupIsFrozen(backupOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            // Otherwise, use Backup price\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n\\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\\n        if (status == Status.bothOraclesUntrusted) {\\n            /*\\n             * If both oracles are now live, unbroken and similar price, we assume that they are reporting\\n             * accurately, and so we switch back to Main Oracle.\\n             */\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\\n            return lastGoodPrice;\\n        }\\n\\n        // --- CASE 4: Using Backup, and Main Oracle is frozen ---\\n        if (status == Status.usingBackupMainFrozen) {\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                // If both Oracles are broken, return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Main Oracle is broken, remember it and switch to using Backup\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is working, return Backup current price\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                // if Main Oracle is frozen and Backup is broken, remember Backup broke, and return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.usingMainBackupUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If both are frozen, just use lastGoodPrice\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // if Main Oracle is frozen and Backup is working, keep using Backup (no status change)\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // if Main Oracle is live and Backup is broken, remember Backup broke, and return Main Oracle price\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.usingMainBackupUntrusted);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // If Main Oracle is live and Backup is frozen, just use last good price (no status change) since we have no basis for comparison\\n            if (_backupIsFrozen(backupOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle is live and Backup is working, compare prices. Switch to Main Oracle\\n            // if prices are within 5%, and return Main Oracle price.\\n            if (\\n                _bothOraclesSimilarPrice(\\n                    mainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // Otherwise if Main Oracle is live but price not within 5% of Backup, distrust Main Oracle, and return Backup price\\n            _changeStatus(Status.usingBackupMainUntrusted);\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n\\n        // --- CASE 5: Using Main Oracle, Back up is untrusted ---\\n        if (status == Status.usingMainBackupUntrusted) {\\n            // If Main Oracle breaks, now both oracles are untrusted\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle is frozen, return last good price (no status change)\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle and Backup are both live, unbroken and similar price, switch back to Main Oracle working and return MainOracle price\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // If Main Oracle is live but deviated >17.5% from it's previous price and Backup is still untrusted, switch\\n            // to bothOraclesUntrusted and return last good price\\n            if (\\n                _priceChangeAboveMax(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    decimals\\n                )\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // Otherwise if Main Oracle is live and deviated <50% from it's previous price and Backup is still untrusted,\\n            // return Main Oracle price (no status change)\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n    }\\n\\n    // --- Helper functions ---\\n\\n    /* Main Oracle is considered broken if its current or previous round data is in any way bad. We check the previous round\\n     * for two reasons:\\n     *\\n     * 1) It is necessary data for the price deviation check in case 1,\\n     * and\\n     * 2) Main Oracle is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\\n     * peace of mind when using or returning to Main Oracle.\\n     */\\n    function _mainOracleIsBroken(\\n        Response memory _currentResponse,\\n        Response memory _prevResponse\\n    ) internal view returns (bool) {\\n        return\\n            _badMainOracleResponse(_currentResponse) ||\\n            _badMainOracleResponse(_prevResponse);\\n    }\\n\\n    function _badMainOracleResponse(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        // Check for an invalid roundId that is 0\\n        if (_response.roundId == 0) {\\n            return true;\\n        }\\n        // Check for an invalid timeStamp that is 0, or in the future\\n        if (\\n            _response.blockNumber == 0 || _response.blockNumber > block.number\\n        ) {\\n            return true;\\n        }\\n        // Check for non-positive price\\n        if (_response.answer <= 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _mainOracleIsFrozen(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        return (block.number - _response.blockNumber) > TIMEOUT;\\n    }\\n\\n    function _priceChangeAboveMax(\\n        Response memory _currentResponse,\\n        Response memory _prevResponse,\\n        uint8 _decimals\\n    ) internal pure returns (bool) {\\n        uint currentScaledPrice = _scalePriceByDigits(\\n            uint256(_currentResponse.answer),\\n            _decimals\\n        );\\n        uint prevScaledPrice = _scalePriceByDigits(\\n            uint256(_prevResponse.answer),\\n            _decimals\\n        );\\n\\n        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);\\n        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);\\n\\n        /*\\n         * Use the larger price as the denominator:\\n         * - If price decreased, the percentage deviation is in relation to the the previous price.\\n         * - If price increased, the percentage deviation is in relation to the current price.\\n         */\\n        uint difference = maxPrice - minPrice;\\n        uint threshold = (maxPrice *\\n            MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND) / 1000; // 17.5% of max price\\n\\n        // Return true if price has more than doubled, or more than halved.\\n        return difference > threshold;\\n    }\\n\\n    function _backupOracleIsBroken(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        // Check for an invalid timeStamp that is 0, or in the future\\n        if (\\n            _response.blockNumber == 0 ||\\n            _response.blockNumber > block.timestamp\\n        ) {\\n            return true;\\n        }\\n        // Check for zero price\\n        if (_response.answer == 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _backupIsFrozen(\\n        Response memory _backupResponse\\n    ) internal view returns (bool) {\\n        return block.number - _backupResponse.blockNumber > TIMEOUT;\\n    }\\n\\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n        Response memory _mainOracleResponse,\\n        Response memory _prevMainOracleResponse,\\n        Response memory _backupResponse,\\n        uint8 _mainOracleDecimals,\\n        uint8 _backupOracleDecimals\\n    ) internal view returns (bool) {\\n        // Return false if either oracle is broken or frozen\\n        if (\\n            _backupOracleIsBroken(_backupResponse) ||\\n            _backupIsFrozen(_backupResponse) ||\\n            _mainOracleIsBroken(_mainOracleResponse, _prevMainOracleResponse) ||\\n            _mainOracleIsFrozen(_mainOracleResponse)\\n        ) {\\n            return false;\\n        }\\n\\n        return\\n            _bothOraclesSimilarPrice(\\n                _mainOracleResponse,\\n                _backupResponse,\\n                _mainOracleDecimals,\\n                _backupOracleDecimals\\n            );\\n    }\\n\\n    function _bothOraclesSimilarPrice(\\n        Response memory _mainOracleResponse,\\n        Response memory _backupResponse,\\n        uint8 _mainOracleDecimals,\\n        uint8 _backupOracleDecimals\\n    ) internal pure returns (bool) {\\n        uint scaledMainOraclePrice = _scalePriceByDigits(\\n            uint256(_mainOracleResponse.answer),\\n            _mainOracleDecimals\\n        );\\n        uint scaledBackupPrice = _scalePriceByDigits(\\n            uint256(_backupResponse.answer),\\n            _backupOracleDecimals\\n        );\\n\\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\\n        uint minPrice = LiquityMath._min(\\n            scaledBackupPrice,\\n            scaledMainOraclePrice\\n        );\\n        uint maxPrice = LiquityMath._max(\\n            scaledBackupPrice,\\n            scaledMainOraclePrice\\n        );\\n        uint percentPriceDifference = ((maxPrice - minPrice) *\\n            DECIMAL_PRECISION) / minPrice;\\n\\n        /*\\n         * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting\\n         * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\\n         */\\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\\n    }\\n\\n    function _scalePriceByDigits(\\n        uint _price,\\n        uint _answerDigits\\n    ) internal pure returns (uint) {\\n        /*\\n         * Convert the price returned by an oracle to an 18-digit decimal for use by Hedgehog.\\n         * At date of Hedgehog launch, MaainOracle uses an 8-digit price, but we also handle the possibility of\\n         * future changes.\\n         */\\n        uint price;\\n        // TODO: Double check that\\n        if (_answerDigits >= TARGET_DIGITS) {\\n            // Scale the returned price value down to Hedgehog's target precision\\n            price = _price / (10 ** (_answerDigits - TARGET_DIGITS));\\n        } else if (_answerDigits < TARGET_DIGITS) {\\n            // Scale the returned price value up to Hedgehog's target precision\\n            price = _price * (10 ** (TARGET_DIGITS - _answerDigits));\\n        }\\n        return price;\\n    }\\n\\n    function _changeStatus(Status _status) internal {\\n        status = _status;\\n        emit PriceFeedStatusChanged(_status);\\n    }\\n\\n    function _storePrice(uint _currentPrice) internal {\\n        lastGoodPrice = _currentPrice;\\n        emit LastGoodPriceUpdated(_currentPrice);\\n    }\\n\\n    function _storeGoodPrice(\\n        Response memory _response,\\n        uint8 _decimals\\n    ) internal returns (uint) {\\n        uint scaledPrice = _scalePriceByDigits(\\n            uint256(_response.answer),\\n            _decimals\\n        );\\n\\n        _storePrice(scaledPrice);\\n\\n        return scaledPrice;\\n    }\\n\\n    function _getCurrentMainOracleResponse()\\n        internal\\n        view\\n        returns (Response memory response)\\n    {\\n        // Try to get latest price data:\\n        try mainOracle.latestRoundData() returns (\\n            int256 answer,\\n            uint64 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 roundId\\n        ) {\\n            response.roundId = roundId;\\n            response.answer = answer;\\n            response.blockNumber = uint64(currentChainBN);\\n\\n            return response;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts, return a zero response with success = false\\n            return response;\\n        }\\n    }\\n\\n    function _getCurrentBackupResponse()\\n        internal\\n        view\\n        returns (Response memory response)\\n    {\\n        // Try to get latest price data:\\n        try backupOracle.latestRoundData() returns (\\n            int256 answer,\\n            uint64 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 roundId\\n        ) {\\n            response.roundId = roundId;\\n            response.answer = answer;\\n            response.blockNumber = uint64(currentChainBN);\\n\\n            return response;\\n        } catch {\\n            // If call to Backup aggregator reverts, return a zero response with success = false\\n            return response;\\n        }\\n    }\\n\\n    function _getPrevOracleResponse(\\n        uint80 _currentRoundId\\n    ) internal view returns (Response memory prevMainOracleResponse) {\\n        /*\\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\\n         */\\n\\n        // Try to get the price data from the previous round:\\n        try mainOracle.getRoundData(_currentRoundId - 1) returns (\\n            int256 answer,\\n            uint64 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 roundId\\n        ) {\\n            // If call to Hedgehog succeeds, return the response and success = true\\n            prevMainOracleResponse.roundId = roundId;\\n            prevMainOracleResponse.answer = answer;\\n            prevMainOracleResponse.blockNumber = uint64(currentChainBN);\\n            return prevMainOracleResponse;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts, return a zero response with success = false\\n            return prevMainOracleResponse;\\n        }\\n    }\\n\\n    function _getPrevBackupOracleResponse(\\n        uint80 _currentRoundId\\n    ) internal view returns (Response memory prevBackupOracleResponse) {\\n        /*\\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\\n         */\\n\\n        // Try to get the price data from the previous round:\\n        try backupOracle.getRoundData(_currentRoundId - 1) returns (\\n            int256 answer,\\n            uint64 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 roundId\\n        ) {\\n            // If call to Hedgehog succeeds, return the response and success = true\\n            prevBackupOracleResponse.roundId = roundId;\\n            prevBackupOracleResponse.answer = answer;\\n            prevBackupOracleResponse.blockNumber = uint64(currentChainBN);\\n            return prevBackupOracleResponse;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts, return a zero response with success = false\\n            return prevBackupOracleResponse;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf46d2129aa7783b72d0b1c717102e334416375a4303cab9001adfedc5ed81e47\",\"license\":\"MIT\"},\"contracts/dependencies/BaseMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ncontract BaseMath {\\n    uint public constant DECIMAL_PRECISION = 1e18;\\n}\\n\",\"keccak256\":\"0x5338502be04e32035bbf0310600c8724281edc81b312f5d89c683b23d0bb3fa7\",\"license\":\"MIT\"},\"contracts/dependencies/LiquityMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @notice A fork of Liquity Math library with an upgraded pragma\\n *\\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\\n */\\n\\nlibrary LiquityMath {\\n    using SafeMath for uint;\\n\\n    uint internal constant DECIMAL_PRECISION = 1e18;\\n\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n     *\\n     * - Making it \\u201ctoo high\\u201d could lead to overflows.\\n     * - Making it \\u201ctoo low\\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\n     *\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 WStETH,\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n     *\\n     */\\n    uint internal constant NICR_PRECISION = 1e20;\\n\\n    function _min(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a < _b) ? _a : _b;\\n    }\\n\\n    function _max(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a >= _b) ? _a : _b;\\n    }\\n\\n    /*\\n     * Multiply two decimal numbers and use normal rounding rules:\\n     * -round product up if 19'th mantissa digit >= 5\\n     * -round product down if 19'th mantissa digit < 5\\n     *\\n     * Used only inside the exponentiation, _decPow().\\n     */\\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\\n        uint prod_xy = x.mul(y);\\n\\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\\n    }\\n\\n    /*\\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n     *\\n     * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\n     *\\n     * Called by two functions that represent time in units of minutes:\\n     * 1) TroveManager._calcDecayedBaseRate\\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\\n     *\\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n     * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n     *\\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n     * negligibly different from just passing the cap, since:\\n     *\\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n     */\\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\\n        if (_minutes > 525600000) {\\n            _minutes = 525600000;\\n        } // cap to avoid overflow\\n\\n        if (_minutes == 0) {\\n            return DECIMAL_PRECISION;\\n        }\\n\\n        uint y = DECIMAL_PRECISION;\\n        uint x = _base;\\n        uint n = _minutes;\\n\\n        // Exponentiation-by-squaring\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x = decMul(x, x);\\n                n = n.div(2);\\n            } else {\\n                // if (n % 2 != 0)\\n                y = decMul(x, y);\\n                x = decMul(x, x);\\n                n = (n.sub(1)).div(2);\\n            }\\n        }\\n\\n        return decMul(x, y);\\n    }\\n\\n    function _getAbsoluteDifference(\\n        uint _a,\\n        uint _b\\n    ) internal pure returns (uint) {\\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\\n    }\\n\\n    function _computeNominalCR(\\n        uint _coll,\\n        uint _debt\\n    ) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            return _coll.mul(NICR_PRECISION).div(_debt);\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return 2 ** 256 - 1;\\n        }\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * Change coll ration calculation from [coll] * [price] / [debt] to\\n     * [coll] / [debt] / [gasPrice]\\n     */\\n    function _computeCR(\\n        uint _coll,\\n        uint _debt,\\n        uint _price\\n    ) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            uint newCollRatio = _coll.mul(DECIMAL_PRECISION).div(_debt).div(\\n                _price\\n            );\\n\\n            return newCollRatio;\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return 2 ** 256 - 1;\\n        }\\n    }\\n\\n    function _findPriceBelowMCR(\\n        uint256 _coll,\\n        uint256 _debt,\\n        uint256 _startPrice,\\n        uint _mcr\\n    ) internal pure returns (uint256) {\\n        uint256 step = 1; // Starting with the smallest step size\\n        uint256 GWEI = 10 ** 9;\\n        uint256 previousPrice = _startPrice * GWEI; // To track previous iteration's price\\n\\n        for (\\n            uint256 price = _startPrice * GWEI;\\n            price <= 750 * GWEI;\\n            price += step\\n        ) {\\n            uint256 cr = _computeCR(_coll, _debt, price);\\n\\n            if (cr < _mcr) {\\n                // Start decreasing the price to find the exact threshold\\n                for (\\n                    uint256 decreasedPrice = previousPrice;\\n                    decreasedPrice <= price &&\\n                        decreasedPrice >= _startPrice * GWEI; // Added protection against underflow\\n                    decreasedPrice -= GWEI\\n                ) {\\n                    if (_computeCR(_coll, _debt, decreasedPrice) < _mcr) {\\n                        return decreasedPrice;\\n                    }\\n                }\\n            }\\n\\n            // Dynamically adjust step size\\n            if (cr < (_mcr - 200000000000000000)) {\\n                step = 20 * GWEI; // Increase step size if CR is much lower than MCR\\n            } else if (cr > (_mcr + 50000000000000000)) {\\n                step = GWEI; // Decrease step size if CR is much higher than MCR\\n            }\\n\\n            previousPrice = price; // Update previous price for the next iteration\\n        }\\n\\n        return 0; // return 0 if no price was found that brings the CR below MCR\\n    }\\n}\\n\",\"keccak256\":\"0x46a963cee07c23aeea182635a2009071b29e8f7be4411332c09544598df3cffc\",\"license\":\"MIT\"},\"contracts/interfaces/IBaseFeeOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IBaseFeeOracle {\\n    function decimals() external view returns (uint8);\\n\\n    function version() external view returns (uint256);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(\\n        uint80 _roundId\\n    )\\n        external\\n        view\\n        returns (\\n            int256 answer,\\n            uint64 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 roundId\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            int256 answer,\\n            uint64 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 roundId\\n        );\\n}\\n\",\"keccak256\":\"0xb2699368ee3df47a4734f11fcf0c880baf6f7ff8989b2f76948a0240d6bf4d26\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6111e28061007e6000396000f3fe608060405234801561001057600080fd5b50600436106100d55760003560e01c806386800a961161008757806386800a96146101635780638da5cb5b1461016b57806390107afe1461017c578063a20baee61461018f578063a3f4df7e1461019e578063c8e07115146101d3578063f2fde38b146101e6578063f56f48f2146101f957600080fd5b80630490be83146100da5780630fdb11cf146100f65780631be5c92f146100fe578063200d2ed21461010657806345079cb414610120578063715018a61461012e578063836efd3114610138575b600080fd5b6100e360035481565b6040519081526020015b60405180910390f35b6100e3610201565b6100e3600181565b6004546101139060ff1681565b6040516100ed9190610ed2565b6100e366b1a2bc2ec5000081565b6101366106af565b005b60025461014b906001600160a01b031681565b6040516001600160a01b0390911681526020016100ed565b6100e360b081565b6000546001600160a01b031661014b565b61013661018a366004610f11565b6106c3565b6100e3670de0b6b3a764000081565b6101c660405180604001604052806009815260200168141c9a58d95199595960ba1b81525081565b6040516100ed9190610f44565b60015461014b906001600160a01b031681565b6101366101f4366004610f92565b6107e8565b6100e3604581565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610257573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027b9190610fad565b90506000610287610866565b905060006102988260400151610907565b905060006102a46109c0565b905060006102b58260400151610a34565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103309190610fad565b905060006004805460ff169081111561034b5761034b610ebc565b0361048f5761035a8585610a58565b156103bc5761036883610a7b565b15610385576103776002610acb565b600354965050505050505090565b61038e83610b28565b1561039d576103776001610acb565b6103a76001610acb565b6103b18382610b4c565b965050505050505090565b6103c585610b28565b15610408576103d383610a7b565b156103e2576103776004610acb565b6103ec6003610acb565b6103f583610b28565b156103a757600354965050505050505090565b610413858588610b6b565b1561046d5761042183610a7b565b806104325750610432838388610b6b565b15610441576103776002610acb565b61044a83610b28565b15610459576103776001610acb565b6104636001610acb565b6103b18387610b4c565b61047683610a7b565b15610485576104856004610acb565b6103b18587610b4c565b60016004805460ff16908111156104a8576104a8610ebc565b03610517576104b8838388610b6b565b156104c7576103776002610acb565b6104d48585858985610bea565b156104e3576104856000610acb565b6104ec83610a7b565b156104fb576103776002610acb565b61050483610b28565b1561048557600354965050505050505090565b60026004805460ff169081111561053057610530610ebc565b03610551576105428585858985610bea565b15610377576104856000610acb565b60036004805460ff169081111561056a5761056a610ebc565b0361061f576105798585610a58565b156105a05761058783610a7b565b15610596576103776002610acb565b6104fb6001610acb565b6105a985610b28565b156105c6576105b783610a7b565b156104fb576103776004610acb565b6105cf83610a7b565b156105de576104856004610acb565b6105e783610b28565b156105fa57600354965050505050505090565b61060685848884610c48565b15610615576104856000610acb565b6104856001610acb565b6004805460ff168181111561063657610636610ebc565b036106a6576106458585610a58565b15610654576103776002610acb565b61065d85610b28565b1561067057600354965050505050505090565b61067d8585858985610bea565b1561068c576104856000610acb565b610697858588610b6b565b15610485576103776002610acb565b50505050505090565b6106b7610cd1565b6106c16000610d2b565b565b6106cb610cd1565b600180546001600160a01b038481166001600160a01b03199283161790925560028054928416929091169190911790556004805460ff19169055600061070f610866565b905060006107208260400151610907565b905061072c8282610a58565b8061073b575061073b82610b28565b156107595760405163062a774160e51b815260040160405180910390fd5b6107d982600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d49190610fad565b610b4c565b506107e26106af565b50505050565b6107f0610cd1565b6001600160a01b03811661085a5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61086381610d2b565b50565b61086e610e9c565b600160009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b8152600401608060405180830381865afa9250505080156108dd575060408051601f3d908101601f191682019092526108da91810190610fd0565b60015b6108e45790565b6001600160501b03166040850152918352506001600160401b0316602082015290565b61090f610e9c565b600180546001600160a01b031690639a6fc8f59061092d9085611049565b6040516001600160e01b031960e084901b1681526001600160501b039091166004820152602401608060405180830381865afa92505050801561098d575060408051601f3d908101601f1916820190925261098a91810190610fd0565b60015b61099657919050565b6001600160501b03166040850152918352506001600160401b03166020820152919050565b919050565b6109c8610e9c565b600260009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b8152600401608060405180830381865afa9250505080156108dd575060408051601f3d908101601f191682019092526108da91810190610fd0565b610a3c610e9c565b6002546001600160a01b0316639a6fc8f561092d600185611049565b6000610a6383610d7b565b80610a725750610a7282610d7b565b90505b92915050565b600081602001516001600160401b031660001480610aa557504282602001516001600160401b0316115b15610ab257506001919050565b8151600003610ac357506001919050565b506000919050565b6004805482919060ff191660018383811115610ae957610ae9610ebc565b02179055507f5c57579a8214fe4f710c1c56fa829f045b9fa6d225a744225a30c32188064d4e81604051610b1d9190610ed2565b60405180910390a150565b6000604582602001516001600160401b031643610b459190611070565b1192915050565b600080610b6084600001518460ff16610dde565b9050610a7281610e41565b600080610b7f85600001518460ff16610dde565b90506000610b9485600001518560ff16610dde565b90506000610ba28383610e76565b90506000610bb08484610e8c565b90506000610bbe8383611070565b905060006103e8610bd060b085611083565b610bda919061109a565b9091119998505050505050505050565b6000610bf584610a7b565b80610c045750610c0484610b28565b80610c145750610c148686610a58565b80610c235750610c2386610b28565b15610c3057506000610c3f565b610c3c86858585610c48565b90505b95945050505050565b600080610c5c86600001518560ff16610dde565b90506000610c7186600001518560ff16610dde565b90506000610c7f8284610e76565b90506000610c8d8385610e8c565b9050600082670de0b6b3a7640000610ca58285611070565b610caf9190611083565b610cb9919061109a565b66b1a2bc2ec5000010159a9950505050505050505050565b6000546001600160a01b031633146106c15760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610851565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600081604001516001600160501b0316600003610d9a57506001919050565b60208201516001600160401b03161580610dc057504382602001516001600160401b0316115b15610dcd57506001919050565b8151600012610ac357506001919050565b60008060018310610e1057610df4600184611070565b610dff90600a6111a0565b610e09908561109a565b9050610a72565b6001831015610a7257610e24836001611070565b610e2f90600a6111a0565b610e399085611083565b949350505050565b60038190556040518181527f4d29de21de555af78a62fc82dd4bc05e9ae5b0660a37f04729527e0f22780cd390602001610b1d565b6000818310610e855781610a72565b5090919050565b600081831015610e855781610a72565b604080516060810182526000808252602082018190529181019190915290565b634e487b7160e01b600052602160045260246000fd5b6020810160058310610ef457634e487b7160e01b600052602160045260246000fd5b91905290565b80356001600160a01b03811681146109bb57600080fd5b60008060408385031215610f2457600080fd5b610f2d83610efa565b9150610f3b60208401610efa565b90509250929050565b600060208083528351808285015260005b81811015610f7157858101830151858201604001528201610f55565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215610fa457600080fd5b610a7282610efa565b600060208284031215610fbf57600080fd5b815160ff81168114610a7257600080fd5b60008060008060808587031215610fe657600080fd5b8451935060208501516001600160401b038116811461100457600080fd5b6040860151606087015191945092506001600160501b038116811461102857600080fd5b939692955090935050565b634e487b7160e01b600052601160045260246000fd5b6001600160501b0382811682821603908082111561106957611069611033565b5092915050565b81810381811115610a7557610a75611033565b8082028115828204841417610a7557610a75611033565b6000826110b757634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156110f75781600019048211156110dd576110dd611033565b808516156110ea57918102915b93841c93908002906110c1565b509250929050565b60008261110e57506001610a75565b8161111b57506000610a75565b8160018114611131576002811461113b57611157565b6001915050610a75565b60ff84111561114c5761114c611033565b50506001821b610a75565b5060208310610133831016604e8410600b841016171561117a575081810a610a75565b61118483836110bc565b806000190482111561119857611198611033565b029392505050565b6000610a7283836110ff56fea2646970667358221220b7a3f2b8b4b18042ebc41010b6e5a973a58f48733bf53d2b7aca6509f1e4eb2664736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100d55760003560e01c806386800a961161008757806386800a96146101635780638da5cb5b1461016b57806390107afe1461017c578063a20baee61461018f578063a3f4df7e1461019e578063c8e07115146101d3578063f2fde38b146101e6578063f56f48f2146101f957600080fd5b80630490be83146100da5780630fdb11cf146100f65780631be5c92f146100fe578063200d2ed21461010657806345079cb414610120578063715018a61461012e578063836efd3114610138575b600080fd5b6100e360035481565b6040519081526020015b60405180910390f35b6100e3610201565b6100e3600181565b6004546101139060ff1681565b6040516100ed9190610ed2565b6100e366b1a2bc2ec5000081565b6101366106af565b005b60025461014b906001600160a01b031681565b6040516001600160a01b0390911681526020016100ed565b6100e360b081565b6000546001600160a01b031661014b565b61013661018a366004610f11565b6106c3565b6100e3670de0b6b3a764000081565b6101c660405180604001604052806009815260200168141c9a58d95199595960ba1b81525081565b6040516100ed9190610f44565b60015461014b906001600160a01b031681565b6101366101f4366004610f92565b6107e8565b6100e3604581565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610257573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027b9190610fad565b90506000610287610866565b905060006102988260400151610907565b905060006102a46109c0565b905060006102b58260400151610a34565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103309190610fad565b905060006004805460ff169081111561034b5761034b610ebc565b0361048f5761035a8585610a58565b156103bc5761036883610a7b565b15610385576103776002610acb565b600354965050505050505090565b61038e83610b28565b1561039d576103776001610acb565b6103a76001610acb565b6103b18382610b4c565b965050505050505090565b6103c585610b28565b15610408576103d383610a7b565b156103e2576103776004610acb565b6103ec6003610acb565b6103f583610b28565b156103a757600354965050505050505090565b610413858588610b6b565b1561046d5761042183610a7b565b806104325750610432838388610b6b565b15610441576103776002610acb565b61044a83610b28565b15610459576103776001610acb565b6104636001610acb565b6103b18387610b4c565b61047683610a7b565b15610485576104856004610acb565b6103b18587610b4c565b60016004805460ff16908111156104a8576104a8610ebc565b03610517576104b8838388610b6b565b156104c7576103776002610acb565b6104d48585858985610bea565b156104e3576104856000610acb565b6104ec83610a7b565b156104fb576103776002610acb565b61050483610b28565b1561048557600354965050505050505090565b60026004805460ff169081111561053057610530610ebc565b03610551576105428585858985610bea565b15610377576104856000610acb565b60036004805460ff169081111561056a5761056a610ebc565b0361061f576105798585610a58565b156105a05761058783610a7b565b15610596576103776002610acb565b6104fb6001610acb565b6105a985610b28565b156105c6576105b783610a7b565b156104fb576103776004610acb565b6105cf83610a7b565b156105de576104856004610acb565b6105e783610b28565b156105fa57600354965050505050505090565b61060685848884610c48565b15610615576104856000610acb565b6104856001610acb565b6004805460ff168181111561063657610636610ebc565b036106a6576106458585610a58565b15610654576103776002610acb565b61065d85610b28565b1561067057600354965050505050505090565b61067d8585858985610bea565b1561068c576104856000610acb565b610697858588610b6b565b15610485576103776002610acb565b50505050505090565b6106b7610cd1565b6106c16000610d2b565b565b6106cb610cd1565b600180546001600160a01b038481166001600160a01b03199283161790925560028054928416929091169190911790556004805460ff19169055600061070f610866565b905060006107208260400151610907565b905061072c8282610a58565b8061073b575061073b82610b28565b156107595760405163062a774160e51b815260040160405180910390fd5b6107d982600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d49190610fad565b610b4c565b506107e26106af565b50505050565b6107f0610cd1565b6001600160a01b03811661085a5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61086381610d2b565b50565b61086e610e9c565b600160009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b8152600401608060405180830381865afa9250505080156108dd575060408051601f3d908101601f191682019092526108da91810190610fd0565b60015b6108e45790565b6001600160501b03166040850152918352506001600160401b0316602082015290565b61090f610e9c565b600180546001600160a01b031690639a6fc8f59061092d9085611049565b6040516001600160e01b031960e084901b1681526001600160501b039091166004820152602401608060405180830381865afa92505050801561098d575060408051601f3d908101601f1916820190925261098a91810190610fd0565b60015b61099657919050565b6001600160501b03166040850152918352506001600160401b03166020820152919050565b919050565b6109c8610e9c565b600260009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b8152600401608060405180830381865afa9250505080156108dd575060408051601f3d908101601f191682019092526108da91810190610fd0565b610a3c610e9c565b6002546001600160a01b0316639a6fc8f561092d600185611049565b6000610a6383610d7b565b80610a725750610a7282610d7b565b90505b92915050565b600081602001516001600160401b031660001480610aa557504282602001516001600160401b0316115b15610ab257506001919050565b8151600003610ac357506001919050565b506000919050565b6004805482919060ff191660018383811115610ae957610ae9610ebc565b02179055507f5c57579a8214fe4f710c1c56fa829f045b9fa6d225a744225a30c32188064d4e81604051610b1d9190610ed2565b60405180910390a150565b6000604582602001516001600160401b031643610b459190611070565b1192915050565b600080610b6084600001518460ff16610dde565b9050610a7281610e41565b600080610b7f85600001518460ff16610dde565b90506000610b9485600001518560ff16610dde565b90506000610ba28383610e76565b90506000610bb08484610e8c565b90506000610bbe8383611070565b905060006103e8610bd060b085611083565b610bda919061109a565b9091119998505050505050505050565b6000610bf584610a7b565b80610c045750610c0484610b28565b80610c145750610c148686610a58565b80610c235750610c2386610b28565b15610c3057506000610c3f565b610c3c86858585610c48565b90505b95945050505050565b600080610c5c86600001518560ff16610dde565b90506000610c7186600001518560ff16610dde565b90506000610c7f8284610e76565b90506000610c8d8385610e8c565b9050600082670de0b6b3a7640000610ca58285611070565b610caf9190611083565b610cb9919061109a565b66b1a2bc2ec5000010159a9950505050505050505050565b6000546001600160a01b031633146106c15760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610851565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600081604001516001600160501b0316600003610d9a57506001919050565b60208201516001600160401b03161580610dc057504382602001516001600160401b0316115b15610dcd57506001919050565b8151600012610ac357506001919050565b60008060018310610e1057610df4600184611070565b610dff90600a6111a0565b610e09908561109a565b9050610a72565b6001831015610a7257610e24836001611070565b610e2f90600a6111a0565b610e399085611083565b949350505050565b60038190556040518181527f4d29de21de555af78a62fc82dd4bc05e9ae5b0660a37f04729527e0f22780cd390602001610b1d565b6000818310610e855781610a72565b5090919050565b600081831015610e855781610a72565b604080516060810182526000808252602082018190529181019190915290565b634e487b7160e01b600052602160045260246000fd5b6020810160058310610ef457634e487b7160e01b600052602160045260246000fd5b91905290565b80356001600160a01b03811681146109bb57600080fd5b60008060408385031215610f2457600080fd5b610f2d83610efa565b9150610f3b60208401610efa565b90509250929050565b600060208083528351808285015260005b81811015610f7157858101830151858201604001528201610f55565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215610fa457600080fd5b610a7282610efa565b600060208284031215610fbf57600080fd5b815160ff81168114610a7257600080fd5b60008060008060808587031215610fe657600080fd5b8451935060208501516001600160401b038116811461100457600080fd5b6040860151606087015191945092506001600160501b038116811461102857600080fd5b939692955090935050565b634e487b7160e01b600052601160045260246000fd5b6001600160501b0382811682821603908082111561106957611069611033565b5092915050565b81810381811115610a7557610a75611033565b8082028115828204841417610a7557610a75611033565b6000826110b757634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156110f75781600019048211156110dd576110dd611033565b808516156110ea57918102915b93841c93908002906110c1565b509250929050565b60008261110e57506001610a75565b8161111b57506000610a75565b8160018114611131576002811461113b57611157565b6001915050610a75565b60ff84111561114c5761114c611033565b50506001821b610a75565b5060208310610133831016604e8410600b841016171561117a575081810a610a75565b61118483836110bc565b806000190482111561119857611198611033565b029392505050565b6000610a7283836110ff56fea2646970667358221220b7a3f2b8b4b18042ebc41010b6e5a973a58f48733bf53d2b7aca6509f1e4eb2664736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 396,
        "contract": "contracts/PriceFeed.sol:PriceFeed",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 10298,
        "contract": "contracts/PriceFeed.sol:PriceFeed",
        "label": "mainOracle",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IBaseFeeOracle)20670"
      },
      {
        "astId": 10301,
        "contract": "contracts/PriceFeed.sol:PriceFeed",
        "label": "backupOracle",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IBaseFeeOracle)20670"
      },
      {
        "astId": 10315,
        "contract": "contracts/PriceFeed.sol:PriceFeed",
        "label": "lastGoodPrice",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 10331,
        "contract": "contracts/PriceFeed.sol:PriceFeed",
        "label": "status",
        "offset": 0,
        "slot": "4",
        "type": "t_enum(Status)10328"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IBaseFeeOracle)20670": {
        "encoding": "inplace",
        "label": "contract IBaseFeeOracle",
        "numberOfBytes": "20"
      },
      "t_enum(Status)10328": {
        "encoding": "inplace",
        "label": "enum PriceFeed.Status",
        "numberOfBytes": "1"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}