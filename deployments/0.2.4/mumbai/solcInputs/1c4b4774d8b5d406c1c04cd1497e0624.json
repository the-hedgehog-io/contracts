{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/BaseFeeLMAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./dependencies/IERC2612.sol\";\nimport \"./dependencies/CheckContract.sol\";\n\n/*\n *\n * Based upon OpenZeppelin's ERC20 contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n *\n * and their EIP2612 (ERC20Permit / ERC712) functionality:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n *\n *\n * --- Functionality added specific to the BaseFeeLMAToken ---\n *\n * 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external\n * transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending BaseFeeLMA directly to a Liquity\n * core contract, when they should rather call the right function.\n *\n * 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move BaseFeeLMA tokens between Liquity <-> user.\n */\n\ncontract BaseFeeLMAToken is CheckContract, IERC20, IERC2612 {\n    using SafeMath for uint256;\n\n    uint256 private _totalSupply;\n    string internal constant _NAME = \"BaseFeeLMA Stablecoin\";\n    string internal constant _SYMBOL = \"BaseFeeLMA\";\n    string internal constant _VERSION = \"1\";\n    uint8 internal constant _DECIMALS = 18;\n\n    // --- Data for EIP2612 ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n\n    mapping(address => uint256) private _nonces;\n\n    // User data for BaseFeeLMA token\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    // --- Addresses ---\n    address public immutable troveManagerAddress;\n    address public immutable stabilityPoolAddress;\n    address public immutable borrowerOperationsAddress;\n\n    // --- Events ---\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n\n    event BaseFeeLMATokenBalanceUpdated(address _user, uint _amount);\n\n    constructor(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress\n    ) {\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        troveManagerAddress = _troveManagerAddress;\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        stabilityPoolAddress = _stabilityPoolAddress;\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        bytes32 hashedName = keccak256(bytes(_NAME));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\n            _TYPE_HASH,\n            hashedName,\n            hashedVersion\n        );\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external {\n        _requireCallerIsBorrowerOperations();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external {\n        _requireCallerIsBOorTroveMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(\n        address _sender,\n        address _poolAddress,\n        uint256 _amount\n    ) external {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(\n        address _poolAddress,\n        address _receiver,\n        uint256 _amount\n    ) external {\n        _requireCallerIsTroveMorSP();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(\n        address account\n    ) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    // --- EIP 2612 Functionality ---\n\n    function domainSeparator() public view override returns (bytes32) {\n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return\n                _buildDomainSeparator(\n                    _TYPE_HASH,\n                    _HASHED_NAME,\n                    _HASHED_VERSION\n                );\n        }\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"BaseFeeLMA: expired deadline\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        amount,\n                        _nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, \"BaseFeeLMA: invalid signature\");\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _chainID() private view returns (uint256 chainID) {\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(typeHash, name, version, _chainID(), address(this))\n            );\n    }\n\n    // --- Internal operations ---\n    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        assert(sender != address(0));\n        assert(recipient != address(0));\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BaseFeeLMA: zero address param\");\n        require(spender != address(0), \"BaseFeeLMA: zero address param\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"BaseFeeLMA: Cannot transfer tokens directly to the BaseFeeLMA token contract or the zero address\"\n        );\n        require(\n            _recipient != stabilityPoolAddress &&\n                _recipient != troveManagerAddress &&\n                _recipient != borrowerOperationsAddress,\n            \"BaseFeeLMA: Cannot transfer tokens directly to the StabilityPool, TroveManager or BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"BaseFeeLMAToken: Caller is not BorrowerOperations\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"BaseFeeLMA: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(\n            msg.sender == stabilityPoolAddress,\n            \"BaseFeeLMA: Caller is not the StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsTroveMorSP() internal view {\n        require(\n            msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"BaseFeeLMA: Caller is neither TroveManager nor StabilityPool\"\n        );\n    }\n\n    // --- Optional functions ---\n\n    function name() external pure returns (string memory) {\n        return _NAME;\n    }\n\n    function symbol() external pure returns (string memory) {\n        return _SYMBOL;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return _DECIMALS;\n    }\n\n    function version() external pure override returns (string memory) {\n        return _VERSION;\n    }\n\n    function permitTypeHash() external pure override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}\n"
    },
    "contracts/dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ncontract CheckContract {\n    /**\n     * Check that the account is an already deployed non-destroyed contract.\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\n     */\n    function checkContract(address _account) internal view {\n        require(_account != address(0), \"Account cannot be zero address\");\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_account)\n        }\n        require(size > 0, \"Account code size cannot be zero\");\n    }\n}\n"
    },
    "contracts/dependencies/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold StETH.\n *\n * See https://eips.stETHeum.org/EIPS/eip-2612.\n *\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.stETHeum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to\n     * a value in the near future. The deadline argument can be set to uint(-1) to\n     * create Permits that effectively never expire.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    function version() external view returns (string memory);\n\n    function permitTypeHash() external view returns (bytes32);\n\n    function domainSeparator() external view returns (bytes32);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}