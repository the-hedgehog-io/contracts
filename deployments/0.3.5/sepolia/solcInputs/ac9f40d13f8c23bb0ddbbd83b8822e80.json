{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/dependencies/BaseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ncontract BaseMath {\n    uint public constant DECIMAL_PRECISION = 1e18;\n}\n"
    },
    "contracts/dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @notice A fork of Liquity Math library with an upgraded pragma\n *\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\n */\n\nlibrary LiquityMath {\n    using SafeMath for uint;\n\n    uint internal constant DECIMAL_PRECISION = 1e18;\n\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it “too high” could lead to overflows.\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 WStETH,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint internal constant NICR_PRECISION = 1e20;\n\n    function _min(uint _a, uint _b) internal pure returns (uint) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /*\n     * Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\n        uint prod_xy = x.mul(y);\n\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\n    }\n\n    /*\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n     *\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     *\n     * Called by two functions that represent time in units of minutes:\n     * 1) TroveManager._calcDecayedBaseRate\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\n     *\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n     *\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n     * negligibly different from just passing the cap, since:\n     *\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n     */\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\n        if (_minutes > 525600000) {\n            _minutes = 525600000;\n        } // cap to avoid overflow\n\n        if (_minutes == 0) {\n            return DECIMAL_PRECISION;\n        }\n\n        uint y = DECIMAL_PRECISION;\n        uint x = _base;\n        uint n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n.div(2);\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n.sub(1)).div(2);\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(\n        uint _a,\n        uint _b\n    ) internal pure returns (uint) {\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\n    }\n\n    function _computeNominalCR(\n        uint _coll,\n        uint _debt\n    ) internal pure returns (uint) {\n        if (_debt > 0) {\n            return _coll.mul(NICR_PRECISION).div(_debt);\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n\n    /**\n     * HEDGEHOG UPDATES:\n     * Change coll ration calculation from [coll] * [price] / [debt] to\n     * [coll] / [debt] / [gasPrice] * 1e36\n     */\n    function _computeCR(\n        uint _coll,\n        uint _debt,\n        uint _price\n    ) internal pure returns (uint) {\n        if (_debt > 0) {\n            uint newCollRatio = _coll\n                .mul(DECIMAL_PRECISION)\n                .div(_debt)\n                .mul(DECIMAL_PRECISION)\n                .div(_price);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n\n    function _findPriceBelowMCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint _mcr\n    ) internal pure returns (uint256 price) {\n        // Finds an exact price at which CR becomes MCR. Liqudation does not happen in the event of them being equal, hence we add 1 to it to find closest liqudation price\n        price =\n            ((((_coll * DECIMAL_PRECISION) / _debt) * DECIMAL_PRECISION) /\n                _mcr) +\n            1;\n    }\n}\n"
    },
    "contracts/interfaces/IBaseFeeOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IBaseFeeOracle {\n    function decimals() external view returns (uint8);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint256 _roundId\n    )\n        external\n        view\n        returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        );\n}\n"
    },
    "contracts/LPRewards/TestContracts/TestPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../../PriceFeed.sol\";\n\ncontract TestPriceFeed is PriceFeed {\n    function setLastGoodPrice(uint _lastGoodPrice) external {\n        lastGoodPrice = _lastGoodPrice;\n    }\n\n    function setStatus(Status _status) external {\n        status = _status;\n    }\n}\n"
    },
    "contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IBaseFeeOracle.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./dependencies/BaseMath.sol\";\nimport \"./dependencies/LiquityMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nerror MainOracleDisabled();\n\n/*\n * PriceFeed for production deployment, to be connected to Main Oracle's live BaseFee:WstETH aggregator reference\n * contract, and a Backup oracle contract.\n *\n * The PriceFeed uses \"Main Oracle\" as primary oracle, and \"Back Up\" as fallback. It contains logic for\n * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\n * \"Main Oracle\" oracle.\n *\n * Based on Liquity Protocol.\n */\ncontract PriceFeed is Ownable, BaseMath {\n    string public constant NAME = \"PriceFeed\";\n\n    IBaseFeeOracle public mainOracle; // Main Oracle aggregator\n    IBaseFeeOracle public backupOracle; // Backup Oracle\n\n    uint public constant TARGET_DIGITS = 18;\n\n    // Maximum time period allowed since Main Oracle's latest round data blockNumber, beyond which Main Oracle is considered frozen.\n    uint public constant TIMEOUT = 69;\n\n    // HEDGEHOG UPDATES: decrease to 176\n    // Maximum deviation allowed between two consecutive Main oracle prices. Hedgehog oracles are getting updated in case there is a 5% diviation price\n    // Meaning that there might be max 17.5% price diviation between rounds\n    uint public constant MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND =\n        176;\n\n    /*\n     * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\n     * to return to using the Main oracle. 18-digit precision.\n     */\n    uint public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\n\n    // The last good price seen from an oracle by Hedgehog\n    uint256 public lastGoodPrice;\n\n    struct Response {\n        int256 answer;\n        uint64 blockNumber;\n        uint256 roundId;\n    }\n\n    enum Status {\n        mainOracleWorking,\n        usingBackupMainUntrusted,\n        bothOraclesUntrusted,\n        usingBackupMainFrozen,\n        usingMainBackupUntrusted\n    }\n\n    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt\n    Status public status;\n\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\n    event PriceFeedStatusChanged(Status newStatus);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _mainOracleAddress,\n        address _backupOracleAddress\n    ) external onlyOwner {\n        Address.isContract(_mainOracleAddress);\n        Address.isContract(_backupOracleAddress);\n\n        mainOracle = IBaseFeeOracle(_mainOracleAddress);\n        backupOracle = IBaseFeeOracle(_backupOracleAddress);\n\n        // Explicitly set initial system status\n        status = Status.mainOracleWorking;\n\n        // Get an initial price from Main Oracle to serve as first reference for lastGoodPrice\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\n            mainOracleResponse.roundId\n        );\n\n        if (\n            _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse) ||\n            _mainOracleIsFrozen(mainOracleResponse)\n        ) {\n            revert MainOracleDisabled();\n        }\n\n        _storeGoodPrice(mainOracleResponse, mainOracle.decimals());\n\n        renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /*\n     * fetchPrice():\n     * Returns the latest price obtained from the Oracle. Called by Hedgehog functions that require a current price.\n     *\n     * Also callable by anyone externally.\n     *\n     * Non-view function - it stores the last good price seen by Hedgehog.\n     *\n     * Uses a main oracle and a fallback oracle in case main one fails. If both fail,\n     * it uses the last good price seen by Hedgehog.\n     *\n     * Hedgehog updates: now both oracles are not allowed to have a price diviation of more then 12.5% between consecutive block\n     */\n    function fetchPrice() external returns (uint256) {\n        // Get current and previous price data from Main oracle, and current price data from Backup\n        uint8 decimals = mainOracle.decimals();\n\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\n            mainOracleResponse.roundId\n        );\n        Response memory backupOracleResponse = _getCurrentBackupResponse();\n        Response memory prevBackupOracleResponse = _getPrevBackupOracleResponse(\n            backupOracleResponse.roundId\n        );\n        uint8 backupDecimals = backupOracle.decimals();\n\n        // --- CASE 1: System fetched last price from Main Oracle  ---\n        if (status == Status.mainOracleWorking) {\n            // If Main Oracle is broken, try backup\n\n            if (\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\n            ) {\n                // If backup is broken then both oracles are untrusted, so return the last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n                /*\n                 * If Backup is only frozen but otherwise returning valid data, return the last good price.\n                 */\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    _changeStatus(Status.usingBackupMainUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Main Oracle is broken and Backup is working, switch to Backup and return current Backup price\n                _changeStatus(Status.usingBackupMainUntrusted);\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // If Main oracle is frozen, try Backup\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\n                // If Backup is broken too, remember Backup broke, and return last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.usingMainBackupUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Backup is frozen or working, remember Main Oracle froze, and switch to backup\n                _changeStatus(Status.usingBackupMainFrozen);\n\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // If Backup is working, use it\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // If MainOracle price has changed by > 12,5% between two consecutive rounds, compare it to Backup's price\n            if (\n                _priceChangeAboveMax(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    decimals\n                )\n            ) {\n                // If Backup is broken, both oracles are untrusted, and return last good price\n                if (\n                    _backupOracleIsBroken(backupOracleResponse) ||\n                    _priceChangeAboveMax(\n                        backupOracleResponse,\n                        prevBackupOracleResponse,\n                        backupDecimals\n                    )\n                ) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If backup is frozen, switch to backup and return last good price\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    _changeStatus(Status.usingBackupMainUntrusted);\n                    return lastGoodPrice;\n                }\n\n                _changeStatus(Status.usingBackupMainUntrusted);\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // If Main oracle is working and Backup is broken, remember Backup is broken\n            if (_backupOracleIsBroken(backupOracleResponse)) {\n                _changeStatus(Status.usingMainBackupUntrusted);\n            }\n\n            // If MainOracle is working, return MainOracle current price (no status change)\n            return _storeGoodPrice(mainOracleResponse, decimals);\n        }\n\n        // --- CASE 2: The system fetched last price from Backup ---\n        if (status == Status.usingBackupMainUntrusted) {\n            // If both Backup and Main oracle are live, unbroken, and reporting similar prices, switch back to Main\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            if (_backupOracleIsBroken(backupOracleResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            /*\n             * If Backup is only frozen but otherwise returning valid data, just return the last good price.\n             * Backup may need to be tipped to return current data.\n             */\n            if (_backupIsFrozen(backupOracleResponse)) {\n                return lastGoodPrice;\n            }\n\n            if (\n                _priceChangeAboveMax(\n                    backupOracleResponse,\n                    prevBackupOracleResponse,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // Otherwise, use Backup price\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\n        }\n\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\n        if (status == Status.bothOraclesUntrusted) {\n            /*\n             * If both oracles are now live, unbroken and similar price, we assume that they are reporting\n             * accurately, and so we switch back to Main Oracle.\n             */\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\n            return lastGoodPrice;\n        }\n\n        // --- CASE 4: Using Backup, and Main Oracle is frozen ---\n        if (status == Status.usingBackupMainFrozen) {\n            if (\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\n            ) {\n                // If both Oracles are broken, return last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Main Oracle is broken, remember it and switch to using Backup\n                _changeStatus(Status.usingBackupMainUntrusted);\n\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // If Backup is working, return Backup current price\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\n                // if Main Oracle is frozen and Backup is broken, remember Backup broke, and return last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.usingMainBackupUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If both are frozen, just use lastGoodPrice\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // if Main Oracle is frozen and Backup is working, keep using Backup (no status change)\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // if Main Oracle is live and Backup is broken, remember Backup broke, and return Main Oracle price\n            if (_backupOracleIsBroken(backupOracleResponse)) {\n                _changeStatus(Status.usingMainBackupUntrusted);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // If Main Oracle is live and Backup is frozen, just use last good price (no status change) since we have no basis for comparison\n            if (_backupIsFrozen(backupOracleResponse)) {\n                return lastGoodPrice;\n            }\n\n            // If Main Oracle is live and Backup is working, compare prices. Switch to Main Oracle\n            // if prices are within 5%, and return Main Oracle price.\n            if (\n                _bothOraclesSimilarPrice(\n                    mainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // Otherwise if Main Oracle is live but price not within 5% of Backup, distrust Main Oracle, and return Backup price\n            _changeStatus(Status.usingBackupMainUntrusted);\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\n        }\n\n        // --- CASE 5: Using Main Oracle, Back up is untrusted ---\n        if (status == Status.usingMainBackupUntrusted) {\n            // If Main Oracle breaks, now both oracles are untrusted\n            if (\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\n            ) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // If Main Oracle is frozen, return last good price (no status change)\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\n                return lastGoodPrice;\n            }\n\n            // If Main Oracle and Backup are both live, unbroken and similar price, switch back to Main Oracle working and return MainOracle price\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // If Main Oracle is live but deviated >17.5% from it's previous price and Backup is still untrusted, switch\n            // to bothOraclesUntrusted and return last good price\n            if (\n                _priceChangeAboveMax(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    decimals\n                )\n            ) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // Otherwise if Main Oracle is live and deviated <17.5% from it's previous price and Backup is still untrusted,\n            // return Main Oracle price (no status change)\n            return _storeGoodPrice(mainOracleResponse, decimals);\n        }\n    }\n\n    // --- Helper functions ---\n\n    /* Main Oracle is considered broken if its current or previous round data is in any way bad. We check the previous round\n     * for two reasons:\n     *\n     * 1) It is necessary data for the price deviation check in case 1,\n     * and\n     * 2) Main Oracle is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\n     * peace of mind when using or returning to Main Oracle.\n     */\n    function _mainOracleIsBroken(\n        Response memory _currentResponse,\n        Response memory _prevResponse\n    ) internal view returns (bool) {\n        return\n            _badMainOracleResponse(_currentResponse) ||\n            _badMainOracleResponse(_prevResponse);\n    }\n\n    function _badMainOracleResponse(\n        Response memory _response\n    ) internal view returns (bool) {\n        // Check for an invalid roundId that is 0\n        if (_response.roundId == 0) {\n            return true;\n        }\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (\n            _response.blockNumber == 0 || _response.blockNumber > block.number\n        ) {\n            return true;\n        }\n        // Check for non-positive price\n        if (_response.answer <= 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _mainOracleIsFrozen(\n        Response memory _response\n    ) internal view returns (bool) {\n        return (block.number - _response.blockNumber) > TIMEOUT;\n    }\n\n    function _priceChangeAboveMax(\n        Response memory _currentResponse,\n        Response memory _prevResponse,\n        uint8 _decimals\n    ) internal pure returns (bool) {\n        uint currentScaledPrice = _scalePriceByDigits(\n            uint256(_currentResponse.answer),\n            _decimals\n        );\n        uint prevScaledPrice = _scalePriceByDigits(\n            uint256(_prevResponse.answer),\n            _decimals\n        );\n\n        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);\n        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);\n\n        /*\n         * Use the larger price as the denominator:\n         * - If price decreased, the percentage deviation is in relation to the the previous price.\n         * - If price increased, the percentage deviation is in relation to the current price.\n         */\n        uint difference = maxPrice - minPrice;\n        uint threshold = (maxPrice *\n            MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND) / 1000; // 17.5% of max price\n\n        // Return true if price has more than doubled, or more than halved.\n        return difference > threshold;\n    }\n\n    function _backupOracleIsBroken(\n        Response memory _response\n    ) internal view returns (bool) {\n        // Check for an invalid roundId that is 0\n        if (_response.roundId == 0) {\n            return true;\n        }\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (\n            _response.blockNumber == 0 || _response.blockNumber > block.number\n        ) {\n            return true;\n        }\n        // Check for zero price\n        if (_response.answer <= 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _backupIsFrozen(\n        Response memory _backupResponse\n    ) internal view returns (bool) {\n        return block.number - _backupResponse.blockNumber > TIMEOUT;\n    }\n\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n        Response memory _mainOracleResponse,\n        Response memory _prevMainOracleResponse,\n        Response memory _backupResponse,\n        uint8 _mainOracleDecimals,\n        uint8 _backupOracleDecimals\n    ) internal view returns (bool) {\n        // Return false if either oracle is broken or frozen\n        if (\n            _backupOracleIsBroken(_backupResponse) ||\n            _backupIsFrozen(_backupResponse) ||\n            _mainOracleIsBroken(_mainOracleResponse, _prevMainOracleResponse) ||\n            _mainOracleIsFrozen(_mainOracleResponse)\n        ) {\n            return false;\n        }\n\n        return\n            _bothOraclesSimilarPrice(\n                _mainOracleResponse,\n                _backupResponse,\n                _mainOracleDecimals,\n                _backupOracleDecimals\n            );\n    }\n\n    function _bothOraclesSimilarPrice(\n        Response memory _mainOracleResponse,\n        Response memory _backupResponse,\n        uint8 _mainOracleDecimals,\n        uint8 _backupOracleDecimals\n    ) internal pure returns (bool) {\n        uint scaledMainOraclePrice = _scalePriceByDigits(\n            uint256(_mainOracleResponse.answer),\n            _mainOracleDecimals\n        );\n        uint scaledBackupPrice = _scalePriceByDigits(\n            uint256(_backupResponse.answer),\n            _backupOracleDecimals\n        );\n\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\n        uint minPrice = LiquityMath._min(\n            scaledBackupPrice,\n            scaledMainOraclePrice\n        );\n        uint maxPrice = LiquityMath._max(\n            scaledBackupPrice,\n            scaledMainOraclePrice\n        );\n        uint percentPriceDifference = ((maxPrice - minPrice) *\n            DECIMAL_PRECISION) / minPrice;\n\n        /*\n         * Return true if the relative price difference is <= 5%: if so, we assume both oracles are probably reporting\n         * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\n         */\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\n    }\n\n    function _scalePriceByDigits(\n        uint _price,\n        uint _answerDigits\n    ) internal pure returns (uint) {\n        /*\n         * Convert the price returned by an oracle to an 18-digit decimal for use by Hedgehog.\n         * At date of Hedgehog launch, MaainOracle uses an 8-digit price, but we also handle the possibility of\n         * future changes.\n         */\n        uint price;\n        if (_answerDigits >= TARGET_DIGITS) {\n            // Scale the returned price value down to Hedgehog's target precision\n            price = _price / (10 ** (_answerDigits - TARGET_DIGITS));\n        } else if (_answerDigits < TARGET_DIGITS) {\n            // Scale the returned price value up to Hedgehog's target precision\n            price = _price * (10 ** (TARGET_DIGITS - _answerDigits));\n        }\n        return price;\n    }\n\n    function _changeStatus(Status _status) internal {\n        status = _status;\n        emit PriceFeedStatusChanged(_status);\n    }\n\n    function _storePrice(uint _currentPrice) internal {\n        lastGoodPrice = _currentPrice;\n        emit LastGoodPriceUpdated(_currentPrice);\n    }\n\n    function _storeGoodPrice(\n        Response memory _response,\n        uint8 _decimals\n    ) internal returns (uint) {\n        uint scaledPrice = _scalePriceByDigits(\n            uint256(_response.answer),\n            _decimals\n        );\n\n        _storePrice(scaledPrice);\n\n        return scaledPrice;\n    }\n\n    function _getCurrentMainOracleResponse()\n        internal\n        view\n        returns (Response memory response)\n    {\n        // Try to get latest price data:\n        try mainOracle.latestRoundData() returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            response.roundId = roundId;\n            response.answer = answer;\n            response.blockNumber = uint64(currentChainBN);\n\n            return response;\n        } catch {\n            // If call to Main Oracle aggregator reverts\n            return response;\n        }\n    }\n\n    function _getCurrentBackupResponse()\n        internal\n        view\n        returns (Response memory response)\n    {\n        // Try to get latest price data:\n        try backupOracle.latestRoundData() returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            response.roundId = roundId;\n            response.answer = answer;\n            response.blockNumber = uint64(currentChainBN);\n\n            return response;\n        } catch {\n            // If call to Backup aggregator reverts with empty response\n            return response;\n        }\n    }\n\n    function _getPrevOracleResponse(\n        uint256 _currentRoundId\n    ) internal view returns (Response memory prevMainOracleResponse) {\n        /*\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\n         */\n\n        // Try to get the price data from the previous round:\n        try mainOracle.getRoundData(_currentRoundId - 1) returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            // If call to Hedgehog succeeds, return the response and success = true\n            prevMainOracleResponse.roundId = roundId;\n            prevMainOracleResponse.answer = answer;\n            prevMainOracleResponse.blockNumber = uint64(currentChainBN);\n            return prevMainOracleResponse;\n        } catch {\n            // If call to Main Oracle aggregator reverts\n            return prevMainOracleResponse;\n        }\n    }\n\n    function _getPrevBackupOracleResponse(\n        uint256 _currentRoundId\n    ) internal view returns (Response memory prevBackupOracleResponse) {\n        /*\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\n         */\n\n        // Try to get the price data from the previous round:\n        try backupOracle.getRoundData(_currentRoundId - 1) returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            // If call to Hedgehog succeeds, return the response and success = true\n            prevBackupOracleResponse.roundId = roundId;\n            prevBackupOracleResponse.answer = answer;\n            prevBackupOracleResponse.blockNumber = uint64(currentChainBN);\n            return prevBackupOracleResponse;\n        } catch {\n            // If call to Main Oracle aggregator reverts\n            return prevBackupOracleResponse;\n        }\n    }\n}\n"
    },
    "contracts/PriceFeedArb.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IBaseFeeOracle.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./dependencies/BaseMath.sol\";\nimport \"./dependencies/LiquityMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nerror MainOracleDisabled();\n\ninterface ArbSys {\n    function arbBlockNumber() external view returns (uint256);\n}\n\n/*\n * PriceFeed for production deployment, to be connected to Main Oracle's live BaseFee:WstETH aggregator reference\n * contract, and a Backup oracle contract.\n *\n * The PriceFeed uses \"Main Oracle\" as primary oracle, and \"Back Up\" as fallback. It contains logic for\n * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\n * \"Main Oracle\" oracle.\n *\n * Based on Liquity Protocol.\n */\ncontract PriceFeedArb is Ownable, BaseMath {\n    string public constant NAME = \"PriceFeed\";\n\n    IBaseFeeOracle public mainOracle; // Main Oracle aggregator\n    IBaseFeeOracle public backupOracle; // Backup Oracle\n\n    uint public constant TARGET_DIGITS = 18;\n\n    // Maximum time period allowed since Main Oracle's latest round data blockNumber, beyond which Main Oracle is considered frozen.\n    uint public constant TIMEOUT = 69;\n\n    // HEDGEHOG UPDATES: decrease to 176\n    // Maximum deviation allowed between two consecutive Main oracle prices. Hedgehog oracles are getting updated in case there is a 5% diviation price\n    // Meaning that there might be max 17.5% price diviation between rounds\n    uint public constant MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND =\n        176;\n\n    /*\n     * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\n     * to return to using the Main oracle. 18-digit precision.\n     */\n    uint public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\n\n    // The last good price seen from an oracle by Hedgehog\n    uint256 public lastGoodPrice;\n\n    ArbSys constant arbsys = ArbSys(address(100));\n\n    struct Response {\n        int256 answer;\n        uint64 blockNumber;\n        uint256 roundId;\n    }\n\n    enum Status {\n        mainOracleWorking,\n        usingBackupMainUntrusted,\n        bothOraclesUntrusted,\n        usingBackupMainFrozen,\n        usingMainBackupUntrusted\n    }\n\n    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt\n    Status public status;\n\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\n    event PriceFeedStatusChanged(Status newStatus);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _mainOracleAddress,\n        address _backupOracleAddress\n    ) external onlyOwner {\n        Address.isContract(_mainOracleAddress);\n        Address.isContract(_backupOracleAddress);\n\n        mainOracle = IBaseFeeOracle(_mainOracleAddress);\n        backupOracle = IBaseFeeOracle(_backupOracleAddress);\n\n        // Explicitly set initial system status\n        status = Status.mainOracleWorking;\n\n        // Get an initial price from Main Oracle to serve as first reference for lastGoodPrice\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\n            mainOracleResponse.roundId\n        );\n\n        if (\n            _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse) ||\n            _mainOracleIsFrozen(mainOracleResponse)\n        ) {\n            revert MainOracleDisabled();\n        }\n\n        _storeGoodPrice(mainOracleResponse, mainOracle.decimals());\n\n        renounceOwnership();\n    }\n\n    // --- Functions ---\n\n    /*\n     * fetchPrice():\n     * Returns the latest price obtained from the Oracle. Called by Hedgehog functions that require a current price.\n     *\n     * Also callable by anyone externally.\n     *\n     * Non-view function - it stores the last good price seen by Hedgehog.\n     *\n     * Uses a main oracle and a fallback oracle in case main one fails. If both fail,\n     * it uses the last good price seen by Hedgehog.\n     *\n     * Hedgehog updates: now both oracles are not allowed to have a price diviation of more then 12.5% between consecutive block\n     */\n    function fetchPrice() external returns (uint256) {\n        // Get current and previous price data from Main oracle, and current price data from Backup\n        uint8 decimals = mainOracle.decimals();\n\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\n            mainOracleResponse.roundId\n        );\n        Response memory backupOracleResponse = _getCurrentBackupResponse();\n        Response memory prevBackupOracleResponse = _getPrevBackupOracleResponse(\n            backupOracleResponse.roundId\n        );\n        uint8 backupDecimals = backupOracle.decimals();\n\n        // --- CASE 1: System fetched last price from Main Oracle  ---\n        if (status == Status.mainOracleWorking) {\n            // If Main Oracle is broken, try backup\n\n            if (\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\n            ) {\n                // If backup is broken then both oracles are untrusted, so return the last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n                /*\n                 * If Backup is only frozen but otherwise returning valid data, return the last good price.\n                 */\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    _changeStatus(Status.usingBackupMainUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Main Oracle is broken and Backup is working, switch to Backup and return current Backup price\n                _changeStatus(Status.usingBackupMainUntrusted);\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // If Main oracle is frozen, try Backup\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\n                // If Backup is broken too, remember Backup broke, and return last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.usingMainBackupUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Backup is frozen or working, remember Main Oracle froze, and switch to backup\n                _changeStatus(Status.usingBackupMainFrozen);\n\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // If Backup is working, use it\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // If MainOracle price has changed by > 12,5% between two consecutive rounds, compare it to Backup's price\n            if (\n                _priceChangeAboveMax(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    decimals\n                )\n            ) {\n                // If Backup is broken, both oracles are untrusted, and return last good price\n                if (\n                    _backupOracleIsBroken(backupOracleResponse) ||\n                    _priceChangeAboveMax(\n                        backupOracleResponse,\n                        prevBackupOracleResponse,\n                        backupDecimals\n                    )\n                ) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If backup is frozen, switch to backup and return last good price\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    _changeStatus(Status.usingBackupMainUntrusted);\n                    return lastGoodPrice;\n                }\n\n                _changeStatus(Status.usingBackupMainUntrusted);\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // If Main oracle is working and Backup is broken, remember Backup is broken\n            if (_backupOracleIsBroken(backupOracleResponse)) {\n                _changeStatus(Status.usingMainBackupUntrusted);\n            }\n\n            // If MainOracle is working, return MainOracle current price (no status change)\n            return _storeGoodPrice(mainOracleResponse, decimals);\n        }\n\n        // --- CASE 2: The system fetched last price from Backup ---\n        if (status == Status.usingBackupMainUntrusted) {\n            // If both Backup and Main oracle are live, unbroken, and reporting similar prices, switch back to Main\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            if (_backupOracleIsBroken(backupOracleResponse)) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            /*\n             * If Backup is only frozen but otherwise returning valid data, just return the last good price.\n             * Backup may need to be tipped to return current data.\n             */\n            if (_backupIsFrozen(backupOracleResponse)) {\n                return lastGoodPrice;\n            }\n\n            if (\n                _priceChangeAboveMax(\n                    backupOracleResponse,\n                    prevBackupOracleResponse,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // Otherwise, use Backup price\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\n        }\n\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\n        if (status == Status.bothOraclesUntrusted) {\n            /*\n             * If both oracles are now live, unbroken and similar price, we assume that they are reporting\n             * accurately, and so we switch back to Main Oracle.\n             */\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\n            return lastGoodPrice;\n        }\n\n        // --- CASE 4: Using Backup, and Main Oracle is frozen ---\n        if (status == Status.usingBackupMainFrozen) {\n            if (\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\n            ) {\n                // If both Oracles are broken, return last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.bothOraclesUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If Main Oracle is broken, remember it and switch to using Backup\n                _changeStatus(Status.usingBackupMainUntrusted);\n\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // If Backup is working, return Backup current price\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\n                // if Main Oracle is frozen and Backup is broken, remember Backup broke, and return last good price\n                if (_backupOracleIsBroken(backupOracleResponse)) {\n                    _changeStatus(Status.usingMainBackupUntrusted);\n                    return lastGoodPrice;\n                }\n\n                // If both are frozen, just use lastGoodPrice\n                if (_backupIsFrozen(backupOracleResponse)) {\n                    return lastGoodPrice;\n                }\n\n                // if Main Oracle is frozen and Backup is working, keep using Backup (no status change)\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\n            }\n\n            // if Main Oracle is live and Backup is broken, remember Backup broke, and return Main Oracle price\n            if (_backupOracleIsBroken(backupOracleResponse)) {\n                _changeStatus(Status.usingMainBackupUntrusted);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // If Main Oracle is live and Backup is frozen, just use last good price (no status change) since we have no basis for comparison\n            if (_backupIsFrozen(backupOracleResponse)) {\n                return lastGoodPrice;\n            }\n\n            // If Main Oracle is live and Backup is working, compare prices. Switch to Main Oracle\n            // if prices are within 5%, and return Main Oracle price.\n            if (\n                _bothOraclesSimilarPrice(\n                    mainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // Otherwise if Main Oracle is live but price not within 5% of Backup, distrust Main Oracle, and return Backup price\n            _changeStatus(Status.usingBackupMainUntrusted);\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\n        }\n\n        // --- CASE 5: Using Main Oracle, Back up is untrusted ---\n        if (status == Status.usingMainBackupUntrusted) {\n            // If Main Oracle breaks, now both oracles are untrusted\n            if (\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\n            ) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // If Main Oracle is frozen, return last good price (no status change)\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\n                return lastGoodPrice;\n            }\n\n            // If Main Oracle and Backup are both live, unbroken and similar price, switch back to Main Oracle working and return MainOracle price\n            if (\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    backupOracleResponse,\n                    decimals,\n                    backupDecimals\n                )\n            ) {\n                _changeStatus(Status.mainOracleWorking);\n                return _storeGoodPrice(mainOracleResponse, decimals);\n            }\n\n            // If Main Oracle is live but deviated >17.5% from it's previous price and Backup is still untrusted, switch\n            // to bothOraclesUntrusted and return last good price\n            if (\n                _priceChangeAboveMax(\n                    mainOracleResponse,\n                    prevMainOracleResponse,\n                    decimals\n                )\n            ) {\n                _changeStatus(Status.bothOraclesUntrusted);\n                return lastGoodPrice;\n            }\n\n            // Otherwise if Main Oracle is live and deviated <17.5% from it's previous price and Backup is still untrusted,\n            // return Main Oracle price (no status change)\n            return _storeGoodPrice(mainOracleResponse, decimals);\n        }\n    }\n\n    // --- Helper functions ---\n\n    /* Main Oracle is considered broken if its current or previous round data is in any way bad. We check the previous round\n     * for two reasons:\n     *\n     * 1) It is necessary data for the price deviation check in case 1,\n     * and\n     * 2) Main Oracle is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\n     * peace of mind when using or returning to Main Oracle.\n     */\n    function _mainOracleIsBroken(\n        Response memory _currentResponse,\n        Response memory _prevResponse\n    ) internal view returns (bool) {\n        return\n            _badMainOracleResponse(_currentResponse) ||\n            _badMainOracleResponse(_prevResponse);\n    }\n\n    function _badMainOracleResponse(\n        Response memory _response\n    ) internal view returns (bool) {\n        // Check for an invalid roundId that is 0\n        if (_response.roundId == 0) {\n            return true;\n        }\n        // Hedgehog Updates: In case of a deployment to Arbitrum we gather current block.number via ArbSys method\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (\n            _response.blockNumber == 0 ||\n            _response.blockNumber > arbsys.arbBlockNumber()\n        ) {\n            return true;\n        }\n        // Check for non-positive price\n        if (_response.answer <= 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _mainOracleIsFrozen(\n        Response memory _response\n    ) internal view returns (bool) {\n        // Hedgehog Updates: In case of a deployment to Arbitrum we gather current block.number via ArbSys method\n        return (arbsys.arbBlockNumber() - _response.blockNumber) > TIMEOUT;\n    }\n\n    function _priceChangeAboveMax(\n        Response memory _currentResponse,\n        Response memory _prevResponse,\n        uint8 _decimals\n    ) internal pure returns (bool) {\n        uint currentScaledPrice = _scalePriceByDigits(\n            uint256(_currentResponse.answer),\n            _decimals\n        );\n        uint prevScaledPrice = _scalePriceByDigits(\n            uint256(_prevResponse.answer),\n            _decimals\n        );\n\n        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);\n        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);\n\n        /*\n         * Use the larger price as the denominator:\n         * - If price decreased, the percentage deviation is in relation to the the previous price.\n         * - If price increased, the percentage deviation is in relation to the current price.\n         */\n        uint difference = maxPrice - minPrice;\n        uint threshold = (maxPrice *\n            MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND) / 1000; // 17.5% of max price\n\n        // Return true if price has more than doubled, or more than halved.\n        return difference > threshold;\n    }\n\n    function _backupOracleIsBroken(\n        Response memory _response\n    ) internal view returns (bool) {\n        // Hedgehog Updates: In case of a deployment to Arbitrum we gather current block.number via ArbSys method\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (\n            _response.blockNumber == 0 ||\n            _response.blockNumber > arbsys.arbBlockNumber()\n        ) {\n            return true;\n        }\n        // Check for zero price\n        if (_response.answer == 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _backupIsFrozen(\n        Response memory _backupResponse\n    ) internal view returns (bool) {\n        // Hedgehog Updates: In case of a deployment to Arbitrum we gather current block.number via ArbSys method\n        return arbsys.arbBlockNumber() - _backupResponse.blockNumber > TIMEOUT;\n    }\n\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice(\n        Response memory _mainOracleResponse,\n        Response memory _prevMainOracleResponse,\n        Response memory _backupResponse,\n        uint8 _mainOracleDecimals,\n        uint8 _backupOracleDecimals\n    ) internal view returns (bool) {\n        // Return false if either oracle is broken or frozen\n        if (\n            _backupOracleIsBroken(_backupResponse) ||\n            _backupIsFrozen(_backupResponse) ||\n            _mainOracleIsBroken(_mainOracleResponse, _prevMainOracleResponse) ||\n            _mainOracleIsFrozen(_mainOracleResponse)\n        ) {\n            return false;\n        }\n\n        return\n            _bothOraclesSimilarPrice(\n                _mainOracleResponse,\n                _backupResponse,\n                _mainOracleDecimals,\n                _backupOracleDecimals\n            );\n    }\n\n    function _bothOraclesSimilarPrice(\n        Response memory _mainOracleResponse,\n        Response memory _backupResponse,\n        uint8 _mainOracleDecimals,\n        uint8 _backupOracleDecimals\n    ) internal pure returns (bool) {\n        uint scaledMainOraclePrice = _scalePriceByDigits(\n            uint256(_mainOracleResponse.answer),\n            _mainOracleDecimals\n        );\n        uint scaledBackupPrice = _scalePriceByDigits(\n            uint256(_backupResponse.answer),\n            _backupOracleDecimals\n        );\n\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\n        uint minPrice = LiquityMath._min(\n            scaledBackupPrice,\n            scaledMainOraclePrice\n        );\n        uint maxPrice = LiquityMath._max(\n            scaledBackupPrice,\n            scaledMainOraclePrice\n        );\n        uint percentPriceDifference = ((maxPrice - minPrice) *\n            DECIMAL_PRECISION) / minPrice;\n\n        /*\n         * Return true if the relative price difference is <= 5%: if so, we assume both oracles are probably reporting\n         * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\n         */\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\n    }\n\n    function _scalePriceByDigits(\n        uint _price,\n        uint _answerDigits\n    ) internal pure returns (uint) {\n        /*\n         * Convert the price returned by an oracle to an 18-digit decimal for use by Hedgehog.\n         * At date of Hedgehog launch, MaainOracle uses an 8-digit price, but we also handle the possibility of\n         * future changes.\n         */\n        uint price;\n        if (_answerDigits >= TARGET_DIGITS) {\n            // Scale the returned price value down to Hedgehog's target precision\n            price = _price / (10 ** (_answerDigits - TARGET_DIGITS));\n        } else if (_answerDigits < TARGET_DIGITS) {\n            // Scale the returned price value up to Hedgehog's target precision\n            price = _price * (10 ** (TARGET_DIGITS - _answerDigits));\n        }\n        return price;\n    }\n\n    function _changeStatus(Status _status) internal {\n        status = _status;\n        emit PriceFeedStatusChanged(_status);\n    }\n\n    function _storePrice(uint _currentPrice) internal {\n        lastGoodPrice = _currentPrice;\n        emit LastGoodPriceUpdated(_currentPrice);\n    }\n\n    function _storeGoodPrice(\n        Response memory _response,\n        uint8 _decimals\n    ) internal returns (uint) {\n        uint scaledPrice = _scalePriceByDigits(\n            uint256(_response.answer),\n            _decimals\n        );\n\n        _storePrice(scaledPrice);\n\n        return scaledPrice;\n    }\n\n    function _getCurrentMainOracleResponse()\n        internal\n        view\n        returns (Response memory response)\n    {\n        // Try to get latest price data:\n        try mainOracle.latestRoundData() returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            response.roundId = roundId;\n            response.answer = answer;\n            response.blockNumber = uint64(currentChainBN);\n\n            return response;\n        } catch {\n            // If call to Main Oracle aggregator reverts\n            return response;\n        }\n    }\n\n    function _getCurrentBackupResponse()\n        internal\n        view\n        returns (Response memory response)\n    {\n        // Try to get latest price data:\n        try backupOracle.latestRoundData() returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            response.roundId = roundId;\n            response.answer = answer;\n            response.blockNumber = uint64(currentChainBN);\n\n            return response;\n        } catch {\n            // If call to Backup aggregator reverts with empty response\n            return response;\n        }\n    }\n\n    function _getPrevOracleResponse(\n        uint256 _currentRoundId\n    ) internal view returns (Response memory prevMainOracleResponse) {\n        /*\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\n         */\n\n        // Try to get the price data from the previous round:\n        try mainOracle.getRoundData(_currentRoundId - 1) returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            // If call to Hedgehog succeeds, return the response and success = true\n            prevMainOracleResponse.roundId = roundId;\n            prevMainOracleResponse.answer = answer;\n            prevMainOracleResponse.blockNumber = uint64(currentChainBN);\n            return prevMainOracleResponse;\n        } catch {\n            // If call to Main Oracle aggregator reverts\n            return prevMainOracleResponse;\n        }\n    }\n\n    function _getPrevBackupOracleResponse(\n        uint256 _currentRoundId\n    ) internal view returns (Response memory prevBackupOracleResponse) {\n        /*\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\n         */\n\n        // Try to get the price data from the previous round:\n        try backupOracle.getRoundData(_currentRoundId - 1) returns (\n            uint256 roundId,\n            int256 answer,\n            uint256 blockNumber,\n            uint256 currentChainBN,\n            uint256 __roundId\n        ) {\n            // If call to Hedgehog succeeds, return the response and success = true\n            prevBackupOracleResponse.roundId = roundId;\n            prevBackupOracleResponse.answer = answer;\n            prevBackupOracleResponse.blockNumber = uint64(currentChainBN);\n            return prevBackupOracleResponse;\n        } catch {\n            // If call to Main Oracle aggregator reverts\n            return prevBackupOracleResponse;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}