{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/ActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\nimport \"./interfaces/IPool.sol\";\n\n/**\n * @notice Fork of Liquity's Active Pool. Logic remains unchanged.\n * Changes to the contract:\n * - Raised pragma version\n * - Removed an import of ActivePool Interface\n * - Updated variable names and docs to refer to BaseFeeLMA token and stEth as a collateral\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\n *\n * The Active Pool holds the stStETH collateral and BaseFeeLMA debt (but not BaseFeeLMA tokens) for all active troves.\n *\n * When a trove is liquidated, it's stStETH and BaseFeeLMA debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IPool {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"ActivePool\";\n\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    uint256 internal StETH; // deposited stEth tracker\n    uint256 internal BaseFeeLMADebt;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolBaseFeeLMADebtUpdated(uint _BaseFeeLMADebt);\n    event ActivePoolStETHBalanceUpdated(uint _stStETH);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n     * Returns the stStETH state variable.\n     *\n     *Not necessarily equal to the the contract's raw StETH balance - stETH can be forcibly sent to contracts.\n     */\n    function getStETH() external view override returns (uint) {\n        return StETH;\n    }\n\n    function getBaseFeeLMADebt() external view override returns (uint) {\n        return BaseFeeLMADebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendStETH(address _account, uint _amount) external {\n        _requireCallerIsBOorTroveMorSP();\n        StETH = StETH.sub(_amount);\n        emit ActivePoolStETHBalanceUpdated(StETH);\n        emit StETHSent(_account, _amount);\n\n        (bool success, ) = _account.call{value: _amount}(\"\");\n        require(success, \"ActivePool: sending StETH failed\");\n    }\n\n    function increaseBaseFeeLMADebt(uint _amount) external override {\n        _requireCallerIsBOorTroveM();\n        BaseFeeLMADebt = BaseFeeLMADebt.add(_amount);\n        emit ActivePoolBaseFeeLMADebtUpdated(BaseFeeLMADebt);\n    }\n\n    function decreaseBaseFeeLMADebt(uint _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        BaseFeeLMADebt = BaseFeeLMADebt.sub(_amount);\n        emit ActivePoolBaseFeeLMADebtUpdated(BaseFeeLMADebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        StETH = StETH.add(msg.value);\n        emit ActivePoolStETHBalanceUpdated(StETH);\n    }\n}\n"
    },
    "contracts/BaseFeeLMAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./dependencies/IERC2612.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\n\n/*\n *\n * Based upon OpenZeppelin's ERC20 contract:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n *\n * and their EIP2612 (ERC20Permit / ERC712) functionality:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\n *\n *\n * --- Functionality added specific to the BaseFeeLMAToken ---\n *\n * 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external\n * transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending BaseFeeLMA directly to a Liquity\n * core contract, when they should rather call the right function.\n *\n * 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move BaseFeeLMA tokens between Liquity <-> user.\n */\n\ncontract BaseFeeLMAToken is CheckContract, IERC20, IERC2612 {\n    using SafeMath for uint256;\n\n    uint256 private _totalSupply;\n    string internal constant _NAME = \"BaseFeeLMA Stablecoin\";\n    string internal constant _SYMBOL = \"BaseFeeLMA\";\n    string internal constant _VERSION = \"1\";\n    uint8 internal constant _DECIMALS = 18;\n\n    // --- Data for EIP2612 ---\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant _PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _TYPE_HASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n\n    mapping(address => uint256) private _nonces;\n\n    // User data for BaseFeeLMA token\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    // --- Addresses ---\n    address public immutable troveManagerAddress;\n    address public immutable stabilityPoolAddress;\n    address public immutable borrowerOperationsAddress;\n\n    // --- Events ---\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n\n    event BaseFeeLMATokenBalanceUpdated(address _user, uint _amount);\n\n    constructor(\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _borrowerOperationsAddress\n    ) {\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        troveManagerAddress = _troveManagerAddress;\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n\n        stabilityPoolAddress = _stabilityPoolAddress;\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        bytes32 hashedName = keccak256(bytes(_NAME));\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\n\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _chainID();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\n            _TYPE_HASH,\n            hashedName,\n            hashedVersion\n        );\n    }\n\n    // --- Functions for intra-Liquity calls ---\n\n    function mint(address _account, uint256 _amount) external {\n        _requireCallerIsBorrowerOperations();\n        _mint(_account, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external {\n        _requireCallerIsBOorTroveMorSP();\n        _burn(_account, _amount);\n    }\n\n    function sendToPool(\n        address _sender,\n        address _poolAddress,\n        uint256 _amount\n    ) external {\n        _requireCallerIsStabilityPool();\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    function returnFromPool(\n        address _poolAddress,\n        address _receiver,\n        uint256 _amount\n    ) external {\n        _requireCallerIsTroveMorSP();\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    // --- External functions ---\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(\n        address account\n    ) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _requireValidRecipient(recipient);\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    // --- EIP 2612 Functionality ---\n\n    function domainSeparator() public view override returns (bytes32) {\n        if (_chainID() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return\n                _buildDomainSeparator(\n                    _TYPE_HASH,\n                    _HASHED_NAME,\n                    _HASHED_VERSION\n                );\n        }\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint amount,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"BaseFeeLMA: expired deadline\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        amount,\n                        _nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == owner, \"BaseFeeLMA: invalid signature\");\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        // FOR EIP 2612\n        return _nonces[owner];\n    }\n\n    // --- Internal operations ---\n\n    function _chainID() private view returns (uint256 chainID) {\n        assembly {\n            chainID := chainid()\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(typeHash, name, version, _chainID(), address(this))\n            );\n    }\n\n    // --- Internal operations ---\n    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        assert(sender != address(0));\n        assert(recipient != address(0));\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        assert(account != address(0));\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        assert(owner != address(0));\n        assert(spender != address(0));\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidRecipient(address _recipient) internal view {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"BaseFeeLMA: Cannot transfer tokens directly to the BaseFeeLMA token contract or the zero address\"\n        );\n        require(\n            _recipient != stabilityPoolAddress &&\n                _recipient != troveManagerAddress &&\n                _recipient != borrowerOperationsAddress,\n            \"BaseFeeLMA: Cannot transfer tokens directly to the StabilityPool, TroveManager or BorrowerOps\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"BaseFeeLMAToken: Caller is not BorrowerOperations\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"BaseFeeLMA: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(\n            msg.sender == stabilityPoolAddress,\n            \"BaseFeeLMA: Caller is not the StabilityPool\"\n        );\n    }\n\n    function _requireCallerIsTroveMorSP() internal view {\n        require(\n            msg.sender == troveManagerAddress ||\n                msg.sender == stabilityPoolAddress,\n            \"BaseFeeLMA: Caller is neither TroveManager nor StabilityPool\"\n        );\n    }\n\n    // --- Optional functions ---\n\n    function name() external pure returns (string memory) {\n        return _NAME;\n    }\n\n    function symbol() external pure returns (string memory) {\n        return _SYMBOL;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return _DECIMALS;\n    }\n\n    function version() external pure override returns (string memory) {\n        return _VERSION;\n    }\n\n    function permitTypeHash() external pure override returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/ITroveManager.sol\"; // TODO: Check if used and if should be included into changes list\nimport \"./interfaces/IBaseFeeLMAToken.sol\";\nimport \"./interfaces/ICollSurplusPool.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/IHOGStaking.sol\";\nimport \"./dependencies/HedgehogBase.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\n\n/**\n * @notice Fork of Liquity's BorrowerOperations. Logic remains unchanged.\n * Changes to the contract:\n * - Raised pragma version\n * - Removed an import of IBorrowerOperations Interface\n * - Updated variable names and docs to refer to BaseFeeLMA token and stEth as a collateral\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\n */\n\ncontract BorrowerOperations is HedgehogBase, Ownable, CheckContract {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address stabilityPoolAddress;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IHOGStaking public hogStaking;\n    address public hogStakingAddress;\n\n    IBaseFeeLMAToken baseFeeLMAToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_adjustTrove {\n        uint price;\n        uint collChange;\n        uint netDebtChange;\n        bool isCollIncrease;\n        uint debt;\n        uint coll;\n        uint oldICR;\n        uint newICR;\n        uint newTCR;\n        uint BaseFeeLMAFee;\n        uint newDebt;\n        uint newColl;\n        uint stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint price;\n        uint BaseFeeLMAFee;\n        uint netDebt;\n        uint compositeDebt;\n        uint ICR;\n        uint NICR;\n        uint stake;\n        uint arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IBaseFeeLMAToken baseFeeLMAToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event BaseFeeLMATokenAddressChanged(address _BaseFeeLMATokenAddress);\n    event HOGStakingAddressChanged(address _hogStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint _debt,\n        uint _coll,\n        uint stake,\n        BorrowerOperation operation\n    );\n    event BaseFeeLMABorrowingFeePaid(\n        address indexed _borrower,\n        uint _BaseFeeLMAFee\n    );\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _baseFeeLMATokenAddress,\n        address _hogStakingAddress\n    ) external onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn BaseFeeLMA\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_baseFeeLMATokenAddress);\n        checkContract(_hogStakingAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        baseFeeLMAToken = IBaseFeeLMAToken(_baseFeeLMATokenAddress);\n        hogStakingAddress = _hogStakingAddress;\n        hogStaking = IHOGStaking(_hogStakingAddress);\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit BaseFeeLMATokenAddressChanged(_baseFeeLMATokenAddress);\n        emit HOGStakingAddressChanged(_hogStakingAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint _maxFeePercentage,\n        uint _BaseFeeLMAAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable {\n        ContractsCache memory contractsCache = ContractsCache(\n            troveManager,\n            activePool,\n            baseFeeLMAToken\n        );\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.BaseFeeLMAFee;\n        vars.netDebt = _BaseFeeLMAAmount;\n\n        if (!isRecoveryMode) {\n            vars.BaseFeeLMAFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.baseFeeLMAToken,\n                _BaseFeeLMAAmount,\n                _maxFeePercentage\n            );\n            vars.netDebt = vars.netDebt.add(vars.BaseFeeLMAFee);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested BaseFeeLMA amount + BaseFeeLMA borrowing fee + BaseFeeLMA gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n\n        vars.ICR = LiquityMath._computeCR(\n            msg.value,\n            vars.compositeDebt,\n            vars.price\n        );\n        vars.NICR = LiquityMath._computeNominalCR(\n            msg.value,\n            vars.compositeDebt\n        );\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint newTCR = _getNewTCRFromTroveChange(\n                msg.value,\n                true,\n                vars.compositeDebt,\n                true,\n                vars.price\n            ); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, msg.value);\n        contractsCache.troveManager.increaseTroveDebt(\n            msg.sender,\n            vars.compositeDebt\n        );\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\n            msg.sender\n        );\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(\n            msg.sender\n        );\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        // Move the stETH to the Active Pool, and mint the BaseFeeLMAAmount to the borrower\n        _activePoolAddColl(contractsCache.activePool, msg.value);\n        _withdrawBaseFeeLMA(\n            contractsCache.activePool,\n            contractsCache.baseFeeLMAToken,\n            msg.sender,\n            _BaseFeeLMAAmount,\n            vars.netDebt\n        );\n        // Move the BaseFeeLMA gas compensation to the Gas Pool\n        _withdrawBaseFeeLMA(\n            contractsCache.activePool,\n            contractsCache.baseFeeLMAToken,\n            gasPoolAddress,\n            BaseFeeLMA_GAS_COMPENSATION,\n            BaseFeeLMA_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.compositeDebt,\n            msg.value,\n            vars.stake,\n            BorrowerOperation.openTrove\n        );\n        emit BaseFeeLMABorrowingFeePaid(msg.sender, vars.BaseFeeLMAFee);\n    }\n\n    // Send StETH as collateral to a trove\n    function addColl(address _upperHint, address _lowerHint) external payable {\n        _adjustTrove(msg.sender, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Send StETH as collateral to a trove. Called by only the Stability Pool.\n    function moveStETHGainToTrove(\n        address _borrower,\n        address _upperHint,\n        address _lowerHint\n    ) external payable {\n        _requireCallerIsStabilityPool();\n        _adjustTrove(_borrower, 0, 0, false, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw StETH collateral from a trove\n    function withdrawColl(\n        uint _collWithdrawal,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        _adjustTrove(\n            msg.sender,\n            _collWithdrawal,\n            0,\n            false,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    // Withdraw BaseFeeLMA tokens from a trove: mint new BaseFeeLMA tokens to the owner, and increase the trove's debt accordingly\n    function withdrawBaseFeeLMA(\n        uint _maxFeePercentage,\n        uint _BaseFeeLMAAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        _adjustTrove(\n            msg.sender,\n            0,\n            _BaseFeeLMAAmount,\n            true,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n    }\n\n    // Repay BaseFeeLMA tokens to a Trove: Burn the repaid BaseFeeLMA tokens, and reduce the trove's debt accordingly\n    function repayBaseFeeLMA(\n        uint _BaseFeeLMAAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        _adjustTrove(\n            msg.sender,\n            0,\n            _BaseFeeLMAAmount,\n            false,\n            _upperHint,\n            _lowerHint,\n            0\n        );\n    }\n\n    function adjustTrove(\n        uint _maxFeePercentage,\n        uint _collWithdrawal,\n        uint _BaseFeeLMAChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external payable {\n        _adjustTrove(\n            msg.sender,\n            _collWithdrawal,\n            _BaseFeeLMAChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n    }\n\n    /*\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     *\n     * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n     *\n     * If both are positive, it will revert.\n     */\n    function _adjustTrove(\n        address _borrower,\n        uint _collWithdrawal,\n        uint _BaseFeeLMAChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint _maxFeePercentage\n    ) internal {\n        ContractsCache memory contractsCache = ContractsCache(\n            troveManager,\n            activePool,\n            baseFeeLMAToken\n        );\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_BaseFeeLMAChange);\n        }\n        _requireSingularCollChange(_collWithdrawal);\n        _requireNonZeroAdjustment(_collWithdrawal, _BaseFeeLMAChange);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure StETH transfer from the Stability Pool to a trove\n        assert(\n            msg.sender == _borrower ||\n                (msg.sender == stabilityPoolAddress &&\n                    msg.value > 0 &&\n                    _BaseFeeLMAChange == 0)\n        );\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not StETH was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(\n            msg.value,\n            _collWithdrawal\n        );\n\n        vars.netDebtChange = _BaseFeeLMAChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) {\n            vars.BaseFeeLMAFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.baseFeeLMAToken,\n                _BaseFeeLMAChange,\n                _maxFeePercentage\n            );\n            vars.netDebtChange = vars.netDebtChange.add(vars.BaseFeeLMAFee); // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease,\n            vars.price\n        );\n        assert(_collWithdrawal <= vars.coll);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            _collWithdrawal,\n            _isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough BaseFeeLMA\n        if (!_isDebtIncrease && _BaseFeeLMAChange > 0) {\n            _requireAtLeastMinNetDebt(\n                _getNetDebt(vars.debt).sub(vars.netDebtChange)\n            );\n            _requireValidBaseFeeLMARepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientBaseFeeLMABalance(\n                contractsCache.baseFeeLMAToken,\n                _borrower,\n                vars.netDebtChange\n            );\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            _borrower,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\n            _borrower\n        );\n\n        // Re-insert trove in to the sorted list\n        uint newNICR = _getNewNominalICRFromTroveChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(\n            _borrower,\n            vars.newDebt,\n            vars.newColl,\n            vars.stake,\n            BorrowerOperation.adjustTrove\n        );\n        emit BaseFeeLMABorrowingFeePaid(msg.sender, vars.BaseFeeLMAFee);\n\n        // Use the unmodified _BaseFeeLMAChange here, as we don't send the fee to the user\n        _moveTokensAndStETHfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.baseFeeLMAToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _BaseFeeLMAChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        IBaseFeeLMAToken baseFeeLMATokenCached = baseFeeLMAToken;\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint price = priceFeed.fetchPrice();\n        _requireNotInRecoveryMode(price);\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientBaseFeeLMABalance(\n            baseFeeLMATokenCached,\n            msg.sender,\n            debt.sub(BaseFeeLMA_GAS_COMPENSATION)\n        );\n\n        uint newTCR = _getNewTCRFromTroveChange(\n            coll,\n            false,\n            debt,\n            false,\n            price\n        );\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid BaseFeeLMA from the user's balance and the gas compensation from the Gas Pool\n        _repayBaseFeeLMA(\n            activePoolCached,\n            baseFeeLMATokenCached,\n            msg.sender,\n            debt.sub(BaseFeeLMA_GAS_COMPENSATION)\n        );\n        _repayBaseFeeLMA(\n            activePoolCached,\n            baseFeeLMATokenCached,\n            gasPoolAddress,\n            BaseFeeLMA_GAS_COMPENSATION\n        );\n\n        // Send the collateral back to the user\n        activePoolCached.sendStETH(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external {\n        // send StETH from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IBaseFeeLMAToken _baseFeeLMAToken,\n        uint _BaseFeeLMAAmount,\n        uint _maxFeePercentage\n    ) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint BaseFeeLMAFee = _troveManager.getBorrowingFee(_BaseFeeLMAAmount);\n\n        _requireUserAcceptsFee(\n            BaseFeeLMAFee,\n            _BaseFeeLMAAmount,\n            _maxFeePercentage\n        );\n\n        // Send fee to HOG staking contract\n        hogStaking.increaseF_BaseFeeLMA(BaseFeeLMAFee);\n        _baseFeeLMAToken.mint(hogStakingAddress, BaseFeeLMAFee);\n\n        return BaseFeeLMAFee;\n    }\n\n    function _getUSDValue(\n        uint _coll,\n        uint _price\n    ) internal pure returns (uint) {\n        uint usdValue = _price.mul(_coll).div(DECIMAL_PRECISION);\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint _collReceived,\n        uint _requestedCollWithdrawal\n    ) internal pure returns (uint collChange, bool isCollIncrease) {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    ) internal returns (uint, uint) {\n        uint newColl = (_isCollIncrease)\n            ? _troveManager.increaseTroveColl(_borrower, _collChange)\n            : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint newDebt = (_isDebtIncrease)\n            ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n            : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndStETHfromAdjustment(\n        IActivePool _activePool,\n        IBaseFeeLMAToken _baseFeeLMAToken,\n        address _borrower,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _BaseFeeLMAChange,\n        bool _isDebtIncrease,\n        uint _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawBaseFeeLMA(\n                _activePool,\n                _baseFeeLMAToken,\n                _borrower,\n                _BaseFeeLMAChange,\n                _netDebtChange\n            );\n        } else {\n            _repayBaseFeeLMA(\n                _activePool,\n                _baseFeeLMAToken,\n                _borrower,\n                _BaseFeeLMAChange\n            );\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendStETH(_borrower, _collChange);\n        }\n    }\n\n    // Send StETH to Active Pool and increase its recorded StETH balance\n    function _activePoolAddColl(\n        IActivePool _activePool,\n        uint _amount\n    ) internal {\n        (bool success, ) = address(_activePool).call{value: _amount}(\"\");\n        require(success, \"BorrowerOps: Sending StETH to ActivePool failed\");\n    }\n\n    // Issue the specified amount of BaseFeeLMA to _account and increases the total active debt (_netDebtIncrease potentially includes a BaseFeeLMAFee)\n    function _withdrawBaseFeeLMA(\n        IActivePool _activePool,\n        IBaseFeeLMAToken _baseFeeLMAToken,\n        address _account,\n        uint _BaseFeeLMAAmount,\n        uint _netDebtIncrease\n    ) internal {\n        _activePool.increaseBaseFeeLMADebt(_netDebtIncrease);\n        _baseFeeLMAToken.mint(_account, _BaseFeeLMAAmount);\n    }\n\n    // Burn the specified amount of BaseFeeLMA from _account and decreases the total active debt\n    function _repayBaseFeeLMA(\n        IActivePool _activePool,\n        IBaseFeeLMAToken _baseFeeLMAToken,\n        address _account,\n        uint BaseFeeLMA\n    ) internal {\n        _activePool.decreaseBaseFeeLMADebt(BaseFeeLMA);\n        _baseFeeLMAToken.burn(_account, BaseFeeLMA);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireSingularCollChange(uint _collWithdrawal) internal view {\n        require(\n            msg.value == 0 || _collWithdrawal == 0,\n            \"BorrowerOperations: Cannot withdraw and add coll\"\n        );\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(\n            msg.sender == _borrower,\n            \"BorrowerOps: Caller must be the borrower for a withdrawal\"\n        );\n    }\n\n    function _requireNonZeroAdjustment(\n        uint _collWithdrawal,\n        uint _BaseFeeLMAChange\n    ) internal view {\n        require(\n            msg.value != 0 || _collWithdrawal != 0 || _BaseFeeLMAChange != 0,\n            \"BorrowerOps: There must be either a collateral change or a debt change\"\n        );\n    }\n\n    function _requireTroveisActive(\n        ITroveManager _troveManager,\n        address _borrower\n    ) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(\n        ITroveManager _troveManager,\n        address _borrower\n    ) internal view {\n        uint status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint _BaseFeeLMAChange) internal pure {\n        require(\n            _BaseFeeLMAChange > 0,\n            \"BorrowerOps: Debt increase requires non-zero debtChange\"\n        );\n    }\n\n    function _requireNotInRecoveryMode(uint _price) internal view {\n        require(\n            !_checkRecoveryMode(_price),\n            \"BorrowerOps: Operation not permitted during Recovery Mode\"\n        );\n    }\n\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\n        require(\n            _collWithdrawal == 0,\n            \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\"\n        );\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /*\n         *In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease,\n                _vars.price\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\n        require(\n            _newICR >= MCR,\n            \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint _newICR) internal pure {\n        require(\n            _newICR >= CCR,\n            \"BorrowerOps: Operation must leave trove with ICR >= CCR\"\n        );\n    }\n\n    function _requireNewICRisAboveOldICR(\n        uint _newICR,\n        uint _oldICR\n    ) internal pure {\n        require(\n            _newICR >= _oldICR,\n            \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\"\n        );\n    }\n\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\n        require(\n            _newTCR >= CCR,\n            \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\n        require(\n            _netDebt >= MIN_NET_DEBT,\n            \"BorrowerOps: Trove's net debt must be greater than minimum\"\n        );\n    }\n\n    function _requireValidBaseFeeLMARepayment(\n        uint _currentDebt,\n        uint _debtRepayment\n    ) internal pure {\n        require(\n            _debtRepayment <= _currentDebt.sub(BaseFeeLMA_GAS_COMPENSATION),\n            \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\"\n        );\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(\n            msg.sender == stabilityPoolAddress,\n            \"BorrowerOps: Caller is not Stability Pool\"\n        );\n    }\n\n    function _requireSufficientBaseFeeLMABalance(\n        IBaseFeeLMAToken _baseFeeLMAToken,\n        address _borrower,\n        uint _debtRepayment\n    ) internal view {\n        require(\n            _baseFeeLMAToken.balanceOf(_borrower) >= _debtRepayment,\n            \"BorrowerOps: Caller doesnt have enough BaseFeeLMA to make repayment\"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(\n        uint _maxFeePercentage,\n        bool _isRecoveryMode\n    ) internal pure {\n        if (_isRecoveryMode) {\n            require(\n                _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\"\n            );\n        } else {\n            require(\n                _maxFeePercentage >= BORROWING_FEE_FLOOR &&\n                    _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\"\n            );\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint) {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    ) internal pure returns (uint) {\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint _coll,\n        uint _debt,\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint, uint) {\n        uint newColl = _coll;\n        uint newDebt = _debt;\n\n        newColl = _isCollIncrease\n            ? _coll.add(_collChange)\n            : _coll.sub(_collChange);\n        newDebt = _isDebtIncrease\n            ? _debt.add(_debtChange)\n            : _debt.sub(_debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint _collChange,\n        bool _isCollIncrease,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        uint _price\n    ) internal view returns (uint) {\n        uint totalColl = getEntireSystemColl();\n        uint totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease\n            ? totalColl.add(_collChange)\n            : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease\n            ? totalDebt.add(_debtChange)\n            : totalDebt.sub(_debtChange);\n\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}\n"
    },
    "contracts/CollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\n\ncontract CollSurplusPool is Ownable, CheckContract {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"CollSurplusPool\";\n\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public activePoolAddress;\n\n    // deposited stETH tracker\n    uint256 internal StETH;\n    // Collateral surplus claimable by trove owners\n    mapping(address => uint) internal balances;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        renounceOwnership();\n    }\n\n    /* Returns the StETH state variable at ActivePool address.\n       Not necessarily equal to the raw stETH balance - stETH can be forcibly sent to contracts. */\n    function getStETH() external view returns (uint) {\n        return StETH;\n    }\n\n    function getCollateral(address _account) external view returns (uint) {\n        return balances[_account];\n    }\n\n    // --- Pool functionality ---\n\n    function accountSurplus(address _account, uint _amount) external {\n        _requireCallerIsTroveManager();\n\n        uint newAmount = balances[_account].add(_amount);\n        balances[_account] = newAmount;\n\n        emit CollBalanceUpdated(_account, newAmount);\n    }\n\n    function claimColl(address _account) external {\n        _requireCallerIsBorrowerOperations();\n        uint claimableColl = balances[_account];\n        require(\n            claimableColl > 0,\n            \"CollSurplusPool: No collateral available to claim\"\n        );\n\n        balances[_account] = 0;\n        emit CollBalanceUpdated(_account, 0);\n\n        StETH = StETH.sub(claimableColl);\n        emit EtherSent(_account, claimableColl);\n\n        (bool success, ) = _account.call{value: claimableColl}(\"\");\n        require(success, \"CollSurplusPool: sending StETH failed\");\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"CollSurplusPool: Caller is not Borrower Operations\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == troveManagerAddress,\n            \"CollSurplusPool: Caller is not TroveManager\"\n        );\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == activePoolAddress,\n            \"CollSurplusPool: Caller is not Active Pool\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        StETH = StETH.add(msg.value);\n    }\n}\n"
    },
    "contracts/DefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IPool.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\n\n/**\n * @notice Fork of Liquity's Default Pool. Logic remains unchanged.\n * Changes to the contract:\n * - Raised pragma version\n * - Removed an import of Default Interface and updated with IPool\n *\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\n *\n * The Default Pool holds the StETH and BaseFeeLMA debt (but not BaseFeeLMA tokens) from liquidations that have been redistributed\n * to active troves but not yet \"applied\", i.e. not yet recorded on a recipient active trove's struct.\n *\n * When a trove makes an operation that applies its pending StETH and BaseFeeLMA debt, its pending StETH and BaseFeeLMA debt is moved\n * from the Default Pool to the Active Pool.\n */\ncontract DefaultPool is Ownable, CheckContract, IPool {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"DefaultPool\";\n\n    address public troveManagerAddress;\n    address public activePoolAddress;\n    uint256 internal StETH; // deposited StETH tracker\n    uint256 internal BaseFeeLMADebt; // debt\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolBaseFeeLMADebtUpdated(uint _BaseFeeLMADebt);\n    event DefaultPoolStETHBalanceUpdated(uint _StETH);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external onlyOwner {\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n\n        troveManagerAddress = _troveManagerAddress;\n        activePoolAddress = _activePoolAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n     * Returns the StETH state variable.\n     *\n     * Not necessarily equal to the the contract's raw StETH balance - stETH can be forcibly sent to contracts.\n     */\n    function getStETH() external view returns (uint) {\n        return StETH;\n    }\n\n    function getBaseFeeLMADebt() external view override returns (uint) {\n        return BaseFeeLMADebt;\n    }\n\n    // --- Pool functionality ---\n\n    function sendStETHToActivePool(uint _amount) external {\n        _requireCallerIsTroveManager();\n        address activePool = activePoolAddress; // cache to save an SLOAD\n        StETH = StETH.sub(_amount);\n        emit DefaultPoolStETHBalanceUpdated(StETH);\n        emit StETHSent(activePool, _amount);\n\n        (bool success, ) = activePool.call{value: _amount}(\"\");\n        require(success, \"DefaultPool: sending StETH failed\");\n    }\n\n    function increaseBaseFeeLMADebt(uint _amount) external override {\n        _requireCallerIsTroveManager();\n        BaseFeeLMADebt = BaseFeeLMADebt.add(_amount);\n        emit DefaultPoolBaseFeeLMADebtUpdated(BaseFeeLMADebt);\n    }\n\n    function decreaseBaseFeeLMADebt(uint _amount) external override {\n        _requireCallerIsTroveManager();\n        BaseFeeLMADebt = BaseFeeLMADebt.sub(_amount);\n        emit DefaultPoolBaseFeeLMADebtUpdated(BaseFeeLMADebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == activePoolAddress,\n            \"DefaultPool: Caller is not the ActivePool\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == troveManagerAddress,\n            \"DefaultPool: Caller is not the TroveManager\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        StETH = StETH.add(msg.value);\n        emit DefaultPoolStETHBalanceUpdated(StETH);\n    }\n}\n"
    },
    "contracts/dependencies/BaseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ncontract BaseMath {\n    uint public constant DECIMAL_PRECISION = 1e18;\n}\n"
    },
    "contracts/dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ncontract CheckContract {\n    /**\n     * Check that the account is an already deployed non-destroyed contract.\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\n     */\n    function checkContract(address _account) internal view {\n        require(_account != address(0), \"Account cannot be zero address\");\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_account)\n        }\n        require(size > 0, \"Account code size cannot be zero\");\n    }\n}\n"
    },
    "contracts/dependencies/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n// Buidler's helper contract for console logging\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function log() internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log()\")\n        );\n        ignored;\n    }\n\n    function logInt(int p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(int)\", p0)\n        );\n        ignored;\n    }\n\n    function logUint(uint p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint)\", p0)\n        );\n        ignored;\n    }\n\n    function logString(string memory p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string)\", p0)\n        );\n        ignored;\n    }\n\n    function logBool(bool p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool)\", p0)\n        );\n        ignored;\n    }\n\n    function logAddress(address p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes)\", p0)\n        );\n        ignored;\n    }\n\n    function logByte(bytes1 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(byte)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes1)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes2)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes3)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes4)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes5)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes6)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes7)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes8)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes9)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes10)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes11)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes12)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes13)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes14)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes15)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes16)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes17)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes18)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes19)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes20)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes21)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes22)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes23)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes24)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes25)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes26)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes27)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes28)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes29)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes30)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes31)\", p0)\n        );\n        ignored;\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bytes32)\", p0)\n        );\n        ignored;\n    }\n\n    function log(uint p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint)\", p0)\n        );\n        ignored;\n    }\n\n    function log(string memory p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string)\", p0)\n        );\n        ignored;\n    }\n\n    function log(bool p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool)\", p0)\n        );\n        ignored;\n    }\n\n    function log(address p0) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address)\", p0)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,string)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,address)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,uint)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,string)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,bool)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,address)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,string)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,address)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,uint)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,string)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,bool)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,address)\", p0, p1)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        uint p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,uint,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,string,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,bool,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        uint p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(uint,address,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        uint p1,\n        address p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,uint,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        uint p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,string,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        bool p1,\n        address p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,bool,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        uint p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        bool p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        string memory p0,\n        address p1,\n        address p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(string,address,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        uint p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,uint,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,string,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3)\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,bool,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        bool p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(bool,address,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        uint p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        uint p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        uint p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,uint,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        uint p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        bool p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        string memory p1,\n        address p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,string,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        bool p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,bool,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,uint,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        address p1,\n        uint p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,uint,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,uint,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,uint,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        uint p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,string,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,string,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        bool p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,string,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        address p1,\n        string memory p2,\n        address p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,string,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,bool,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        address p1,\n        bool p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,bool,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,bool,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,bool,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,address,uint)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(\n        address p0,\n        address p1,\n        address p2,\n        string memory p3\n    ) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,address,string)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,address,bool)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        (bool ignored, ) = CONSOLE_ADDRESS.staticcall(\n            abi.encodeWithSignature(\n                \"log(address,address,address,address)\",\n                p0,\n                p1,\n                p2,\n                p3\n            )\n        );\n        ignored;\n    }\n}\n"
    },
    "contracts/dependencies/HedgehogBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./BaseMath.sol\";\nimport \"./LiquityMath.sol\";\nimport \"../interfaces/IActivePool.sol\";\nimport \"../interfaces/IDefaultPool.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IHedgehogBase.sol\";\n\n/**\n * @notice Fork of LiquityMath with an upgraded pragma and:\n * [ - Get OZ contracts from a package\n * TODO: List changes to HedgehogBase File and variables ]\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\ncontract HedgehogBase is BaseMath, IHedgehogBase {\n    using SafeMath for uint;\n\n    uint public constant _100pct = 1000000000000000000; // 1e18 == 100%\n\n    // Minimum collateral ratio for individual troves\n    uint public constant MCR = 1100000000000000000; // 110%\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint public constant CCR = 1500000000000000000; // 150%\n\n    // Amount of BaseFeeLMA to be locked in gas pool on opening troves\n    uint public constant BaseFeeLMA_GAS_COMPENSATION = 200e18;\n\n    // Minimum amount of net BaseFeeLMA debt a trove must have\n    uint public constant MIN_NET_DEBT = 1800e18;\n    // uint constant public MIN_NET_DEBT = 0;\n\n    uint public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    uint public constant BORROWING_FEE_FLOOR = (DECIMAL_PRECISION / 1000) * 5; // 0.5%\n\n    IActivePool public activePool;\n\n    IDefaultPool public defaultPool;\n\n    IPriceFeed public override priceFeed;\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\n        return _debt.add(BaseFeeLMA_GAS_COMPENSATION);\n    }\n\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\n        return _debt.sub(BaseFeeLMA_GAS_COMPENSATION);\n    }\n\n    // Return the amount of StETH to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(\n        uint _entireColl\n    ) internal pure returns (uint) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\n        uint activeColl = activePool.getStETH();\n        uint liquidatedColl = defaultPool.getStETH();\n\n        return activeColl.add(liquidatedColl);\n    }\n\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\n        uint activeDebt = activePool.getBaseFeeLMADebt();\n        uint closedDebt = defaultPool.getBaseFeeLMADebt();\n\n        return activeDebt.add(closedDebt);\n    }\n\n    function _getTCR(uint _price) internal view returns (uint TCR) {\n        uint entireSystemColl = getEntireSystemColl();\n        uint entireSystemDebt = getEntireSystemDebt();\n\n        TCR = LiquityMath._computeCR(\n            entireSystemColl,\n            entireSystemDebt,\n            _price\n        );\n\n        return TCR;\n    }\n\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\n        uint TCR = _getTCR(_price);\n\n        return TCR < CCR;\n    }\n\n    function _requireUserAcceptsFee(\n        uint _fee,\n        uint _amount,\n        uint _maxFeePercentage\n    ) internal pure {\n        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\n        require(\n            feePercentage <= _maxFeePercentage,\n            \"Fee exceeded provided maximum\"\n        );\n    }\n}\n"
    },
    "contracts/dependencies/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold StETH.\n *\n * See https://eips.stETHeum.org/EIPS/eip-2612.\n *\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.stETHeum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to\n     * a value in the near future. The deadline argument can be set to uint(-1) to\n     * create Permits that effectively never expire.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    function version() external view returns (string memory);\n\n    function permitTypeHash() external view returns (bytes32);\n\n    function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/dependencies/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./console.sol\";\n\n/**\n * @notice A fork of Liquity Math library with an upgraded pragma\n *\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\n */\n\nlibrary LiquityMath {\n    using SafeMath for uint;\n\n    uint internal constant DECIMAL_PRECISION = 1e18;\n\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it too high could lead to overflows.\n     * - Making it too low could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 StETH,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint internal constant NICR_PRECISION = 1e20;\n\n    function _min(uint _a, uint _b) internal pure returns (uint) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint _a, uint _b) internal pure returns (uint) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /*\n     * Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\n        uint prod_xy = x.mul(y);\n\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\n    }\n\n    /*\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n     *\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     *\n     * Called by two functions that represent time in units of minutes:\n     * 1) TroveManager._calcDecayedBaseRate\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\n     *\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n     *\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n     * negligibly different from just passing the cap, since:\n     *\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n     */\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\n        if (_minutes > 525600000) {\n            _minutes = 525600000;\n        } // cap to avoid overflow\n\n        if (_minutes == 0) {\n            return DECIMAL_PRECISION;\n        }\n\n        uint y = DECIMAL_PRECISION;\n        uint x = _base;\n        uint n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n.div(2);\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n.sub(1)).div(2);\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(\n        uint _a,\n        uint _b\n    ) internal pure returns (uint) {\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\n    }\n\n    function _computeNominalCR(\n        uint _coll,\n        uint _debt\n    ) internal pure returns (uint) {\n        if (_debt > 0) {\n            return _coll.mul(NICR_PRECISION).div(_debt);\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n\n    function _computeCR(\n        uint _coll,\n        uint _debt,\n        uint _price\n    ) internal pure returns (uint) {\n        if (_debt > 0) {\n            uint newCollRatio = _coll.mul(_price).div(_debt);\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n}\n"
    },
    "contracts/dependencies/LiquitySafeMath128.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n// uint128 addition and subtraction, with overflow protection.\n\nlibrary LiquitySafeMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        uint128 c = a + b;\n        require(c >= a, \"LiquitySafeMath128: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b <= a, \"LiquitySafeMath128: subtraction overflow\");\n        uint128 c = a - b;\n\n        return c;\n    }\n}\n"
    },
    "contracts/GasPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/**\n * The purpose of this contract is to hold BaseFeeLMA tokens for gas compensation:\n * https://github.com/liquity/dev#gas-compensation\n * When a borrower opens a trove, an additional 50 BaseFeeLMA debt is issued,\n * and 50 BaseFeeLMA is minted and sent to this contract.\n * When a borrower closes their active trove, this gas compensation is refunded:\n * 50 BaseFeeLMA is burned from the this contract's balance, and the corresponding\n * 50 BaseFeeLMA debt on the trove is cancelled.\n * See this issue for more context: https://github.com/liquity/dev/issues/186\n */\ncontract GasPool {\n    // do nothing, as the core contracts have permission to send to and burn from this address\n}\n"
    },
    "contracts/interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./IPool.sol\";\n\ninterface IActivePool is IPool {\n    // --- Events ---\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolBaseFeeLMADebtUpdated(uint _BaseFeeLMADebt);\n    event ActivePoolStETHBalanceUpdated(uint _StETH);\n\n    // --- Functions ---\n    function sendStETH(address _account, uint _amount) external;\n}\n"
    },
    "contracts/interfaces/IBaseFeeLMAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../dependencies/IERC2612.sol\";\n\ninterface IBaseFeeLMAToken is IERC20, IERC2612 {\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n\n    event BaseFeeLMATokenBalanceUpdated(address _user, uint _amount);\n\n    // --- Functions ---\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(\n        address _sender,\n        address poolAddress,\n        uint256 _amount\n    ) external;\n\n    function returnFromPool(\n        address poolAddress,\n        address user,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event BaseFeeLMATokenAddressChanged(address _baseFeeLMATokenAddress);\n    event HOGStakingAddressChanged(address _hogStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint _debt,\n        uint _coll,\n        uint stake,\n        uint8 operation\n    );\n    event BaseFeeLMABorrowingFeePaid(\n        address indexed _borrower,\n        uint _BaseFeeLMAFee\n    );\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _baseFeeLMATokenAddress,\n        address _hogStakingAddress\n    ) external;\n\n    function openTrove(\n        uint _maxFee,\n        uint _BaseFeeLMAAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function addColl(address _upperHint, address _lowerHint) external payable;\n\n    function moveStETHGainToTrove(\n        address _user,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function withdrawColl(\n        uint _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function withdrawBaseFeeLMA(\n        uint _maxFee,\n        uint _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function repayBaseFeeLMA(\n        uint _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(\n        uint _maxFee,\n        uint _collWithdrawal,\n        uint _debtChange,\n        bool isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external payable;\n\n    function claimCollateral() external;\n\n    function getCompositeDebt(uint _debt) external pure returns (uint);\n}\n"
    },
    "contracts/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface ICollSurplusPool {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\n    event StETHSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getStETH() external view returns (uint);\n\n    function getCollateral(address _account) external view returns (uint);\n\n    function accountSurplus(address _account, uint _amount) external;\n\n    function claimColl(address _account) external;\n}\n"
    },
    "contracts/interfaces/ICommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface ICommunityIssuance {\n    // --- Events ---\n\n    event HOGTokenAddressSet(address _hogTokenAddress);\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\n    event TotalHOGIssuedUpdated(uint _totalHOGIssued);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _hogTokenAddress,\n        address _stabilityPoolAddress\n    ) external;\n\n    function issueHOG() external returns (uint);\n\n    function sendHOG(address _account, uint _HOGamount) external;\n}\n"
    },
    "contracts/interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./IPool.sol\";\n\ninterface IDefaultPool is IPool {\n    // --- Events ---\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event DefaultPoolBaseFeeLMADebtUpdated(uint _BaseFeeLMADebt);\n    event DefaultPoolStETHBalanceUpdated(uint _StETH);\n\n    // --- Functions ---\n    function sendStETHToActivePool(uint _amount) external;\n}\n"
    },
    "contracts/interfaces/IHedgehogBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./IPriceFeed.sol\";\n\ninterface IHedgehogBase {\n    function priceFeed() external view returns (IPriceFeed);\n}\n"
    },
    "contracts/interfaces/IHOGStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IHOGStaking {\n    // --- Events --\n\n    event HOGTokenAddressSet(address _hogTokenAddress);\n    event BaseFeeLMATokenAddressSet(address _baseFeeLMATokenAddress);\n    event TroveManagerAddressSet(address _troveManager);\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n    event ActivePoolAddressSet(address _activePoolAddress);\n\n    event StakeChanged(address indexed staker, uint newStake);\n    event StakingGainsWithdrawn(\n        address indexed staker,\n        uint BaseFeeLMAGain,\n        uint StETHGain\n    );\n    event F_StETHUpdated(uint _F_StETH);\n    event F_BaseFeeLMAUpdated(uint _F_BaseFeeLMA);\n    event TotalHOGStakedUpdated(uint _totalHOGStaked);\n    event StETHSent(address _account, uint _amount);\n    event StakerSnapshotsUpdated(\n        address _staker,\n        uint _F_StETH,\n        uint _F_BaseFeeLMA\n    );\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _hogTokenAddress,\n        address _baseFeeLMATokenAddress,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    ) external;\n\n    function stake(uint _HOGamount) external;\n\n    function unstake(uint _HOGamount) external;\n\n    function increaseF_StETH(uint _StETHFee) external;\n\n    function increaseF_BaseFeeLMA(uint _HOGFee) external;\n\n    function getPendingStETHGain(address _user) external view returns (uint);\n\n    function getPendingBaseFeeLMAGain(\n        address _user\n    ) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IHOGToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../dependencies/IERC2612.sol\";\n\ninterface IHOGToken is IERC20, IERC2612 {\n    // --- Events ---\n\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\n    event HOGStakingAddressSet(address _hogStakingAddress);\n    event LockupContractFactoryAddressSet(\n        address _lockupContractFactoryAddress\n    );\n\n    // --- Functions ---\n\n    function sendToHOGStaking(address _sender, uint256 _amount) external;\n\n    function getDeploymentStartTime() external view returns (uint256);\n\n    function getLpRewardsEntitlement() external view returns (uint256);\n\n    function increaseAllowance(\n        address _spender,\n        uint256 _addedValues\n    ) external returns (bool);\n\n    function decreaseAllowance(\n        address _spender,\n        uint256 _decreasedValue\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n// Common interface for the Pools.\ninterface IPool {\n    // --- Events ---\n\n    event StETHBalanceUpdated(uint _newBalance);\n    event BaseFeeLMABalanceUpdated(uint _newBalance);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event StETHSent(address _to, uint _amount);\n\n    // --- Functions ---\n\n    function getStETH() external view returns (uint);\n\n    function getBaseFeeLMADebt() external view returns (uint);\n\n    function increaseBaseFeeLMADebt(uint _amount) external;\n\n    function decreaseBaseFeeLMADebt(uint _amount) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\ninterface IPriceFeed {\n    // --- Events ---\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\n\n    // --- Function ---\n    function fetchPrice() external returns (uint);\n}\n"
    },
    "contracts/interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n    // --- Events ---\n\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event NodeAdded(address _id, uint _NICR);\n    event NodeRemoved(address _id);\n\n    // --- Functions ---\n\n    function setParams(\n        uint256 _size,\n        address _TroveManagerAddress,\n        address _borrowerOperationsAddress\n    ) external;\n\n    function insert(\n        address _id,\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function remove(address _id) external;\n\n    function reInsert(\n        address _id,\n        uint256 _newICR,\n        address _prevId,\n        address _nextId\n    ) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (bool);\n\n    function findInsertPosition(\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (address, address);\n}\n"
    },
    "contracts/interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/*\n * The Stability Pool holds BaseFeeLMA tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its BaseFeeLMA debt gets offset with\n * BaseFeeLMA in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of BaseFeeLMA tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a BaseFeeLMA loss, in proportion to their deposit as a share of total deposits.\n * They also receive an StETH gain, as the StETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total BaseFeeLMA in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / StETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * --- HOG ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * A HOG issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued HOG in proportion to the deposit as a share of total deposits. The HOG earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#hog-issuance-to-stability-providers\n */\ninterface IStabilityPool {\n    // --- Events ---\n\n    event StabilityPoolStETHBalanceUpdated(uint _newBalance);\n    event StabilityPoolBaseFeeLMABalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(\n        address indexed _depositor,\n        uint _P,\n        uint _S,\n        uint _G\n    );\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint _newFrontEndStake,\n        address _depositor\n    );\n\n    event StETHGainWithdrawn(\n        address indexed _depositor,\n        uint _StETH,\n        uint _BaseFeeLMALoss\n    );\n    event HOGPaidToDepositor(address indexed _depositor, uint _HOG);\n    event HOGPaidToFrontEnd(address indexed _frontEnd, uint _HOG);\n    event StETHSent(address _to, uint _amount);\n\n    // --- Functions ---\n\n    /*\n     * Called only once on init, to set addresses of other Hedgehog contracts\n     * Callable only by owner, renounces ownership at the end\n     */\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _baseFeeLMATokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Frontend is registered or zero address\n     * - Sender is not a registered frontend\n     * - _amount is not zero\n     * ---\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (HOG, StETH) to depositor\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint _amount, address _frontEndTag) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (HOG, StETH) to depositor\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some StETH gain\n     * ---\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's HOG gain to  depositor\n     * - Sends all tagged front end's HOG gain to the tagged front end\n     * - Transfers the depositor's entire StETH gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged front end stake\n     */\n    function withdrawStETHGainToTrove(\n        address _upperHint,\n        address _lowerHint\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Frontend (sender) not already registered\n     * - User (sender) has no deposit\n     * - _kickbackRate is in the range [0, 100%]\n     * ---\n     * Front end makes a one-time selection of kickback rate upon registering\n     */\n    function registerFrontEnd(uint _kickbackRate) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the BaseFeeLMA contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's StETH collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint _debt, uint _coll) external;\n\n    /*\n     * Returns the total amount of StETH held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like StETH received from a self-destruct.\n     */\n    function getStETH() external view returns (uint);\n\n    /*\n     * Returns BaseFeeLMA held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalBaseFeeLMADeposits() external view returns (uint);\n\n    /*\n     * Calculates the StETH gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorStETHGain(\n        address _depositor\n    ) external view returns (uint);\n\n    /*\n     * Calculate the HOG gain earned by a deposit since its last snapshots were taken.\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n     * which they made their deposit.\n     */\n    function getDepositorHOGGain(\n        address _depositor\n    ) external view returns (uint);\n\n    /*\n     * Return the HOG gain earned by the front end.\n     */\n    function getFrontEndHOGGain(address _frontEnd) external view returns (uint);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedBaseFeeLMADeposit(\n        address _depositor\n    ) external view returns (uint);\n\n    /*\n     * Return the front end's compounded stake.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(\n        address _frontEnd\n    ) external view returns (uint);\n\n    /*\n     * Fallback function\n     * Only callable by Active Pool, it just accounts for StETH received\n     * receive() external payable;\n     */\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./IHedgehogBase.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./IBaseFeeLMAToken.sol\";\nimport \"./IHOGToken.sol\";\nimport \"./IHOGStaking.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is IHedgehogBase {\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event HOGTokenAddressChanged(address _hogTokenAddress);\n    event HOGStakingAddressChanged(address _hogStakingAddress);\n\n    event Liquidation(\n        uint _liquidatedDebt,\n        uint _liquidatedColl,\n        uint _collGasCompensation,\n        uint _BaseFeeLMAGasCompensation\n    );\n    event Redemption(\n        uint _attemptedBaseFeeLMAAmount,\n        uint _actualBaseFeeLMAAmount,\n        uint _StETHSent,\n        uint _StETHFee\n    );\n    event TroveUpdated(\n        address indexed _borrower,\n        uint _debt,\n        uint _coll,\n        uint stake,\n        uint8 operation\n    );\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint _debt,\n        uint _coll,\n        uint8 operation\n    );\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(uint _newTotalStakes);\n    event SystemSnapshotsUpdated(\n        uint _totalStakesSnapshot,\n        uint _totalCollateralSnapshot\n    );\n    event LTermsUpdated(uint _L_StETH, uint _L_BaseFeeLMADebt);\n    event TroveSnapshotsUpdated(uint _L_StETH, uint _L_BaseFeeLMADebt);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n\n    // --- Functions ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _baseFeeLMATokenAddress,\n        address _sortedTrovesAddress,\n        address _hogTokenAddress,\n        address _hogStakingAddress\n    ) external;\n\n    function stabilityPool() external view returns (IStabilityPool);\n\n    function baseFeeLMAToken() external view returns (IBaseFeeLMAToken);\n\n    function hogToken() external view returns (IHOGToken);\n\n    function hogStaking() external view returns (IHOGStaking);\n\n    function getTroveOwnersCount() external view returns (uint);\n\n    function getTroveFromTroveOwnersArray(\n        uint _index\n    ) external view returns (address);\n\n    function getNominalICR(address _borrower) external view returns (uint);\n\n    function getCurrentICR(\n        address _borrower,\n        uint _price\n    ) external view returns (uint);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint _BaseFeeLMAAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFee\n    ) external;\n\n    function updateStakeAndTotalStakes(\n        address _borrower\n    ) external returns (uint);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(\n        address _borrower\n    ) external returns (uint index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingStETHReward(\n        address _borrower\n    ) external view returns (uint);\n\n    function getPendingBaseFeeLMADebtReward(\n        address _borrower\n    ) external view returns (uint);\n\n    function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        external\n        view\n        returns (\n            uint debt,\n            uint coll,\n            uint pendingBaseFeeLMADebtReward,\n            uint pendingStETHReward\n        );\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getRedemptionRate() external view returns (uint);\n\n    function getRedemptionRateWithDecay() external view returns (uint);\n\n    function getRedemptionFeeWithDecay(\n        uint _StETHDrawn\n    ) external view returns (uint);\n\n    function getBorrowingRate() external view returns (uint);\n\n    function getBorrowingRateWithDecay() external view returns (uint);\n\n    function getBorrowingFee(uint BaseFeeLMADebt) external view returns (uint);\n\n    function getBorrowingFeeWithDecay(\n        uint _BaseFeeLMADebt\n    ) external view returns (uint);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint);\n\n    function getTroveStake(address _borrower) external view returns (uint);\n\n    function getTroveDebt(address _borrower) external view returns (uint);\n\n    function getTroveColl(address _borrower) external view returns (uint);\n\n    function setTroveStatus(address _borrower, uint num) external;\n\n    function increaseTroveColl(\n        address _borrower,\n        uint _collIncrease\n    ) external returns (uint);\n\n    function decreaseTroveColl(\n        address _borrower,\n        uint _collDecrease\n    ) external returns (uint);\n\n    function increaseTroveDebt(\n        address _borrower,\n        uint _debtIncrease\n    ) external returns (uint);\n\n    function decreaseTroveDebt(\n        address _borrower,\n        uint _collDecrease\n    ) external returns (uint);\n\n    function getTCR(uint _price) external view returns (uint);\n\n    function checkRecoveryMode(uint _price) external view returns (bool);\n}\n"
    },
    "contracts/MultiTroveGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"./TroveManager.sol\";\nimport \"./SortedTroves.sol\";\n\n/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */\ncontract MultiTroveGetter {\n    struct CombinedTroveData {\n        address owner;\n        uint debt;\n        uint coll;\n        uint stake;\n        uint snapshotETH;\n        uint snapshotBaseFeeLMADebt;\n    }\n\n    TroveManager public troveManager; // XXX Troves missing from ITroveManager?\n    ISortedTroves public sortedTroves;\n\n    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves) {\n        troveManager = _troveManager;\n        sortedTroves = _sortedTroves;\n    }\n\n    function getMultipleSortedTroves(\n        int _startIdx,\n        uint _count\n    ) external view returns (CombinedTroveData[] memory _troves) {\n        uint startIdx;\n        bool descend;\n\n        if (_startIdx >= 0) {\n            startIdx = uint(_startIdx);\n            descend = true;\n        } else {\n            startIdx = uint(-(_startIdx + 1));\n            descend = false;\n        }\n\n        uint sortedTrovesSize = sortedTroves.getSize();\n\n        if (startIdx >= sortedTrovesSize) {\n            _troves = new CombinedTroveData[](0);\n        } else {\n            uint maxCount = sortedTrovesSize - startIdx;\n\n            if (_count > maxCount) {\n                _count = maxCount;\n            }\n\n            if (descend) {\n                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);\n            } else {\n                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);\n            }\n        }\n    }\n\n    function _getMultipleSortedTrovesFromHead(\n        uint _startIdx,\n        uint _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        address currentTroveowner = sortedTroves.getFirst();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */\n                /* arrayIndex */\n                ,\n\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotBaseFeeLMADebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getNext(currentTroveowner);\n        }\n    }\n\n    function _getMultipleSortedTrovesFromTail(\n        uint _startIdx,\n        uint _count\n    ) internal view returns (CombinedTroveData[] memory _troves) {\n        address currentTroveowner = sortedTroves.getLast();\n\n        for (uint idx = 0; idx < _startIdx; ++idx) {\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n\n        _troves = new CombinedTroveData[](_count);\n\n        for (uint idx = 0; idx < _count; ++idx) {\n            _troves[idx].owner = currentTroveowner;\n            (\n                _troves[idx].debt,\n                _troves[idx].coll,\n                _troves[idx].stake,\n                /* status */\n                /* arrayIndex */\n                ,\n\n            ) = troveManager.Troves(currentTroveowner);\n            (\n                _troves[idx].snapshotETH,\n                _troves[idx].snapshotBaseFeeLMADebt\n            ) = troveManager.rewardSnapshots(currentTroveowner);\n\n            currentTroveowner = sortedTroves.getPrev(currentTroveowner);\n        }\n    }\n}\n"
    },
    "contracts/SortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\n\n/*\n * A sorted doubly linked list with nodes sorted in descending order.\n *\n * Nodes map to active Troves in the system - the ID property is the address of a Trove owner.\n * Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n * which is like the ICR but without the price, i.e., just collateral / debt.\n *\n * The list optionally accepts insert position hints.\n *\n * NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Troves\n * change dynamically as liquidation events occur.\n *\n * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Troves,\n * but maintains their order. A node inserted based on current NICR will maintain the correct position,\n * relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.\n * Thus, Nodes remain sorted by current NICR.\n *\n * Nodes need only be re-inserted upon a Trove operation - when the owner adds or removes collateral or debt\n * to their position.\n *\n * The list is a modification of the following audited SortedDoublyLinkedList:\n * https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n *\n *\n * Changes made in the Liquity implementation:\n *\n * - Keys have been removed from nodes\n *\n * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.\n *   The list relies on the property that ordering by ICR is maintained as the StETH:USD price varies.\n *\n * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access\n */\ncontract SortedTroves is Ownable, CheckContract {\n    using SafeMath for uint256;\n\n    string public constant NAME = \"SortedTroves\";\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event NodeAdded(address _id, uint _NICR);\n    event NodeRemoved(address _id);\n\n    address public borrowerOperationsAddress;\n\n    ITroveManager public troveManager;\n\n    // Information for a node in the list\n    struct Node {\n        bool exists;\n        address nextId; // Id of next node (smaller NICR) in the list\n        address prevId; // Id of previous node (larger NICR) in the list\n    }\n\n    // Information for the list\n    struct Data {\n        address head; // Head of the list. Also the node in the list with the largest NICR\n        address tail; // Tail of the list. Also the node in the list with the smallest NICR\n        uint256 maxSize; // Maximum size of the list\n        uint256 size; // Current size of the list\n        mapping(address => Node) nodes; // Track the corresponding ids for each node in the list\n    }\n\n    Data public data;\n\n    // --- Dependency setters ---\n\n    function setParams(\n        uint256 _size,\n        address _troveManagerAddress,\n        address _borrowerOperationsAddress\n    ) external onlyOwner {\n        require(_size > 0, \"SortedTroves: Size cant be zero\");\n        checkContract(_troveManagerAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        data.maxSize = _size;\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\n        renounceOwnership();\n    }\n\n    /*\n     * @dev Add a node to the list\n     * @param _id Node's id\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n\n    function insert(\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);\n    }\n\n    function _insert(\n        ITroveManager _troveManager,\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal {\n        // List must not be full\n        require(!isFull(), \"SortedTroves: List is full\");\n        // List must not already contain node\n        require(!contains(_id), \"SortedTroves: List already contains the node\");\n        // Node id must not be null\n        require(_id != address(0), \"SortedTroves: Id cannot be zero\");\n        // NICR must be non-zero\n        require(_NICR > 0, \"SortedTroves: NICR must be positive\");\n\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (!_validInsertPosition(_troveManager, _NICR, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(\n                _troveManager,\n                _NICR,\n                prevId,\n                nextId\n            );\n        }\n\n        data.nodes[_id].exists = true;\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            data.head = _id;\n            data.tail = _id;\n        } else if (prevId == address(0)) {\n            // Insert before `prevId` as the head\n            data.nodes[_id].nextId = data.head;\n            data.nodes[data.head].prevId = _id;\n            data.head = _id;\n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            data.nodes[_id].prevId = data.tail;\n            data.nodes[data.tail].nextId = _id;\n            data.tail = _id;\n        } else {\n            // Insert at insert position between `prevId` and `nextId`\n            data.nodes[_id].nextId = nextId;\n            data.nodes[_id].prevId = prevId;\n            data.nodes[prevId].nextId = _id;\n            data.nodes[nextId].prevId = _id;\n        }\n\n        data.size = data.size.add(1);\n        emit NodeAdded(_id, _NICR);\n    }\n\n    function remove(address _id) external {\n        _requireCallerIsTroveManager();\n        _remove(_id);\n    }\n\n    /*\n     * @dev Remove a node from the list\n     * @param _id Node's id\n     */\n    function _remove(address _id) internal {\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n\n        if (data.size > 1) {\n            // List contains more than a single node\n            if (_id == data.head) {\n                // The removed node is the head\n                // Set head to next node\n                data.head = data.nodes[_id].nextId;\n                // Set prev pointer of new head to null\n                data.nodes[data.head].prevId = address(0);\n            } else if (_id == data.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                data.tail = data.nodes[_id].prevId;\n                // Set next pointer of new tail to null\n                data.nodes[data.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                data.nodes[data.nodes[_id].prevId].nextId = data\n                    .nodes[_id]\n                    .nextId;\n                // Set prev pointer of next node to the previous node\n                data.nodes[data.nodes[_id].nextId].prevId = data\n                    .nodes[_id]\n                    .prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            data.head = address(0);\n            data.tail = address(0);\n        }\n\n        delete data.nodes[_id];\n        data.size = data.size.sub(1);\n        emit NodeRemoved(_id);\n    }\n\n    /*\n     * @dev Re-insert the node at a new position, based on its new NICR\n     * @param _id Node's id\n     * @param _newNICR Node's new NICR\n     * @param _prevId Id of previous node for the new insert position\n     * @param _nextId Id of next node for the new insert position\n     */\n    function reInsert(\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    ) external {\n        ITroveManager troveManagerCached = troveManager;\n\n        _requireCallerIsBOorTroveM(troveManagerCached);\n        // List must contain the node\n        require(contains(_id), \"SortedTroves: List does not contain the id\");\n        // NICR must be non-zero\n        require(_newNICR > 0, \"SortedTroves: NICR must be positive\");\n\n        // Remove node from the list\n        _remove(_id);\n\n        _insert(troveManagerCached, _id, _newNICR, _prevId, _nextId);\n    }\n\n    /*\n     * @dev Checks if the list contains a node\n     */\n    function contains(address _id) public view returns (bool) {\n        return data.nodes[_id].exists;\n    }\n\n    /*\n     * @dev Checks if the list is full\n     */\n    function isFull() public view returns (bool) {\n        return data.size == data.maxSize;\n    }\n\n    /*\n     * @dev Checks if the list is empty\n     */\n    function isEmpty() public view returns (bool) {\n        return data.size == 0;\n    }\n\n    /*\n     * @dev Returns the current size of the list\n     */\n    function getSize() external view returns (uint256) {\n        return data.size;\n    }\n\n    /*\n     * @dev Returns the maximum size of the list\n     */\n    function getMaxSize() external view returns (uint256) {\n        return data.maxSize;\n    }\n\n    /*\n     * @dev Returns the first node in the list (node with the largest NICR)\n     */\n    function getFirst() external view returns (address) {\n        return data.head;\n    }\n\n    /*\n     * @dev Returns the last node in the list (node with the smallest NICR)\n     */\n    function getLast() external view returns (address) {\n        return data.tail;\n    }\n\n    /*\n     * @dev Returns the next node (with a smaller NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getNext(address _id) external view returns (address) {\n        return data.nodes[_id].nextId;\n    }\n\n    /*\n     * @dev Returns the previous node (with a larger NICR) in the list for a given node\n     * @param _id Node's id\n     */\n    function getPrev(address _id) external view returns (address) {\n        return data.nodes[_id].prevId;\n    }\n\n    /*\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function validInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (bool) {\n        return _validInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _validInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (bool) {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty();\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return\n                data.head == _nextId &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return\n                data.tail == _prevId &&\n                _NICR <= _troveManager.getNominalICR(_prevId);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs\n            return\n                data.nodes[_prevId].nextId == _nextId &&\n                _troveManager.getNominalICR(_prevId) >= _NICR &&\n                _NICR >= _troveManager.getNominalICR(_nextId);\n        }\n    }\n\n    /*\n     * @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOADs\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start descending the list from\n     */\n    function _descendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the head, check if the insert position is before the head\n        if (\n            data.head == _startId &&\n            _NICR >= _troveManager.getNominalICR(_startId)\n        ) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = data.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (\n            prevId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            prevId = data.nodes[prevId].nextId;\n            nextId = data.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position\n     * @param _troveManager TroveManager contract, passed in as param to save SLOADs\n     * @param _NICR Node's NICR\n     * @param _startId Id of node to start ascending the list from\n     */\n    function _ascendList(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _startId\n    ) internal view returns (address, address) {\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (\n            data.tail == _startId &&\n            _NICR <= _troveManager.getNominalICR(_startId)\n        ) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = data.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (\n            nextId != address(0) &&\n            !_validInsertPosition(_troveManager, _NICR, prevId, nextId)\n        ) {\n            nextId = data.nodes[nextId].prevId;\n            prevId = data.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /*\n     * @dev Find the insert position for a new node with the given NICR\n     * @param _NICR Node's NICR\n     * @param _prevId Id of previous node for the insert position\n     * @param _nextId Id of next node for the insert position\n     */\n    function findInsertPosition(\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (address, address) {\n        return _findInsertPosition(troveManager, _NICR, _prevId, _nextId);\n    }\n\n    function _findInsertPosition(\n        ITroveManager _troveManager,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    ) internal view returns (address, address) {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (\n                !contains(prevId) || _NICR > _troveManager.getNominalICR(prevId)\n            ) {\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (\n                !contains(nextId) || _NICR < _troveManager.getNominalICR(nextId)\n            ) {\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_troveManager, _NICR, data.head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_troveManager, _NICR, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_troveManager, _NICR, prevId);\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == address(troveManager),\n            \"SortedTroves: Caller is not the TroveManager\"\n        );\n    }\n\n    function _requireCallerIsBOorTroveM(\n        ITroveManager _troveManager\n    ) internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n                msg.sender == address(_troveManager),\n            \"SortedTroves: Caller is neither BO nor TroveM\"\n        );\n    }\n}\n"
    },
    "contracts/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"./interfaces/IStabilityPool.sol\";\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/IBaseFeeLMAToken.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/ICommunityIssuance.sol\";\nimport \"./dependencies/HedgehogBase.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/LiquitySafeMath128.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\n\n/**\n * @notice Fork of Liquity's Stability Pool. Logic remains unchanged.\n * Changes to the contract:\n * - Raised pragma version\n * - Removed an import of IStabilityPool Interface\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\n *\n * The Stability Pool holds BaseFeeLMA tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its BaseFeeLMA debt gets offset with\n * BaseFeeLMA in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of BaseFeeLMA tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a BaseFeeLMA loss, in proportion to their deposit as a share of total deposits.\n * They also receive an StETH gain, as the StETH collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total BaseFeeLMA in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and StETH gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and StETH gain, we simply update two state variables:\n * a product P, and a sum S.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated StETH gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated StETH gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated StETH gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding StETH gain\n * can be calculated using the initial deposit, the depositors snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated StETH gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion BaseFeeLMA has depleted to < 1 BaseFeeLMA).\n *\n *\n *  --- TRACKING DEPOSITOR'S StETH GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated StETH gain, during the epoch in which the deposit was non-zero and earned StETH.\n *\n * We calculate the depositor's accumulated StETH gain for the scale at which they made the deposit, using the StETH gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated StETH gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / StETH gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n * --- HOG ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * A HOG issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued HOG in proportion to the deposit as a share of total deposits. The HOG earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#hog-issuance-to-stability-providers\n *\n * We use the same mathematical product-sum approach to track HOG gains for depositors, where 'G' is the sum corresponding to HOG gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is HedgehogBase, Ownable, CheckContract {\n    using LiquitySafeMath128 for uint128;\n    using SafeMath for uint256;\n\n    string public constant NAME = \"StabilityPool\";\n\n    IBorrowerOperations public borrowerOperations;\n\n    ITroveManager public troveManager;\n\n    IBaseFeeLMAToken public baseFeeLMAToken;\n\n    // Needed to check if there are pending liquidations\n    ISortedTroves public sortedTroves;\n\n    ICommunityIssuance public communityIssuance;\n\n    uint256 internal StETH; // deposited stETH tracker\n\n    // Tracker for BaseFeeLMA held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalBaseFeeLMADeposits;\n\n    // --- Data structures ---\n\n    struct FrontEnd {\n        uint kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        uint S;\n        uint P;\n        uint G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n\n    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct\n    mapping(address => uint) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\n    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some BaseFeeLMA debt with the deposit.\n     *\n     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     */\n    uint public P = DECIMAL_PRECISION;\n\n    uint public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* StETH Gain sum 'S': During its lifetime, each deposit d_t earns an StETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n     * is the depositor's snapshot of S taken at the time t when the deposit was made.\n     *\n     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n     *\n     * - The inner mapping records the sum S at different scales\n     * - The outer mapping records the (scale => sum) mappings, for different epochs.\n     */\n    mapping(uint128 => mapping(uint128 => uint)) public epochToScaleToSum;\n\n    /*\n     * Similarly, the sum 'G' is used to calculate HOG gains. During it's lifetime, each deposit d_t earns a HOG gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n     *\n     *  HOG reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the HOG reward is issued (i.e. G is updated), before other state changes are made.\n     */\n    mapping(uint128 => mapping(uint128 => uint)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the HOG issuance calculation\n    uint public lastHOGError;\n    // Error trackers for the error correction in the offset calculation\n    uint public lastStETHError_Offset;\n    uint public lastBaseFeeLMALossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolStETHBalanceUpdated(uint _newBalance);\n    event StabilityPoolBaseFeeLMABalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(\n        address indexed _depositor,\n        uint _P,\n        uint _S,\n        uint _G\n    );\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint _newFrontEndStake,\n        address _depositor\n    );\n\n    event StETHGainWithdrawn(\n        address indexed _depositor,\n        uint _StETH,\n        uint _BaseFeeLMALoss\n    );\n    event HOGPaidToDepositor(address indexed _depositor, uint _HOG);\n    event HOGPaidToFrontEnd(address indexed _frontEnd, uint _HOG);\n    event StETHSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _baseFeeLMATokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_baseFeeLMATokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_communityIssuanceAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        baseFeeLMAToken = IBaseFeeLMAToken(_baseFeeLMATokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit BaseFeeLMATokenAddressChanged(_baseFeeLMATokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    function getStETH() external view returns (uint) {\n        return StETH;\n    }\n\n    function getTotalBaseFeeLMADeposits() external view returns (uint) {\n        return totalBaseFeeLMADeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n     *\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (HOG, StETH) to depositor\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint _amount, address _frontEndTag) external {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerHOGIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        uint depositorStETHGain = getDepositorStETHGain(msg.sender);\n        uint compoundedBaseFeeLMADeposit = getCompoundedBaseFeeLMADeposit(\n            msg.sender\n        );\n        uint BaseFeeLMALoss = initialDeposit.sub(compoundedBaseFeeLMADeposit); // Needed only for event log\n\n        // First pay out any HOG gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutHOGGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendBaseFeeLMAtoStabilityPool(msg.sender, _amount);\n\n        uint newDeposit = compoundedBaseFeeLMADeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit StETHGainWithdrawn(msg.sender, depositorStETHGain, BaseFeeLMALoss); // BaseFeeLMA Loss required for event log\n\n        _sendStETHGainToDepositor(depositorStETHGain);\n    }\n\n    /*  withdrawFromSP():\n     *\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (HOG, StETH) to depositor\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint _amount) external {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerHOGIssuance(communityIssuanceCached);\n\n        uint depositorStETHGain = getDepositorStETHGain(msg.sender);\n\n        uint compoundedBaseFeeLMADeposit = getCompoundedBaseFeeLMADeposit(\n            msg.sender\n        );\n        uint BaseFeeLMAtoWithdraw = LiquityMath._min(\n            _amount,\n            compoundedBaseFeeLMADeposit\n        );\n        uint BaseFeeLMALoss = initialDeposit.sub(compoundedBaseFeeLMADeposit); // Needed only for event log\n\n        // First pay out any HOG gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutHOGGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake.sub(\n            BaseFeeLMAtoWithdraw\n        );\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendBaseFeeLMAToDepositor(msg.sender, BaseFeeLMAtoWithdraw);\n\n        // Update deposit\n        uint newDeposit = compoundedBaseFeeLMADeposit.sub(BaseFeeLMAtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit StETHGainWithdrawn(msg.sender, depositorStETHGain, BaseFeeLMALoss); // BaseFeeLMA Loss required for event log\n\n        _sendStETHGainToDepositor(depositorStETHGain);\n    }\n\n    /* withdrawStETHGainToTrove:\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's HOG gain to  depositor\n     * - Sends all tagged front end's HOG gain to the tagged front end\n     * - Transfers the depositor's entire StETH gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged front end stake */\n    function withdrawStETHGainToTrove(\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        uint initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        _requireUserHasTrove(msg.sender);\n        _requireUserHasStETHGain(msg.sender);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerHOGIssuance(communityIssuanceCached);\n\n        uint depositorStETHGain = getDepositorStETHGain(msg.sender);\n\n        uint compoundedBaseFeeLMADeposit = getCompoundedBaseFeeLMADeposit(\n            msg.sender\n        );\n        uint BaseFeeLMALoss = initialDeposit.sub(compoundedBaseFeeLMADeposit); // Needed only for event log\n\n        // First pay out any HOG gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutHOGGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint newFrontEndStake = compoundedFrontEndStake;\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _updateDepositAndSnapshots(msg.sender, compoundedBaseFeeLMADeposit);\n\n        /* Emit events before transferring StETH gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the StETH gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n        emit StETHGainWithdrawn(msg.sender, depositorStETHGain, BaseFeeLMALoss);\n        emit UserDepositChanged(msg.sender, compoundedBaseFeeLMADeposit);\n\n        StETH = StETH.sub(depositorStETHGain);\n        emit StabilityPoolStETHBalanceUpdated(StETH);\n        emit StETHSent(msg.sender, depositorStETHGain);\n\n        borrowerOperations.moveStETHGainToTrove{value: depositorStETHGain}(\n            msg.sender,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    // --- HOG issuance functions ---\n\n    function _triggerHOGIssuance(\n        ICommunityIssuance _communityIssuance\n    ) internal {\n        uint HOGIssuance = _communityIssuance.issueHOG();\n        _updateG(HOGIssuance);\n    }\n\n    function _updateG(uint _HOGIssuance) internal {\n        uint totalBaseFeeLMA = totalBaseFeeLMADeposits; // cached to save an SLOAD\n        /*\n         * When total deposits is 0, G is not updated. In this case, the HOG issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         *\n         */\n        if (totalBaseFeeLMA == 0 || _HOGIssuance == 0) {\n            return;\n        }\n\n        uint HOGPerUnitStaked;\n        HOGPerUnitStaked = _computeHOGPerUnitStaked(\n            _HOGIssuance,\n            totalBaseFeeLMA\n        );\n\n        uint marginalHOGGain = HOGPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[\n            currentEpoch\n        ][currentScale].add(marginalHOGGain);\n\n        emit G_Updated(\n            epochToScaleToG[currentEpoch][currentScale],\n            currentEpoch,\n            currentScale\n        );\n    }\n\n    function _computeHOGPerUnitStaked(\n        uint _HOGIssuance,\n        uint _totalBaseFeeLMADeposits\n    ) internal returns (uint) {\n        /*\n         * Calculate the HOG-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n         * cumulative error low in the running total G:\n         *\n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint HOGNumerator = _HOGIssuance.mul(DECIMAL_PRECISION).add(\n            lastHOGError\n        );\n\n        uint HOGPerUnitStaked = HOGNumerator.div(_totalBaseFeeLMADeposits);\n        lastHOGError = HOGNumerator.sub(\n            HOGPerUnitStaked.mul(_totalBaseFeeLMADeposits)\n        );\n\n        return HOGPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n     * Cancels out the specified debt against the BaseFeeLMA contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's StETH collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint _debtToOffset, uint _collToAdd) external {\n        _requireCallerIsTroveManager();\n        uint totalBaseFeeLMA = totalBaseFeeLMADeposits; // cached to save an SLOAD\n        if (totalBaseFeeLMA == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerHOGIssuance(communityIssuance);\n\n        (\n            uint StETHGainPerUnitStaked,\n            uint BaseFeeLMALossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(\n                _collToAdd,\n                _debtToOffset,\n                totalBaseFeeLMA\n            );\n\n        _updateRewardSumAndProduct(\n            StETHGainPerUnitStaked,\n            BaseFeeLMALossPerUnitStaked\n        ); // updates S and P\n\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n    function _computeRewardsPerUnitStaked(\n        uint _collToAdd,\n        uint _debtToOffset,\n        uint _totalBaseFeeLMADeposits\n    )\n        internal\n        returns (uint StETHGainPerUnitStaked, uint BaseFeeLMALossPerUnitStaked)\n    {\n        /*\n         * Compute the BaseFeeLMA and StETH rewards. Uses a \"feedback\" error correction, to keep\n         * the cumulative error in the P and S state variables low:\n         *\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratios.\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store these errors for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint StETHNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(\n            lastStETHError_Offset\n        );\n\n        assert(_debtToOffset <= _totalBaseFeeLMADeposits);\n        if (_debtToOffset == _totalBaseFeeLMADeposits) {\n            BaseFeeLMALossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastBaseFeeLMALossError_Offset = 0;\n        } else {\n            uint BaseFeeLMALossNumerator = _debtToOffset\n                .mul(DECIMAL_PRECISION)\n                .sub(lastBaseFeeLMALossError_Offset);\n            /*\n             * Add 1 to make error in quotient positive. We want \"slightly too much\" BaseFeeLMA loss,\n             * which ensures the error in any given compoundedBaseFeeLMADeposit favors the Stability Pool.\n             */\n            BaseFeeLMALossPerUnitStaked = (\n                BaseFeeLMALossNumerator.div(_totalBaseFeeLMADeposits)\n            ).add(1);\n            lastBaseFeeLMALossError_Offset = (\n                BaseFeeLMALossPerUnitStaked.mul(_totalBaseFeeLMADeposits)\n            ).sub(BaseFeeLMALossNumerator);\n        }\n\n        StETHGainPerUnitStaked = StETHNumerator.div(_totalBaseFeeLMADeposits);\n        lastStETHError_Offset = StETHNumerator.sub(\n            StETHGainPerUnitStaked.mul(_totalBaseFeeLMADeposits)\n        );\n\n        return (StETHGainPerUnitStaked, BaseFeeLMALossPerUnitStaked);\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        uint _StETHGainPerUnitStaked,\n        uint _BaseFeeLMALossPerUnitStaked\n    ) internal {\n        uint currentP = P;\n        uint newP;\n\n        assert(_BaseFeeLMALossPerUnitStaked <= DECIMAL_PRECISION);\n        /*\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool BaseFeeLMA in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - BaseFeeLMALossPerUnitStaked)\n         */\n        uint newProductFactor = uint(DECIMAL_PRECISION).sub(\n            _BaseFeeLMALossPerUnitStaked\n        );\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentS = epochToScaleToSum[currentEpochCached][\n            currentScaleCached\n        ];\n\n        /*\n         * Calculate the new S first, before we update P.\n         * The StETH gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         *\n         * Since S corresponds to StETH gain, and P to deposit loss, we update S first.\n         */\n        uint marginalStETHGain = _StETHGainPerUnitStaked.mul(currentP);\n        uint newS = currentS.add(marginalStETHGain);\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (\n            currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR\n        ) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(\n                DECIMAL_PRECISION\n            );\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        assert(newP > 0);\n        P = newP;\n\n        emit P_Updated(newP);\n    }\n\n    function _moveOffsetCollAndDebt(\n        uint _collToAdd,\n        uint _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n\n        // Cancel the liquidated BaseFeeLMA debt with the BaseFeeLMA in the stability pool\n        activePoolCached.decreaseBaseFeeLMADebt(_debtToOffset);\n        _decreaseBaseFeeLMA(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        baseFeeLMAToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendStETH(address(this), _collToAdd);\n    }\n\n    function _decreaseBaseFeeLMA(uint _amount) internal {\n        uint newTotalBaseFeeLMADeposits = totalBaseFeeLMADeposits.sub(_amount);\n        totalBaseFeeLMADeposits = newTotalBaseFeeLMADeposits;\n        emit StabilityPoolBaseFeeLMABalanceUpdated(newTotalBaseFeeLMADeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the StETH gain earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     */\n    function getDepositorStETHGain(\n        address _depositor\n    ) public view returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint StETHGain = _getStETHGainFromSnapshots(initialDeposit, snapshots);\n        return StETHGain;\n    }\n\n    function _getStETHGainFromSnapshots(\n        uint initialDeposit,\n        Snapshots memory snapshots\n    ) internal view returns (uint) {\n        /*\n         * Grab the sum 'S' from the epoch at which the stake was made. The StETH gain may span up to one scale change.\n         * If it does, the second portion of the StETH gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint S_Snapshot = snapshots.S;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(\n            S_Snapshot\n        );\n        uint secondPortion = epochToScaleToSum[epochSnapshot][\n            scaleSnapshot.add(1)\n        ].div(SCALE_FACTOR);\n\n        uint StETHGain = initialDeposit\n            .mul(firstPortion.add(secondPortion))\n            .div(P_Snapshot)\n            .div(DECIMAL_PRECISION);\n\n        return StETHGain;\n    }\n\n    /*\n     * Calculate the HOG gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  HOG = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     */\n    function getDepositorHOGGain(\n        address _depositor\n    ) public view returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /*\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         */\n        uint kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint HOGGain = kickbackRate\n            .mul(_getHOGGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return HOGGain;\n    }\n\n    /*\n     * Return the HOG gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n     *\n     * D0 is the last recorded value of the front end's total tagged deposits.\n     */\n    function getFrontEndHOGGain(address _frontEnd) public view returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint frontEndShare = uint(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint HOGGain = frontEndShare\n            .mul(_getHOGGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return HOGGain;\n    }\n\n    function _getHOGGainFromSnapshots(\n        uint initialStake,\n        Snapshots memory snapshots\n    ) internal view returns (uint) {\n        /*\n         * Grab the sum 'G' from the epoch at which the stake was made. The HOG gain may span up to one scale change.\n         * If it does, the second portion of the HOG gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint G_Snapshot = snapshots.G;\n        uint P_Snapshot = snapshots.P;\n\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(\n            G_Snapshot\n        );\n        uint secondPortion = epochToScaleToG[epochSnapshot][\n            scaleSnapshot.add(1)\n        ].div(SCALE_FACTOR);\n\n        uint HOGGain = initialStake\n            .mul(firstPortion.add(secondPortion))\n            .div(P_Snapshot)\n            .div(DECIMAL_PRECISION);\n\n        return HOGGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /*\n     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n     */\n    function getCompoundedBaseFeeLMADeposit(\n        address _depositor\n    ) public view returns (uint) {\n        uint initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots memory snapshots = depositSnapshots[_depositor];\n\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(\n            initialDeposit,\n            snapshots\n        );\n        return compoundedDeposit;\n    }\n\n    /*\n     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor's snapshot of the product P, taken at the last time\n     * when one of the front end's tagged deposits updated their deposit.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(\n        address _frontEnd\n    ) public view returns (uint) {\n        uint frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\n\n        uint compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(\n            frontEndStake,\n            snapshots\n        );\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\n    function _getCompoundedStakeFromSnapshots(\n        uint initialStake,\n        Snapshots memory snapshots\n    ) internal view returns (uint) {\n        uint snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) {\n            return 0;\n        }\n\n        uint compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(\n                SCALE_FACTOR\n            );\n        } else {\n            // if scaleDiff >= 2\n            compoundedStake = 0;\n        }\n\n        /*\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         *\n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n         * than it's theoretical value.\n         *\n         * Thus it's unclear whether this line is still really needed.\n         */\n        if (compoundedStake < initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for BaseFeeLMA deposit, StETH gains and HOG gains ---\n\n    // Transfer the BaseFeeLMA tokens from the user to the Stability Pool's address, and update its recorded BaseFeeLMA\n    function _sendBaseFeeLMAtoStabilityPool(\n        address _address,\n        uint _amount\n    ) internal {\n        baseFeeLMAToken.sendToPool(_address, address(this), _amount);\n        uint newTotalBaseFeeLMADeposits = totalBaseFeeLMADeposits.add(_amount);\n        totalBaseFeeLMADeposits = newTotalBaseFeeLMADeposits;\n        emit StabilityPoolBaseFeeLMABalanceUpdated(newTotalBaseFeeLMADeposits);\n    }\n\n    function _sendStETHGainToDepositor(uint _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n        uint newStETH = StETH.sub(_amount);\n        StETH = newStETH;\n        emit StabilityPoolStETHBalanceUpdated(newStETH);\n        emit StETHSent(msg.sender, _amount);\n\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"StabilityPool: sending StETH failed\");\n    }\n\n    // Send BaseFeeLMA to user and decrease BaseFeeLMA in Pool\n    function _sendBaseFeeLMAToDepositor(\n        address _depositor,\n        uint BaseFeeLMAWithdrawal\n    ) internal {\n        if (BaseFeeLMAWithdrawal == 0) {\n            return;\n        }\n\n        baseFeeLMAToken.returnFromPool(\n            address(this),\n            _depositor,\n            BaseFeeLMAWithdrawal\n        );\n        _decreaseBaseFeeLMA(BaseFeeLMAWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint _kickbackRate) external {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(\n        address _depositor,\n        address _frontEndTag\n    ) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n    function _updateDepositAndSnapshots(\n        address _depositor,\n        uint _newValue\n    ) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            delete depositSnapshots[_depositor];\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get S and G for the current epoch and current scale\n        uint currentS = epochToScaleToSum[currentEpochCached][\n            currentScaleCached\n        ];\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].S = currentS;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(\n        address _frontEnd,\n        uint _newValue\n    ) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutHOGGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end's HOG gain\n        if (_frontEnd != address(0)) {\n            uint frontEndHOGGain = getFrontEndHOGGain(_frontEnd);\n            _communityIssuance.sendHOG(_frontEnd, frontEndHOGGain);\n            emit HOGPaidToFrontEnd(_frontEnd, frontEndHOGGain);\n        }\n\n        // Pay out depositor's HOG gain\n        uint depositorHOGGain = getDepositorHOGGain(_depositor);\n        _communityIssuance.sendHOG(_depositor, depositorHOGGain);\n        emit HOGPaidToDepositor(_depositor, depositorHOGGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsActivePool() internal view {\n        require(\n            msg.sender == address(activePool),\n            \"StabilityPool: Caller is not ActivePool\"\n        );\n    }\n\n    function _requireCallerIsTroveManager() internal view {\n        require(\n            msg.sender == address(troveManager),\n            \"StabilityPool: Caller is not TroveManager\"\n        );\n    }\n\n    function _requireNoUnderCollateralizedTroves() internal {\n        uint price = priceFeed.fetchPrice();\n        address lowestTrove = sortedTroves.getLast();\n        uint ICR = troveManager.getCurrentICR(lowestTrove, price);\n        require(\n            ICR >= MCR,\n            \"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\"\n        );\n    }\n\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\n        require(\n            _initialDeposit > 0,\n            \"StabilityPool: User must have a non-zero deposit\"\n        );\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint initialDeposit = deposits[_address].initialValue;\n        require(\n            initialDeposit == 0,\n            \"StabilityPool: User must have no deposit\"\n        );\n    }\n\n    function _requireNonZeroAmount(uint _amount) internal pure {\n        require(_amount > 0, \"StabilityPool: Amount must be non-zero\");\n    }\n\n    function _requireUserHasTrove(address _depositor) internal view {\n        require(\n            troveManager.getTroveStatus(_depositor) == 1,\n            \"StabilityPool: caller must have an active trove to withdraw StETHGain to\"\n        );\n    }\n\n    function _requireUserHasStETHGain(address _depositor) internal view {\n        uint StETHGain = getDepositorStETHGain(_depositor);\n        require(\n            StETHGain > 0,\n            \"StabilityPool: caller must have non-zero StETH Gain\"\n        );\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            \"StabilityPool: must not already be a registered front end\"\n        );\n    }\n\n    function _requireFrontEndIsRegisteredOrZero(\n        address _address\n    ) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            \"StabilityPool: Tag must be a registered front end, or the zero address\"\n        );\n    }\n\n    function _requireValidKickbackRate(uint _kickbackRate) internal pure {\n        require(\n            _kickbackRate <= DECIMAL_PRECISION,\n            \"StabilityPool: Kickback rate must be in range [0,1]\"\n        );\n    }\n\n    // --- Fallback function ---\n\n    receive() external payable {\n        _requireCallerIsActivePool();\n        StETH = StETH.add(msg.value);\n        emit StabilityPoolStETHBalanceUpdated(StETH);\n    }\n}\n"
    },
    "contracts/TestContracts/CDPManagerTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../TroveManager.sol\";\n\n/* Tester contract inherits from TroveManager, and provides external functions \nfor testing the parent's internal functions. */\n\ncontract TroveManagerTester is TroveManager {\n    function computeICR(\n        uint _coll,\n        uint _debt,\n        uint _price\n    ) external pure returns (uint) {\n        return LiquityMath._computeCR(_coll, _debt, _price);\n    }\n\n    function getCollGasCompensation(uint _coll) external pure returns (uint) {\n        return _getCollGasCompensation(_coll);\n    }\n\n    function getBaseFeeLMAGasCompensation() external pure returns (uint) {\n        return BaseFeeLMA_GAS_COMPENSATION;\n    }\n\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n\n    function unprotectedDecayBaseRateFromBorrowing() external returns (uint) {\n        baseRate = _calcDecayedBaseRate();\n        assert(baseRate >= 0 && baseRate <= DECIMAL_PRECISION);\n\n        _updateLastFeeOpTime();\n        return baseRate;\n    }\n\n    function minutesPassedSinceLastFeeOp() external view returns (uint) {\n        return _minutesPassedSinceLastFeeOp();\n    }\n\n    function setLastFeeOpTimeToNow() external {\n        lastFeeOperationTime = block.timestamp;\n    }\n\n    function setBaseRate(uint _baseRate) external {\n        baseRate = _baseRate;\n    }\n\n    function callGetRedemptionFee(uint _ETHDrawn) external view returns (uint) {\n        _getRedemptionFee(_ETHDrawn);\n    }\n\n    function getActualDebtFromComposite(\n        uint _debtVal\n    ) external pure returns (uint) {\n        return _getNetDebt(_debtVal);\n    }\n\n    function callInternalRemoveTroveOwner(address _troveOwner) external {\n        uint troveOwnersArrayLength = TroveOwners.length;\n        _removeTroveOwner(_troveOwner, troveOwnersArrayLength);\n    }\n}\n"
    },
    "contracts/TestContracts/EchidnaProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../TroveManager.sol\";\nimport \"../BorrowerOperations.sol\";\nimport \"../StabilityPool.sol\";\nimport \"../BaseFeeLMAToken.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract EchidnaProxy {\n    TroveManager troveManager;\n    BorrowerOperations borrowerOperations;\n    StabilityPool stabilityPool;\n    BaseFeeLMAToken baseFeeLMAToken;\n\n    constructor(\n        TroveManager _troveManager,\n        BorrowerOperations _borrowerOperations,\n        StabilityPool _stabilityPool,\n        BaseFeeLMAToken _BaseFeeLMAToken\n    ) {\n        troveManager = _troveManager;\n        borrowerOperations = _borrowerOperations;\n        stabilityPool = _stabilityPool;\n        baseFeeLMAToken = _BaseFeeLMAToken;\n    }\n\n    receive() external payable {\n        // do nothing\n    }\n\n    // TroveManager\n\n    function liquidatePrx(address _user) external {\n        troveManager.liquidate(_user);\n    }\n\n    function liquidateTrovesPrx(uint _n) external {\n        troveManager.liquidateTroves(_n);\n    }\n\n    function batchLiquidateTrovesPrx(address[] calldata _troveArray) external {\n        troveManager.batchLiquidateTroves(_troveArray);\n    }\n\n    function redeemCollateralPrx(\n        uint _BaseFeeLMAAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFee\n    ) external {\n        troveManager.redeemCollateral(\n            _BaseFeeLMAAmount,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintNICR,\n            _maxIterations,\n            _maxFee\n        );\n    }\n\n    // Borrower Operations\n    function openTrovePrx(\n        uint _StETH,\n        uint _BaseFeeLMAAmount,\n        address _upperHint,\n        address _lowerHint,\n        uint _maxFee\n    ) external payable {\n        borrowerOperations.openTrove{value: _StETH}(\n            _maxFee,\n            _BaseFeeLMAAmount,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    function addCollPrx(\n        uint _StETH,\n        address _upperHint,\n        address _lowerHint\n    ) external payable {\n        borrowerOperations.addColl{value: _StETH}(_upperHint, _lowerHint);\n    }\n\n    function withdrawCollPrx(\n        uint _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        borrowerOperations.withdrawColl(_amount, _upperHint, _lowerHint);\n    }\n\n    function withdrawBaseFeeLMAPrx(\n        uint _amount,\n        address _upperHint,\n        address _lowerHint,\n        uint _maxFee\n    ) external {\n        borrowerOperations.withdrawBaseFeeLMA(\n            _maxFee,\n            _amount,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    function repayBaseFeeLMAPrx(\n        uint _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        borrowerOperations.repayBaseFeeLMA(_amount, _upperHint, _lowerHint);\n    }\n\n    function closeTrovePrx() external {\n        borrowerOperations.closeTrove();\n    }\n\n    function adjustTrovePrx(\n        uint _StETH,\n        uint _collWithdrawal,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint _maxFee\n    ) external payable {\n        borrowerOperations.adjustTrove{value: _StETH}(\n            _maxFee,\n            _collWithdrawal,\n            _debtChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    // Pool Manager\n    function provideToSPPrx(uint _amount, address _frontEndTag) external {\n        stabilityPool.provideToSP(_amount, _frontEndTag);\n    }\n\n    function withdrawFromSPPrx(uint _amount) external {\n        stabilityPool.withdrawFromSP(_amount);\n    }\n\n    // BaseFeeLMA Token\n\n    function transferPrx(\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return baseFeeLMAToken.transfer(recipient, amount);\n    }\n\n    function approvePrx(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return baseFeeLMAToken.approve(spender, amount);\n    }\n\n    function transferFromPrx(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return baseFeeLMAToken.transferFrom(sender, recipient, amount);\n    }\n\n    function increaseAllowancePrx(\n        address spender,\n        uint256 addedValue\n    ) external returns (bool) {\n        return baseFeeLMAToken.increaseAllowance(spender, addedValue);\n    }\n\n    function decreaseAllowancePrx(\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool) {\n        return baseFeeLMAToken.decreaseAllowance(spender, subtractedValue);\n    }\n}\n"
    },
    "contracts/TestContracts/EchidnaTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../TroveManager.sol\";\nimport \"../BorrowerOperations.sol\";\nimport \"../ActivePool.sol\";\nimport \"../DefaultPool.sol\";\nimport \"../StabilityPool.sol\";\nimport \"../GasPool.sol\";\nimport \"../CollSurplusPool.sol\";\nimport \"../BaseFeeLMAToken.sol\";\nimport \"./PriceFeedTestnet.sol\";\nimport \"../SortedTroves.sol\";\nimport \"./EchidnaProxy.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n//import \"../dependencies/console.sol\";\n\n// Run with:\n// rm -f fuzzTests/corpus/* # (optional)\n// ~/.local/bin/echidna-test contracts/TestContracts/EchidnaTester.sol --contract EchidnaTester --config fuzzTests/echidna_config.yaml\n\ncontract EchidnaTester {\n    using SafeMath for uint;\n\n    uint private constant NUMBER_OF_ACTORS = 100;\n    uint private constant INITIAL_BALANCE = 1e24;\n    uint private MCR;\n    uint private CCR;\n    uint private BaseFeeLMA_GAS_COMPENSATION;\n\n    TroveManager public troveManager;\n    BorrowerOperations public borrowerOperations;\n    ActivePool public activePool;\n    DefaultPool public defaultPool;\n    StabilityPool public stabilityPool;\n    GasPool public gasPool;\n    CollSurplusPool public collSurplusPool;\n    BaseFeeLMAToken public baseFeeLMAToken;\n    PriceFeedTestnet priceFeedTestnet;\n    SortedTroves sortedTroves;\n\n    EchidnaProxy[NUMBER_OF_ACTORS] public echidnaProxies;\n\n    uint private numberOfTroves;\n\n    constructor() payable {\n        troveManager = new TroveManager();\n        borrowerOperations = new BorrowerOperations();\n        activePool = new ActivePool();\n        defaultPool = new DefaultPool();\n        stabilityPool = new StabilityPool();\n        gasPool = new GasPool();\n        baseFeeLMAToken = new BaseFeeLMAToken(\n            address(troveManager),\n            address(stabilityPool),\n            address(borrowerOperations)\n        );\n\n        collSurplusPool = new CollSurplusPool();\n        priceFeedTestnet = new PriceFeedTestnet();\n\n        sortedTroves = new SortedTroves();\n\n        troveManager.setAddresses(\n            address(borrowerOperations),\n            address(activePool),\n            address(defaultPool),\n            address(stabilityPool),\n            address(gasPool),\n            address(collSurplusPool),\n            address(priceFeedTestnet),\n            address(baseFeeLMAToken),\n            address(sortedTroves),\n            address(0),\n            address(0)\n        );\n\n        borrowerOperations.setAddresses(\n            address(troveManager),\n            address(activePool),\n            address(defaultPool),\n            address(stabilityPool),\n            address(gasPool),\n            address(collSurplusPool),\n            address(priceFeedTestnet),\n            address(sortedTroves),\n            address(baseFeeLMAToken),\n            address(0)\n        );\n\n        activePool.setAddresses(\n            address(borrowerOperations),\n            address(troveManager),\n            address(stabilityPool),\n            address(defaultPool)\n        );\n\n        defaultPool.setAddresses(address(troveManager), address(activePool));\n\n        stabilityPool.setAddresses(\n            address(borrowerOperations),\n            address(troveManager),\n            address(activePool),\n            address(baseFeeLMAToken),\n            address(sortedTroves),\n            address(priceFeedTestnet),\n            address(0)\n        );\n\n        collSurplusPool.setAddresses(\n            address(borrowerOperations),\n            address(troveManager),\n            address(activePool)\n        );\n\n        sortedTroves.setParams(\n            1e18,\n            address(troveManager),\n            address(borrowerOperations)\n        );\n\n        for (uint i = 0; i < NUMBER_OF_ACTORS; i++) {\n            echidnaProxies[i] = new EchidnaProxy(\n                troveManager,\n                borrowerOperations,\n                stabilityPool,\n                baseFeeLMAToken\n            );\n            (bool success, ) = address(echidnaProxies[i]).call{\n                value: INITIAL_BALANCE\n            }(\"\");\n            require(success);\n        }\n\n        MCR = borrowerOperations.MCR();\n        CCR = borrowerOperations.CCR();\n        BaseFeeLMA_GAS_COMPENSATION = borrowerOperations\n            .BaseFeeLMA_GAS_COMPENSATION();\n        require(MCR > 0);\n        require(CCR > 0);\n\n        // TODO:\n        priceFeedTestnet.setPrice(1e22);\n    }\n\n    // TroveManager\n\n    function liquidateExt(uint _i, address _user) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].liquidatePrx(_user);\n    }\n\n    function liquidateTrovesExt(uint _i, uint _n) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].liquidateTrovesPrx(_n);\n    }\n\n    function batchLiquidateTrovesExt(\n        uint _i,\n        address[] calldata _troveArray\n    ) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].batchLiquidateTrovesPrx(_troveArray);\n    }\n\n    function redeemCollateralExt(\n        uint _i,\n        uint _BaseFeeLMAAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR\n    ) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].redeemCollateralPrx(\n            _BaseFeeLMAAmount,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintNICR,\n            0,\n            0\n        );\n    }\n\n    // Borrower Operations\n\n    function getAdjustedETH(\n        uint actorBalance,\n        uint _StETH,\n        uint ratio\n    ) internal view returns (uint) {\n        uint price = priceFeedTestnet.getPrice();\n        require(price > 0);\n        uint minETH = ratio.mul(BaseFeeLMA_GAS_COMPENSATION).div(price);\n        require(actorBalance > minETH);\n        uint StETH = minETH + (_StETH % (actorBalance - minETH));\n        return StETH;\n    }\n\n    function getAdjustedBaseFeeLMA(\n        uint StETH,\n        uint _BaseFeeLMAAmount,\n        uint ratio\n    ) internal view returns (uint) {\n        uint price = priceFeedTestnet.getPrice();\n        uint BaseFeeLMAAmount = _BaseFeeLMAAmount;\n        uint compositeDebt = BaseFeeLMAAmount.add(BaseFeeLMA_GAS_COMPENSATION);\n        uint ICR = LiquityMath._computeCR(StETH, compositeDebt, price);\n        if (ICR < ratio) {\n            compositeDebt = StETH.mul(price).div(ratio);\n            BaseFeeLMAAmount = compositeDebt.sub(BaseFeeLMA_GAS_COMPENSATION);\n        }\n        return BaseFeeLMAAmount;\n    }\n\n    function openTroveExt(\n        uint _i,\n        uint _StETH,\n        uint _BaseFeeLMAAmount\n    ) public payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        EchidnaProxy echidnaProxy = echidnaProxies[actor];\n        uint actorBalance = address(echidnaProxy).balance;\n\n        // we pass in CCR instead of MCR in case its the first one\n        uint StETH = getAdjustedETH(actorBalance, _StETH, CCR);\n        uint BaseFeeLMAAmount = getAdjustedBaseFeeLMA(\n            StETH,\n            _BaseFeeLMAAmount,\n            CCR\n        );\n\n        //console.log('StETH', StETH);\n        //console.log('BaseFeeLMAAmount', BaseFeeLMAAmount);\n\n        echidnaProxy.openTrovePrx(\n            StETH,\n            BaseFeeLMAAmount,\n            address(0),\n            address(0),\n            0\n        );\n\n        numberOfTroves = troveManager.getTroveOwnersCount();\n        assert(numberOfTroves > 0);\n        // canary\n        //assert(numberOfTroves == 0);\n    }\n\n    function openTroveRawExt(\n        uint _i,\n        uint _StETH,\n        uint _BaseFeeLMAAmount,\n        address _upperHint,\n        address _lowerHint,\n        uint _maxFee\n    ) public payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].openTrovePrx(\n            _StETH,\n            _BaseFeeLMAAmount,\n            _upperHint,\n            _lowerHint,\n            _maxFee\n        );\n    }\n\n    function addCollExt(uint _i, uint _StETH) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        EchidnaProxy echidnaProxy = echidnaProxies[actor];\n        uint actorBalance = address(echidnaProxy).balance;\n\n        uint StETH = getAdjustedETH(actorBalance, _StETH, MCR);\n\n        echidnaProxy.addCollPrx(StETH, address(0), address(0));\n    }\n\n    function addCollRawExt(\n        uint _i,\n        uint _StETH,\n        address _upperHint,\n        address _lowerHint\n    ) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].addCollPrx(_StETH, _upperHint, _lowerHint);\n    }\n\n    function withdrawCollExt(\n        uint _i,\n        uint _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].withdrawCollPrx(_amount, _upperHint, _lowerHint);\n    }\n\n    function withdrawBaseFeeLMAExt(\n        uint _i,\n        uint _amount,\n        address _upperHint,\n        address _lowerHint,\n        uint _maxFee\n    ) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].withdrawBaseFeeLMAPrx(\n            _amount,\n            _upperHint,\n            _lowerHint,\n            _maxFee\n        );\n    }\n\n    function repayBaseFeeLMAExt(\n        uint _i,\n        uint _amount,\n        address _upperHint,\n        address _lowerHint\n    ) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].repayBaseFeeLMAPrx(\n            _amount,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    function closeTroveExt(uint _i) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].closeTrovePrx();\n    }\n\n    function adjustTroveExt(\n        uint _i,\n        uint _StETH,\n        uint _collWithdrawal,\n        uint _debtChange,\n        bool _isDebtIncrease\n    ) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        EchidnaProxy echidnaProxy = echidnaProxies[actor];\n        uint actorBalance = address(echidnaProxy).balance;\n\n        uint StETH = getAdjustedETH(actorBalance, _StETH, MCR);\n        uint debtChange = _debtChange;\n        if (_isDebtIncrease) {\n            // TODO: add current amount already withdrawn:\n            debtChange = getAdjustedBaseFeeLMA(StETH, uint(_debtChange), MCR);\n        }\n        // TODO: collWithdrawal, debtChange\n        echidnaProxy.adjustTrovePrx(\n            StETH,\n            _collWithdrawal,\n            debtChange,\n            _isDebtIncrease,\n            address(0),\n            address(0),\n            0\n        );\n    }\n\n    function adjustTroveRawExt(\n        uint _i,\n        uint _StETH,\n        uint _collWithdrawal,\n        uint _debtChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint _maxFee\n    ) external payable {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].adjustTrovePrx(\n            _StETH,\n            _collWithdrawal,\n            _debtChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint,\n            _maxFee\n        );\n    }\n\n    // Pool Manager\n\n    function provideToSPExt(\n        uint _i,\n        uint _amount,\n        address _frontEndTag\n    ) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].provideToSPPrx(_amount, _frontEndTag);\n    }\n\n    function withdrawFromSPExt(uint _i, uint _amount) external {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].withdrawFromSPPrx(_amount);\n    }\n\n    // BaseFeeLMA Token\n\n    function transferExt(\n        uint _i,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].transferPrx(recipient, amount);\n    }\n\n    function approveExt(\n        uint _i,\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].approvePrx(spender, amount);\n    }\n\n    function transferFromExt(\n        uint _i,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].transferFromPrx(sender, recipient, amount);\n    }\n\n    function increaseAllowanceExt(\n        uint _i,\n        address spender,\n        uint256 addedValue\n    ) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].increaseAllowancePrx(spender, addedValue);\n    }\n\n    function decreaseAllowanceExt(\n        uint _i,\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool) {\n        uint actor = _i % NUMBER_OF_ACTORS;\n        echidnaProxies[actor].decreaseAllowancePrx(spender, subtractedValue);\n    }\n\n    // PriceFeed\n\n    function setPriceExt(uint256 _price) external {\n        bool result = priceFeedTestnet.setPrice(_price);\n        assert(result);\n    }\n\n    // --------------------------\n    // Invariants and properties\n    // --------------------------\n\n    function echidna_canary_number_of_troves() public view returns (bool) {\n        if (numberOfTroves > 20) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function echidna_canary_active_pool_balance() public view returns (bool) {\n        if (address(activePool).balance > 0) {\n            return false;\n        }\n        return true;\n    }\n\n    function echidna_troves_order() external view returns (bool) {\n        address currentTrove = sortedTroves.getFirst();\n        address nextTrove = sortedTroves.getNext(currentTrove);\n\n        while (currentTrove != address(0) && nextTrove != address(0)) {\n            if (\n                troveManager.getNominalICR(nextTrove) >\n                troveManager.getNominalICR(currentTrove)\n            ) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            currentTrove = nextTrove;\n            nextTrove = sortedTroves.getNext(currentTrove);\n        }\n\n        return true;\n    }\n\n    /**\n     * Status\n     * Minimum debt (gas compensation)\n     * Stake > 0\n     */\n    function echidna_trove_properties() public view returns (bool) {\n        address currentTrove = sortedTroves.getFirst();\n        while (currentTrove != address(0)) {\n            // Status\n            if (\n                TroveManager.Status(\n                    troveManager.getTroveStatus(currentTrove)\n                ) != TroveManager.Status.active\n            ) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            // Minimum debt (gas compensation)\n            if (\n                troveManager.getTroveDebt(currentTrove) <\n                BaseFeeLMA_GAS_COMPENSATION\n            ) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            // Stake > 0\n            if (troveManager.getTroveStake(currentTrove) == 0) {\n                return false;\n            }\n            // Uncomment to check that the condition is meaningful\n            //else return false;\n\n            currentTrove = sortedTroves.getNext(currentTrove);\n        }\n        return true;\n    }\n\n    function echidna_ETH_balances() public view returns (bool) {\n        if (address(troveManager).balance > 0) {\n            return false;\n        }\n\n        if (address(borrowerOperations).balance > 0) {\n            return false;\n        }\n\n        if (address(activePool).balance != activePool.getStETH()) {\n            return false;\n        }\n\n        if (address(defaultPool).balance != defaultPool.getStETH()) {\n            return false;\n        }\n\n        if (address(stabilityPool).balance != stabilityPool.getStETH()) {\n            return false;\n        }\n\n        if (address(baseFeeLMAToken).balance > 0) {\n            return false;\n        }\n\n        if (address(priceFeedTestnet).balance > 0) {\n            return false;\n        }\n\n        if (address(sortedTroves).balance > 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // TODO: What should we do with this? Should it be allowed? Should it be a canary?\n    function echidna_price() public view returns (bool) {\n        uint price = priceFeedTestnet.getPrice();\n\n        if (price == 0) {\n            return false;\n        }\n        // Uncomment to check that the condition is meaningful\n        //else return false;\n\n        return true;\n    }\n\n    // Total BaseFeeLMA matches\n    function echidna_BaseFeeLMA_global_balances() public view returns (bool) {\n        uint totalSupply = baseFeeLMAToken.totalSupply();\n        uint gasPoolBalance = baseFeeLMAToken.balanceOf(address(gasPool));\n\n        uint activePoolBalance = activePool.getBaseFeeLMADebt();\n        uint defaultPoolBalance = defaultPool.getBaseFeeLMADebt();\n        if (totalSupply != activePoolBalance + defaultPoolBalance) {\n            return false;\n        }\n\n        uint stabilityPoolBalance = stabilityPool.getTotalBaseFeeLMADeposits();\n        address currentTrove = sortedTroves.getFirst();\n        uint trovesBalance;\n        while (currentTrove != address(0)) {\n            trovesBalance += baseFeeLMAToken.balanceOf(address(currentTrove));\n            currentTrove = sortedTroves.getNext(currentTrove);\n        }\n        // we cannot state equality because tranfers are made to external addresses too\n        if (\n            totalSupply <= stabilityPoolBalance + trovesBalance + gasPoolBalance\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /*\n    function echidna_test() public view returns(bool) {\n        return true;\n    }\n    */\n}\n"
    },
    "contracts/TestContracts/PriceFeedTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IPriceFeed.sol\";\n\n/*\n * PriceFeed placeholder for testnet and development. The price is simply set manually and saved in a state\n * variable. The contract does not connect to a live Chainlink price feed.\n */\ncontract PriceFeedTestnet is IPriceFeed {\n    uint256 private _price = 200 * 1e18;\n\n    // --- Functions ---\n\n    // View price getter for simplicity in tests\n    function getPrice() external view returns (uint256) {\n        return _price;\n    }\n\n    function fetchPrice() external override returns (uint256) {\n        // Fire an event just like the mainnet version would.\n        // This lets the subgraph rely on events to get the latest price even when developing locally.\n        emit LastGoodPriceUpdated(_price);\n        return _price;\n    }\n\n    // Manual external price setter.\n    function setPrice(uint256 price) external returns (bool) {\n        _price = price;\n        return true;\n    }\n}\n"
    },
    "contracts/TroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/IStabilityPool.sol\";\nimport \"./interfaces/ICollSurplusPool.sol\";\nimport \"./interfaces/IBaseFeeLMAToken.sol\";\nimport \"./interfaces/ISortedTroves.sol\";\nimport \"./interfaces/IHOGToken.sol\";\nimport \"./interfaces/IHOGStaking.sol\";\nimport \"./dependencies/HedgehogBase.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./dependencies/CheckContract.sol\";\nimport \"./dependencies/console.sol\";\n\n/**\n * @notice Fork of Liquity's TroveManager. Logic remains unchanged.\n * Changes to the contract:\n * - Raised pragma version\n * - Removed an import of ActivePool Interface\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\n */\n\ncontract TroveManager is HedgehogBase, Ownable, CheckContract {\n    using SafeMath for uint256;\n    string public constant NAME = \"TroveManager\";\n\n    // --- Connected contract declarations ---\n\n    address public borrowerOperationsAddress;\n\n    IStabilityPool public stabilityPool;\n\n    address gasPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IBaseFeeLMAToken public baseFeeLMAToken;\n\n    IHOGToken public hogToken;\n\n    IHOGStaking public hogStaking;\n\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    // --- Data structures ---\n\n    uint public constant SECONDS_IN_ONE_MINUTE = 60;\n    /*\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 => d = (1/2)^(1/720)\n     */\n    uint public constant MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint public constant REDEMPTION_FEE_FLOOR = (DECIMAL_PRECISION / 1000) * 5; // 0.5%\n    uint public constant MAX_BORROWING_FEE = (DECIMAL_PRECISION / 100) * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint public constant BOOTSTRAP_PERIOD = 14 days;\n\n    /*\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\n     * Corresponds to (1 / ALPHA) in the white paper.\n     */\n    uint public constant BETA = 2;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new BaseFeeLMA issuance)\n    uint public lastFeeOperationTime;\n\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption\n    }\n\n    // Store the necessary data for a trove\n    struct Trove {\n        uint debt;\n        uint coll;\n        uint stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    mapping(address => Trove) public Troves;\n\n    uint public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    uint public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    uint public totalCollateralSnapshot;\n\n    /*\n     * L_StETH and L_BaseFeeLMADebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\n     *\n     * An StETH gain of ( stake * [L_StETH - L_StETH(0)] )\n     * A BaseFeeLMADebt increase  of ( stake * [L_BaseFeeLMADebt - L_BaseFeeLMADebt(0)] )\n     *\n     * Where L_StETH(0) and L_BaseFeeLMADebt(0) are snapshots of L_StETH and L_BaseFeeLMADebt for the active Trove taken at the instant the stake was made\n     */\n    uint public L_StETH;\n    uint public L_BaseFeeLMADebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping(address => RewardSnapshot) public rewardSnapshots;\n\n    // Object containing the StETH and BaseFeeLMA snapshots for a given active trove\n    struct RewardSnapshot {\n        uint StETH;\n        uint BaseFeeLMADebt;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] public TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    uint public lastStETHError_Redistribution;\n    uint public lastBaseFeeLMADebtError_Redistribution;\n\n    /*\n     * --- Variable container structs for liquidations ---\n     *\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\n     * in order to avoid the error: \"CompilerError: Stack too deep\".\n     **/\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint price;\n        uint BaseFeeLMAInStabPool;\n        bool recoveryModeAtStart;\n        uint liquidatedDebt;\n        uint liquidatedColl;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint collToLiquidate;\n        uint pendingDebtReward;\n        uint pendingCollReward;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint remainingBaseFeeLMAInStabPool;\n        uint i;\n        uint ICR;\n        address user;\n        bool backToNormalMode;\n        uint entireSystemDebt;\n        uint entireSystemColl;\n    }\n\n    struct LiquidationValues {\n        uint entireTroveDebt;\n        uint entireTroveColl;\n        uint collGasCompensation;\n        uint BaseFeeLMAGasCompensation;\n        uint debtToOffset;\n        uint collToSendToSP;\n        uint debtToRedistribute;\n        uint collToRedistribute;\n        uint collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint totalCollInSequence;\n        uint totalDebtInSequence;\n        uint totalCollGasCompensation;\n        uint totalBaseFeeLMAGasCompensation;\n        uint totalDebtToOffset;\n        uint totalCollToSendToSP;\n        uint totalDebtToRedistribute;\n        uint totalCollToRedistribute;\n        uint totalCollSurplus;\n    }\n\n    struct ContractsCache {\n        IActivePool activePool;\n        IDefaultPool defaultPool;\n        IBaseFeeLMAToken baseFeeLMAToken;\n        IHOGStaking hogStaking;\n        ISortedTroves sortedTroves;\n        ICollSurplusPool collSurplusPool;\n        address gasPoolAddress;\n    }\n    // --- Variable container structs for redemptions ---\n\n    struct RedemptionTotals {\n        uint remainingBaseFeeLMA;\n        uint totalBaseFeeLMAToRedeem;\n        uint totalStETHDrawn;\n        uint StETHFee;\n        uint StETHToSendToRedeemer;\n        uint decayedBaseRate;\n        uint price;\n        uint totalBaseFeeLMASupplyAtStart;\n    }\n\n    struct SingleRedemptionValues {\n        uint BaseFeeLMALot;\n        uint StETHLot;\n        bool cancelledPartial;\n    }\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(\n        address _newBorrowerOperationsAddress\n    );\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event HOGTokenAddressChanged(address _hogTokenAddress);\n    event HOGStakingAddressChanged(address _hogStakingAddress);\n\n    event Liquidation(\n        uint _liquidatedDebt,\n        uint _liquidatedColl,\n        uint _collGasCompensation,\n        uint _BaseFeeLMAGasCompensation\n    );\n    event Redemption(\n        uint _attemptedBaseFeeLMAAmount,\n        uint _actualBaseFeeLMAAmount,\n        uint _StETHSent,\n        uint _StETHFee\n    );\n    event TroveUpdated(\n        address indexed _borrower,\n        uint _debt,\n        uint _coll,\n        uint _stake,\n        TroveManagerOperation _operation\n    );\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint _debt,\n        uint _coll,\n        TroveManagerOperation _operation\n    );\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(uint _newTotalStakes);\n    event SystemSnapshotsUpdated(\n        uint _totalStakesSnapshot,\n        uint _totalCollateralSnapshot\n    );\n    event LTermsUpdated(uint _L_StETH, uint _L_BaseFeeLMADebt);\n    event TroveSnapshotsUpdated(uint _L_StETH, uint _L_BaseFeeLMADebt);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n\n    enum TroveManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral\n    }\n\n    // --- Dependency setter ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _baseFeeLMATokenAddress,\n        address _sortedTrovesAddress,\n        address _hogTokenAddress,\n        address _hogStakingAddress\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_baseFeeLMATokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_hogTokenAddress);\n        checkContract(_hogStakingAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        baseFeeLMAToken = IBaseFeeLMAToken(_baseFeeLMATokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        hogToken = IHOGToken(_hogTokenAddress);\n        hogStaking = IHOGStaking(_hogStakingAddress);\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit BaseFeeLMATokenAddressChanged(_baseFeeLMATokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit HOGTokenAddressChanged(_hogTokenAddress);\n        emit HOGStakingAddressChanged(_hogStakingAddress);\n\n        renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(\n        uint _index\n    ) external view returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTroves(borrowers);\n    }\n\n    // --- Inner single liquidation functions ---\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint _BaseFeeLMAInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = getEntireDebtAndColl(_borrower);\n\n        _movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        );\n        _removeStake(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation\n            .BaseFeeLMAGasCompensation = BaseFeeLMA_GAS_COMPENSATION; // TODO: Why is that being done if BaseFeeLMA_GAS_COMP is static\n        uint collToLiquidate = singleLiquidation.entireTroveColl.sub(\n            singleLiquidation.collGasCompensation\n        );\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute\n        ) = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            collToLiquidate,\n            _BaseFeeLMAInStabPool\n        );\n\n        _closeTrove(_borrower, Status.closedByLiquidation);\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        emit TroveUpdated(\n            _borrower,\n            0,\n            0,\n            0,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        return singleLiquidation;\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint _ICR,\n        uint _BaseFeeLMAInStabPool,\n        uint _TCR,\n        uint _price\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (TroveOwners.length <= 1) {\n            return singleLiquidation;\n        } // don't liquidate if last trove\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = getEntireDebtAndColl(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation\n            .BaseFeeLMAGasCompensation = BaseFeeLMA_GAS_COMPENSATION;\n        vars.collToLiquidate = singleLiquidation.entireTroveColl.sub(\n            singleLiquidation.collGasCompensation\n        );\n\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR <= _100pct) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            _removeStake(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation\n                .entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n\n            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            _removeStake(_borrower);\n\n            (\n                singleLiquidation.debtToOffset,\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.debtToRedistribute,\n                singleLiquidation.collToRedistribute\n            ) = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _BaseFeeLMAInStabPool\n            );\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /*\n             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is BaseFeeLMA in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             */\n        } else if (\n            (_ICR >= MCR) &&\n            (_ICR < _TCR) &&\n            (singleLiquidation.entireTroveDebt <= _BaseFeeLMAInStabPool)\n        ) {\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward\n            );\n            assert(_BaseFeeLMAInStabPool != 0);\n\n            _removeStake(_borrower);\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl,\n                _price\n            );\n\n            _closeTrove(_borrower, Status.closedByLiquidation);\n            if (singleLiquidation.collSurplus > 0) {\n                collSurplusPool.accountSurplus(\n                    _borrower,\n                    singleLiquidation.collSurplus\n                );\n            }\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.collToSendToSP,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _BaseFeeLMAInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves.\n     */\n    function _getOffsetAndRedistributionVals(\n        uint _debt,\n        uint _coll,\n        uint _BaseFeeLMAInStabPool\n    )\n        internal\n        pure\n        returns (\n            uint debtToOffset,\n            uint collToSendToSP,\n            uint debtToRedistribute,\n            uint collToRedistribute\n        )\n    {\n        if (_BaseFeeLMAInStabPool > 0) {\n            /*\n             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             *\n             *  If the trove's debt is larger than the deposited BaseFeeLMA in the Stability Pool:\n             *\n             *  - Offset an amount of the trove's debt equal to the BaseFeeLMA in the Stability Pool\n             *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\n             *\n             */\n            debtToOffset = LiquityMath._min(_debt, _BaseFeeLMAInStabPool);\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\n            debtToRedistribute = _debt.sub(debtToOffset);\n            collToRedistribute = _coll.sub(collToSendToSP);\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /*\n     *  Get its offset coll/debt and StETH gas comp, and close the trove.\n     */\n    function _getCappedOffsetVals(\n        uint _entireTroveDebt,\n        uint _entireTroveColl,\n        uint _price\n    ) internal pure returns (LiquidationValues memory singleLiquidation) {\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        uint cappedCollPortion = _entireTroveDebt.mul(MCR).div(_price);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            cappedCollPortion\n        );\n        singleLiquidation\n            .BaseFeeLMAGasCompensation = BaseFeeLMA_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion.sub(\n            singleLiquidation.collGasCompensation\n        );\n        singleLiquidation.collSurplus = _entireTroveColl.sub(cappedCollPortion);\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /*\n     * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\n     * starting from the one with the lowest collateral ratio in the system, and moving upwards\n     */\n    function liquidateTroves(uint _n) external {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            IBaseFeeLMAToken(address(0)),\n            IHOGStaking(address(0)),\n            sortedTroves,\n            ICollSurplusPool(address(0)),\n            address(0)\n        );\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.BaseFeeLMAInStabPool = stabilityPoolCached\n            .getTotalBaseFeeLMADeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\n                contractsCache,\n                vars.price,\n                vars.BaseFeeLMAInStabPool,\n                _n\n            );\n        } else {\n            // if !vars.recoveryModeAtStart\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(\n                contractsCache.activePool,\n                contractsCache.defaultPool,\n                vars.price,\n                vars.BaseFeeLMAInStabPool,\n                _n\n            );\n        }\n\n        require(\n            totals.totalDebtInSequence > 0,\n            \"TroveManager: nothing to liquidate\"\n        );\n\n        // Move liquidated StETH and BaseFeeLMA to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        _redistributeDebtAndColl(\n            contractsCache.activePool,\n            contractsCache.defaultPool,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute\n        );\n        if (totals.totalCollSurplus > 0) {\n            contractsCache.activePool.sendStETH(\n                address(collSurplusPool),\n                totals.totalCollSurplus\n            );\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(\n            contractsCache.activePool,\n            totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals\n            .totalCollInSequence\n            .sub(totals.totalCollGasCompensation)\n            .sub(totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalBaseFeeLMAGasCompensation\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            contractsCache.activePool,\n            msg.sender,\n            totals.totalBaseFeeLMAGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /*\n     * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n     */\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\n        ContractsCache memory _contractsCache,\n        uint _price,\n        uint _BaseFeeLMAInStabPool,\n        uint _n\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        vars.user = _contractsCache.sortedTroves.getLast();\n        address firstUser = _contractsCache.sortedTroves.getFirst();\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\n\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (\n                    vars.ICR >= MCR && vars.remainingBaseFeeLMAInStabPool == 0\n                ) {\n                    break;\n                }\n\n                uint TCR = LiquityMath._computeCR(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _contractsCache.activePool,\n                    _contractsCache.defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingBaseFeeLMAInStabPool,\n                    TCR,\n                    _price\n                );\n\n                // Update aggregate trackers\n                vars.remainingBaseFeeLMAInStabPool = vars\n                    .remainingBaseFeeLMAInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\n                    singleLiquidation.debtToOffset\n                );\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(singleLiquidation.collToSendToSP)\n                    .sub(singleLiquidation.collGasCompensation)\n                    .sub(singleLiquidation.collSurplus);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _contractsCache.activePool,\n                    _contractsCache.defaultPool,\n                    vars.user,\n                    vars.remainingBaseFeeLMAInStabPool\n                );\n\n                vars.remainingBaseFeeLMAInStabPool = vars\n                    .remainingBaseFeeLMAInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\n\n            vars.user = nextUser;\n        }\n    }\n\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _BaseFeeLMAInStabPool,\n        uint _n\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        ISortedTroves sortedTrovesCached = sortedTroves;\n\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\n\n        for (vars.i = 0; vars.i < _n; vars.i++) {\n            vars.user = sortedTrovesCached.getLast();\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingBaseFeeLMAInStabPool\n                );\n\n                vars.remainingBaseFeeLMAInStabPool = vars\n                    .remainingBaseFeeLMAInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\n        }\n    }\n\n    /*\n     * Attempt to liquidate a custom list of troves provided by the caller.\n     */\n    function batchLiquidateTroves(address[] memory _troveArray) public {\n        require(\n            _troveArray.length != 0,\n            \"TroveManager: Calldata address array must not be empty\"\n        );\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPool;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.price = priceFeed.fetchPrice();\n        vars.BaseFeeLMAInStabPool = stabilityPoolCached\n            .getTotalBaseFeeLMADeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.price,\n                vars.BaseFeeLMAInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.price,\n                vars.BaseFeeLMAInStabPool,\n                _troveArray\n            );\n        }\n\n        require(\n            totals.totalDebtInSequence > 0,\n            \"TroveManager: nothing to liquidate\"\n        );\n\n        // Move liquidated StETH and BaseFeeLMA to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        _redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute\n        );\n        if (totals.totalCollSurplus > 0) {\n            activePoolCached.sendStETH(\n                address(collSurplusPool),\n                totals.totalCollSurplus\n            );\n        }\n\n        // Update system snapshots\n        _updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl = totals\n            .totalCollInSequence\n            .sub(totals.totalCollGasCompensation)\n            .sub(totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalBaseFeeLMAGasCompensation\n        );\n\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            msg.sender,\n            totals.totalBaseFeeLMAGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /*\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\n     */\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _BaseFeeLMAInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        vars.entireSystemColl = getEntireSystemColl();\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            if (Troves[vars.user].status != Status.active) {\n                continue;\n            }\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (\n                    vars.ICR >= MCR && vars.remainingBaseFeeLMAInStabPool == 0\n                ) {\n                    continue;\n                }\n\n                uint TCR = LiquityMath._computeCR(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingBaseFeeLMAInStabPool,\n                    TCR,\n                    _price\n                );\n\n                // Update aggregate trackers\n                vars.remainingBaseFeeLMAInStabPool = vars\n                    .remainingBaseFeeLMAInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\n                    singleLiquidation.debtToOffset\n                );\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(singleLiquidation.collToSendToSP)\n                    .sub(singleLiquidation.collGasCompensation)\n                    .sub(singleLiquidation.collSurplus);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt,\n                    _price\n                );\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingBaseFeeLMAInStabPool\n                );\n                vars.remainingBaseFeeLMAInStabPool = vars\n                    .remainingBaseFeeLMAInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _price,\n        uint _BaseFeeLMAInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\n\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = getCurrentICR(vars.user, _price);\n\n            if (vars.ICR < MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingBaseFeeLMAInStabPool\n                );\n                vars.remainingBaseFeeLMAInStabPool = vars\n                    .remainingBaseFeeLMAInStabPool\n                    .sub(singleLiquidation.debtToOffset);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(\n                    totals,\n                    singleLiquidation\n                );\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        newTotals.totalCollGasCompensation = oldTotals\n            .totalCollGasCompensation\n            .add(singleLiquidation.collGasCompensation);\n        newTotals.totalBaseFeeLMAGasCompensation = oldTotals\n            .totalBaseFeeLMAGasCompensation\n            .add(singleLiquidation.BaseFeeLMAGasCompensation);\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence.add(\n            singleLiquidation.entireTroveColl\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP.add(\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals\n            .totalDebtToRedistribute\n            .add(singleLiquidation.debtToRedistribute);\n        newTotals.totalCollToRedistribute = oldTotals\n            .totalCollToRedistribute\n            .add(singleLiquidation.collToRedistribute);\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus.add(\n            singleLiquidation.collSurplus\n        );\n\n        return newTotals;\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint _BaseFeeLMA,\n        uint _StETH\n    ) internal {\n        if (_BaseFeeLMA > 0) {\n            baseFeeLMAToken.returnFromPool(\n                gasPoolAddress,\n                _liquidator,\n                _BaseFeeLMA\n            );\n        }\n\n        if (_StETH > 0) {\n            _activePool.sendStETH(_liquidator, _StETH);\n        }\n    }\n\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function _movePendingTroveRewardsToActivePool(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _BaseFeeLMA,\n        uint _StETH\n    ) internal {\n        _defaultPool.decreaseBaseFeeLMADebt(_BaseFeeLMA);\n        _activePool.increaseBaseFeeLMADebt(_BaseFeeLMA);\n        _defaultPool.sendStETHToActivePool(_StETH);\n    }\n\n    // --- Redemption functions ---\n\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for BaseFeeLMA up to _maxBaseFeeLMAamount\n    function _redeemCollateralFromTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint _maxBaseFeeLMAamount,\n        uint _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR\n    ) internal returns (SingleRedemptionValues memory singleRedemption) {\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\n        singleRedemption.BaseFeeLMALot = LiquityMath._min(\n            _maxBaseFeeLMAamount,\n            Troves[_borrower].debt.sub(BaseFeeLMA_GAS_COMPENSATION)\n        );\n\n        // Get the StETHLot of equivalent value in USD\n        singleRedemption.StETHLot = singleRedemption\n            .BaseFeeLMALot\n            .mul(DECIMAL_PRECISION)\n            .div(_price);\n\n        // Decrease the debt and collateral of the current Trove according to the BaseFeeLMA lot and corresponding StETH to send\n        uint newDebt = (Troves[_borrower].debt).sub(\n            singleRedemption.BaseFeeLMALot\n        );\n        uint newColl = (Troves[_borrower].coll).sub(singleRedemption.StETHLot);\n\n        if (newDebt == BaseFeeLMA_GAS_COMPENSATION) {\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\n            _removeStake(_borrower);\n            _closeTrove(_borrower, Status.closedByRedemption);\n            _redeemCloseTrove(\n                _contractsCache,\n                _borrower,\n                BaseFeeLMA_GAS_COMPENSATION,\n                newColl\n            );\n            emit TroveUpdated(\n                _borrower,\n                0,\n                0,\n                0,\n                TroveManagerOperation.redeemCollateral\n            );\n        } else {\n            uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n\n            /*\n             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\n             * certainly result in running out of gas.\n             *\n             * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n             */\n            if (\n                newNICR != _partialRedemptionHintNICR ||\n                _getNetDebt(newDebt) < MIN_NET_DEBT\n            ) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            _contractsCache.sortedTroves.reInsert(\n                _borrower,\n                newNICR,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint\n            );\n\n            Troves[_borrower].debt = newDebt;\n            Troves[_borrower].coll = newColl;\n            _updateStakeAndTotalStakes(_borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                newDebt,\n                newColl,\n                Troves[_borrower].stake,\n                TroveManagerOperation.redeemCollateral\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /*\n     * Called when a full redemption occurs, and closes the trove.\n     * The redeemer swaps (debt - liquidation reserve) BaseFeeLMA for (debt - liquidation reserve) worth of StETH, so the BaseFeeLMA liquidation reserve left corresponds to the remaining debt.\n     * In order to close the trove, the BaseFeeLMA liquidation reserve is burned, and the corresponding debt is removed from the active pool.\n     * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\n     * Any surplus StETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\n     */\n    function _redeemCloseTrove(\n        ContractsCache memory _contractsCache,\n        address _borrower,\n        uint _BaseFeeLMA,\n        uint _StETH\n    ) internal {\n        _contractsCache.baseFeeLMAToken.burn(gasPoolAddress, _BaseFeeLMA);\n        // Update Active Pool BaseFeeLMA, and send StETH to account\n        _contractsCache.activePool.decreaseBaseFeeLMADebt(_BaseFeeLMA);\n\n        // send StETH from Active Pool to CollSurplus Pool\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _StETH);\n        _contractsCache.activePool.sendStETH(\n            address(_contractsCache.collSurplusPool),\n            _StETH\n        );\n    }\n\n    function _isValidFirstRedemptionHint(\n        ISortedTroves _sortedTroves,\n        address _firstRedemptionHint,\n        uint _price\n    ) internal view returns (bool) {\n        if (\n            _firstRedemptionHint == address(0) ||\n            !_sortedTroves.contains(_firstRedemptionHint) ||\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\n        ) {\n            return false;\n        }\n\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\n        return\n            nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\n    }\n\n    /* Send _BaseFeeLMAamount BaseFeeLMA to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n     * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n     *\n     * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n     * splitting the total _amount in appropriate chunks and calling the function multiple times.\n     *\n     * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to\n     * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology\n     * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n     * costs can vary.\n     *\n     * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n     * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n     * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n     * in the sortedTroves list along with the ICR value that the hint was found for.\n     *\n     * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n     * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n     * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining BaseFeeLMA amount, which they can attempt\n     * to redeem later.\n     */\n    function redeemCollateral(\n        uint _BaseFeeLMAamount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFeePercentage\n    ) external {\n        ContractsCache memory contractsCache = ContractsCache(\n            activePool,\n            defaultPool,\n            baseFeeLMAToken,\n            hogStaking,\n            sortedTroves,\n            collSurplusPool,\n            gasPoolAddress\n        );\n        RedemptionTotals memory totals;\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n        _requireAfterBootstrapPeriod();\n        totals.price = priceFeed.fetchPrice();\n        _requireTCRoverMCR(totals.price);\n        _requireAmountGreaterThanZero(_BaseFeeLMAamount);\n        _requireBaseFeeLMABalanceCoversRedemption(\n            contractsCache.baseFeeLMAToken,\n            msg.sender,\n            _BaseFeeLMAamount\n        );\n\n        totals.totalBaseFeeLMASupplyAtStart = getEntireSystemDebt();\n        // Confirm redeemer's balance is less than total BaseFeeLMA supply\n        assert(\n            contractsCache.baseFeeLMAToken.balanceOf(msg.sender) <=\n                totals.totalBaseFeeLMASupplyAtStart\n        );\n\n        totals.remainingBaseFeeLMA = _BaseFeeLMAamount;\n        address currentBorrower;\n\n        if (\n            _isValidFirstRedemptionHint(\n                contractsCache.sortedTroves,\n                _firstRedemptionHint,\n                totals.price\n            )\n        ) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = contractsCache.sortedTroves.getLast();\n            // Find the first trove with ICR >= MCR\n            while (\n                currentBorrower != address(0) &&\n                getCurrentICR(currentBorrower, totals.price) < MCR\n            ) {\n                currentBorrower = contractsCache.sortedTroves.getPrev(\n                    currentBorrower\n                );\n            }\n        }\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of BaseFeeLMA is exchanged for collateral\n        if (_maxIterations == 0) {\n            // Previous implementation: _maxIterations = uint(-1);\n            // Updated since 8th pragma does not allow anymore\n            _maxIterations = type(uint).max;\n        }\n        while (\n            currentBorrower != address(0) &&\n            totals.remainingBaseFeeLMA > 0 &&\n            _maxIterations > 0\n        ) {\n            _maxIterations--;\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(\n                currentBorrower\n            );\n\n            _applyPendingRewards(\n                contractsCache.activePool,\n                contractsCache.defaultPool,\n                currentBorrower\n            );\n            SingleRedemptionValues\n                memory singleRedemption = _redeemCollateralFromTrove(\n                    contractsCache,\n                    currentBorrower,\n                    totals.remainingBaseFeeLMA,\n                    totals.price,\n                    _upperPartialRedemptionHint,\n                    _lowerPartialRedemptionHint,\n                    _partialRedemptionHintNICR\n                );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\n            totals.totalBaseFeeLMAToRedeem = totals.totalBaseFeeLMAToRedeem.add(\n                singleRedemption.BaseFeeLMALot\n            );\n            totals.totalStETHDrawn = totals.totalStETHDrawn.add(\n                singleRedemption.StETHLot\n            );\n\n            totals.remainingBaseFeeLMA = totals.remainingBaseFeeLMA.sub(\n                singleRedemption.BaseFeeLMALot\n            );\n            currentBorrower = nextUserToCheck;\n        }\n\n        require(\n            totals.totalStETHDrawn > 0,\n            \"TroveManager: Unable to redeem any amount\"\n        );\n\n        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.\n        // Use the saved total BaseFeeLMA supply value, from before it was reduced by the redemption.\n        _updateBaseRateFromRedemption(\n            totals.totalStETHDrawn,\n            totals.price,\n            totals.totalBaseFeeLMASupplyAtStart\n        );\n\n        // Calculate the StETH fee\n        totals.StETHFee = _getRedemptionFee(totals.totalStETHDrawn);\n\n        _requireUserAcceptsFee(\n            totals.StETHFee,\n            totals.totalStETHDrawn,\n            _maxFeePercentage\n        );\n        // Send the StETH fee to the HOG staking contract\n        contractsCache.activePool.sendStETH(\n            address(contractsCache.hogStaking),\n            totals.StETHFee\n        );\n        contractsCache.hogStaking.increaseF_StETH(totals.StETHFee);\n\n        totals.StETHToSendToRedeemer = totals.totalStETHDrawn.sub(\n            totals.StETHFee\n        );\n\n        emit Redemption(\n            _BaseFeeLMAamount,\n            totals.totalBaseFeeLMAToRedeem,\n            totals.totalStETHDrawn,\n            totals.StETHFee\n        );\n        // Burn the total BaseFeeLMA that is cancelled with debt, and send the redeemed StETH to msg.sender\n        contractsCache.baseFeeLMAToken.burn(\n            msg.sender,\n            totals.totalBaseFeeLMAToRedeem\n        );\n        // Update Active Pool BaseFeeLMA, and send StETH to account\n        contractsCache.activePool.decreaseBaseFeeLMADebt(\n            totals.totalBaseFeeLMAToRedeem\n        );\n        contractsCache.activePool.sendStETH(\n            msg.sender,\n            totals.StETHToSendToRedeemer\n        );\n    }\n\n    // --- Helper functions ---\n\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getNominalICR(address _borrower) public view returns (uint) {\n        (\n            uint currentStETH,\n            uint currentBaseFeeLMADebt\n        ) = _getCurrentTroveAmounts(_borrower);\n\n        uint NICR = LiquityMath._computeNominalCR(\n            currentStETH,\n            currentBaseFeeLMADebt\n        );\n        return NICR;\n    }\n\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(\n        address _borrower,\n        uint _price\n    ) public view returns (uint) {\n        (\n            uint currentStETH,\n            uint currentBaseFeeLMADebt\n        ) = _getCurrentTroveAmounts(_borrower);\n\n        uint ICR = LiquityMath._computeCR(\n            currentStETH,\n            currentBaseFeeLMADebt,\n            _price\n        );\n        return ICR;\n    }\n\n    function _getCurrentTroveAmounts(\n        address _borrower\n    ) internal view returns (uint, uint) {\n        uint pendingStETHReward = getPendingStETHReward(_borrower);\n        uint pendingBaseFeeLMADebtReward = getPendingBaseFeeLMADebtReward(\n            _borrower\n        );\n\n        uint currentStETH = Troves[_borrower].coll.add(pendingStETHReward);\n        uint currentBaseFeeLMADebt = Troves[_borrower].debt.add(\n            pendingBaseFeeLMADebtReward\n        );\n\n        return (currentStETH, currentBaseFeeLMADebt);\n    }\n\n    function applyPendingRewards(address _borrower) external {\n        _requireCallerIsBorrowerOperations();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower\n    ) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending rewards\n            uint pendingStETHReward = getPendingStETHReward(_borrower);\n            uint pendingBaseFeeLMADebtReward = getPendingBaseFeeLMADebtReward(\n                _borrower\n            );\n\n            // Apply pending rewards to trove's state\n            Troves[_borrower].coll = Troves[_borrower].coll.add(\n                pendingStETHReward\n            );\n            Troves[_borrower].debt = Troves[_borrower].debt.add(\n                pendingBaseFeeLMADebtReward\n            );\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                pendingBaseFeeLMADebtReward,\n                pendingStETHReward\n            );\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].coll,\n                Troves[_borrower].stake,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower's snapshots of L_StETH and L_BaseFeeLMADebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external {\n        _requireCallerIsBorrowerOperations();\n        return _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        rewardSnapshots[_borrower].StETH = L_StETH;\n        rewardSnapshots[_borrower].BaseFeeLMADebt = L_BaseFeeLMADebt;\n        emit TroveSnapshotsUpdated(L_StETH, L_BaseFeeLMADebt);\n    }\n\n    // Get the borrower's pending accumulated StETH reward, earned by their stake\n    function getPendingStETHReward(\n        address _borrower\n    ) public view returns (uint) {\n        uint snapshotStETH = rewardSnapshots[_borrower].StETH;\n        uint rewardPerUnitStaked = L_StETH.sub(snapshotStETH);\n\n        if (\n            rewardPerUnitStaked == 0 ||\n            Troves[_borrower].status != Status.active\n        ) {\n            return 0;\n        }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingStETHReward = stake.mul(rewardPerUnitStaked).div(\n            DECIMAL_PRECISION\n        );\n\n        return pendingStETHReward;\n    }\n\n    // Get the borrower's pending accumulated BaseFeeLMA reward, earned by their stake\n    function getPendingBaseFeeLMADebtReward(\n        address _borrower\n    ) public view returns (uint) {\n        uint snapshotBaseFeeLMADebt = rewardSnapshots[_borrower].BaseFeeLMADebt;\n        uint rewardPerUnitStaked = L_BaseFeeLMADebt.sub(snapshotBaseFeeLMADebt);\n\n        if (\n            rewardPerUnitStaked == 0 ||\n            Troves[_borrower].status != Status.active\n        ) {\n            return 0;\n        }\n\n        uint stake = Troves[_borrower].stake;\n\n        uint pendingBaseFeeLMADebtReward = stake.mul(rewardPerUnitStaked).div(\n            DECIMAL_PRECISION\n        );\n\n        return pendingBaseFeeLMADebtReward;\n    }\n\n    function hasPendingRewards(address _borrower) public view returns (bool) {\n        /*\n         * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n         * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n         * pending rewards\n         */\n        if (Troves[_borrower].status != Status.active) {\n            return false;\n        }\n\n        return (rewardSnapshots[_borrower].StETH < L_StETH);\n    }\n\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\n    function getEntireDebtAndColl(\n        address _borrower\n    )\n        public\n        view\n        returns (\n            uint debt,\n            uint coll,\n            uint pendingBaseFeeLMADebtReward,\n            uint pendingStETHReward\n        )\n    {\n        debt = Troves[_borrower].debt;\n        coll = Troves[_borrower].coll;\n\n        pendingBaseFeeLMADebtReward = getPendingBaseFeeLMADebtReward(_borrower);\n        pendingStETHReward = getPendingStETHReward(_borrower);\n\n        debt = debt.add(pendingBaseFeeLMADebtReward);\n        coll = coll.add(pendingStETHReward);\n    }\n\n    function removeStake(address _borrower) external {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        uint stake = Troves[_borrower].stake;\n        totalStakes = totalStakes.sub(stake);\n        Troves[_borrower].stake = 0;\n    }\n\n    function updateStakeAndTotalStakes(\n        address _borrower\n    ) external returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _updateStakeAndTotalStakes(_borrower);\n    }\n\n    // Update borrower's stake based on their latest collateral value\n    function _updateStakeAndTotalStakes(\n        address _borrower\n    ) internal returns (uint) {\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\n        uint oldStake = Troves[_borrower].stake;\n        Troves[_borrower].stake = newStake;\n\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\n        emit TotalStakesUpdated(totalStakes);\n\n        return newStake;\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot == 0) {\n            stake = _coll;\n        } else {\n            /*\n             * The following assert() holds true because:\n             * - The system always contains >= 1 trove\n             * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n             * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\n             */\n            assert(totalStakesSnapshot > 0);\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\n        }\n        return stake;\n    }\n\n    function _redistributeDebtAndColl(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint _debt,\n        uint _coll\n    ) internal {\n        if (_debt == 0) {\n            return;\n        }\n\n        /*\n         * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \"feedback\"\n         * error correction, to keep the cumulative error low in the running totals L_StETH and L_BaseFeeLMADebt:\n         *\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratios.\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store these errors for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint StETHNumerator = _coll.mul(DECIMAL_PRECISION).add(\n            lastStETHError_Redistribution\n        );\n        uint BaseFeeLMADebtNumerator = _debt.mul(DECIMAL_PRECISION).add(\n            lastBaseFeeLMADebtError_Redistribution\n        );\n\n        // Get the per-unit-staked terms\n        uint StETHRewardPerUnitStaked = StETHNumerator.div(totalStakes);\n        uint BaseFeeLMADebtRewardPerUnitStaked = BaseFeeLMADebtNumerator.div(\n            totalStakes\n        );\n\n        lastStETHError_Redistribution = StETHNumerator.sub(\n            StETHRewardPerUnitStaked.mul(totalStakes)\n        );\n        lastBaseFeeLMADebtError_Redistribution = BaseFeeLMADebtNumerator.sub(\n            BaseFeeLMADebtRewardPerUnitStaked.mul(totalStakes)\n        );\n\n        // Add per-unit-staked terms to the running totals\n        L_StETH = L_StETH.add(StETHRewardPerUnitStaked);\n        L_BaseFeeLMADebt = L_BaseFeeLMADebt.add(\n            BaseFeeLMADebtRewardPerUnitStaked\n        );\n\n        emit LTermsUpdated(L_StETH, L_BaseFeeLMADebt);\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseBaseFeeLMADebt(_debt);\n        _defaultPool.increaseBaseFeeLMADebt(_debt);\n        _activePool.sendStETH(address(_defaultPool), _coll);\n    }\n\n    function closeTrove(address _borrower) external {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        assert(\n            closedStatus != Status.nonExistent && closedStatus != Status.active\n        );\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].coll = 0;\n        Troves[_borrower].debt = 0;\n\n        rewardSnapshots[_borrower].StETH = 0;\n        rewardSnapshots[_borrower].BaseFeeLMADebt = 0;\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /*\n     * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n     * Used in a liquidation sequence.\n     *\n     * The calculation excludes a portion of collateral that is in the ActivePool:\n     *\n     * the total StETH gas compensation from the liquidation sequence\n     *\n     * The StETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n     */\n    function _updateSystemSnapshots_excludeCollRemainder(\n        IActivePool _activePool,\n        uint _collRemainder\n    ) internal {\n        totalStakesSnapshot = totalStakes;\n\n        uint activeColl = _activePool.getStETH();\n        uint liquidatedColl = defaultPool.getStETH();\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(\n            liquidatedColl\n        );\n\n        emit SystemSnapshotsUpdated(\n            totalStakesSnapshot,\n            totalCollateralSnapshot\n        );\n    }\n\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(\n        address _borrower\n    ) external returns (uint index) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(\n        address _borrower\n    ) internal returns (uint128 index) {\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum BaseFeeLMA\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 BaseFeeLMA dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\n\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n\n        return index;\n    }\n\n    /*\n     * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\n     * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\n     */\n    function _removeTroveOwner(\n        address _borrower,\n        uint TroveOwnersArrayLength\n    ) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // Its set in caller function `_closeTrove`\n        assert(\n            troveStatus != Status.nonExistent && troveStatus != Status.active\n        );\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        assert(index <= idxLast);\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR(uint _price) external view returns (uint) {\n        return _getTCR(_price);\n    }\n\n    function checkRecoveryMode(uint _price) external view returns (bool) {\n        return _checkRecoveryMode(_price);\n    }\n\n    // Check whether or not the system *would be* in Recovery Mode, given an StETH:USD price, and the entire system coll and debt.\n    function _checkPotentialRecoveryMode(\n        uint _entireSystemColl,\n        uint _entireSystemDebt,\n        uint _price\n    ) internal pure returns (bool) {\n        uint TCR = LiquityMath._computeCR(\n            _entireSystemColl,\n            _entireSystemDebt,\n            _price\n        );\n\n        return TCR < CCR;\n    }\n\n    // --- Redemption fee functions ---\n\n    /*\n     * This function has two impacts on the baseRate state variable:\n     * 1) decays the baseRate based on time passed since last redemption or BaseFeeLMA borrowing operation.\n     * then,\n     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply\n     */\n    function _updateBaseRateFromRedemption(\n        uint _StETHDrawn,\n        uint _price,\n        uint _totalBaseFeeLMASupply\n    ) internal returns (uint) {\n        uint decayedBaseRate = _calcDecayedBaseRate();\n\n        /* Convert the drawn StETH back to BaseFeeLMA at face value rate (1 BaseFeeLMA:1 USD), in order to get\n         * the fraction of total supply that was redeemed at face value. */\n        uint redeemedBaseFeeLMAFraction = _StETHDrawn.mul(_price).div(\n            _totalBaseFeeLMASupply\n        );\n\n        uint newBaseRate = decayedBaseRate.add(\n            redeemedBaseFeeLMAFraction.div(BETA)\n        );\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\n        assert(newBaseRate > 0); // Base rate is always non-zero after redemption\n\n        // Update the baseRate state variable\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n\n        _updateLastFeeOpTime();\n\n        return newBaseRate;\n    }\n\n    function getRedemptionRate() public view returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view returns (uint) {\n        return _calcRedemptionRate(_calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return\n            LiquityMath._min(\n                REDEMPTION_FEE_FLOOR.add(_baseRate),\n                DECIMAL_PRECISION // cap at a maximum of 100%\n            );\n    }\n\n    function _getRedemptionFee(uint _StETHDrawn) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _StETHDrawn);\n    }\n\n    function getRedemptionFeeWithDecay(\n        uint _StETHDrawn\n    ) external view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _StETHDrawn);\n    }\n\n    function _calcRedemptionFee(\n        uint _redemptionRate,\n        uint _StETHDrawn\n    ) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_StETHDrawn).div(\n            DECIMAL_PRECISION\n        );\n        require(\n            redemptionFee < _StETHDrawn,\n            \"TroveManager: Fee would eat up all returned collateral\"\n        );\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view returns (uint) {\n        return _calcBorrowingRate(_calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return\n            LiquityMath._min(\n                BORROWING_FEE_FLOOR.add(_baseRate),\n                MAX_BORROWING_FEE\n            );\n    }\n\n    function getBorrowingFee(\n        uint _BaseFeeLMADebt\n    ) external view returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _BaseFeeLMADebt);\n    }\n\n    function getBorrowingFeeWithDecay(\n        uint _BaseFeeLMADebt\n    ) external view returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _BaseFeeLMADebt);\n    }\n\n    function _calcBorrowingFee(\n        uint _borrowingRate,\n        uint _BaseFeeLMADebt\n    ) internal pure returns (uint) {\n        return _borrowingRate.mul(_BaseFeeLMADebt).div(DECIMAL_PRECISION);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or BaseFeeLMA borrowing operation.\n    function decayBaseRateFromBorrowing() external {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = _calcDecayedBaseRate();\n        assert(decayedBaseRate <= DECIMAL_PRECISION); // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function _calcDecayedBaseRate() internal view returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(\n            MINUTE_DECAY_FACTOR,\n            minutesPassed\n        );\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return\n            (block.timestamp.sub(lastFeeOperationTime)).div(\n                SECONDS_IN_ONE_MINUTE\n            );\n    }\n\n    // --- 'require' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"TroveManager: Caller is not the BorrowerOperations contract\"\n        );\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(\n            Troves[_borrower].status == Status.active,\n            \"TroveManager: Trove does not exist or is closed\"\n        );\n    }\n\n    function _requireBaseFeeLMABalanceCoversRedemption(\n        IBaseFeeLMAToken _baseFeeLMAToken,\n        address _redeemer,\n        uint _amount\n    ) internal view {\n        require(\n            _baseFeeLMAToken.balanceOf(_redeemer) >= _amount,\n            \"TroveManager: Requested redemption amount must be <= user's BaseFeeLMA token balance\"\n        );\n    }\n\n    function _requireMoreThanOneTroveInSystem(\n        uint TroveOwnersArrayLength\n    ) internal view {\n        require(\n            TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1,\n            \"TroveManager: Only one trove in the system\"\n        );\n    }\n\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\n        require(_amount > 0, \"TroveManager: Amount must be greater than zero\");\n    }\n\n    function _requireTCRoverMCR(uint _price) internal view {\n        require(\n            _getTCR(_price) >= MCR,\n            \"TroveManager: Cannot redeem when TCR < MCR\"\n        );\n    }\n\n    function _requireAfterBootstrapPeriod() internal view {\n        uint systemDeploymentTime = hogToken.getDeploymentStartTime();\n        require(\n            block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD),\n            \"TroveManager: Redemptions are not allowed during bootstrap phase\"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(\n        uint _maxFeePercentage\n    ) internal pure {\n        require(\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR &&\n                _maxFeePercentage <= DECIMAL_PRECISION,\n            \"Max fee percentage must be between 0.5% and 100%\"\n        );\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function getTroveStake(address _borrower) external view returns (uint) {\n        return Troves[_borrower].stake;\n    }\n\n    function getTroveDebt(address _borrower) external view returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    function getTroveColl(address _borrower) external view returns (uint) {\n        return Troves[_borrower].coll;\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function increaseTroveColl(\n        address _borrower,\n        uint _collIncrease\n    ) external returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function decreaseTroveColl(\n        address _borrower,\n        uint _collDecrease\n    ) external returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\n        Troves[_borrower].coll = newColl;\n        return newColl;\n    }\n\n    function increaseTroveDebt(\n        address _borrower,\n        uint _debtIncrease\n    ) external returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(\n        address _borrower,\n        uint _debtDecrease\n    ) external returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}