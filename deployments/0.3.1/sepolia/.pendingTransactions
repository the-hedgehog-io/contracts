{
  "0x58617f0fb60e5c1a79ece0634eb0a88428c7f51440efeeb648b74c2501343b72": {
    "name": "PriceFeed",
    "deployment": {
      "_format": "hh-sol-artifact-1",
      "contractName": "PriceFeed",
      "sourceName": "contracts/PriceFeed.sol",
      "abi": [
        {
          "inputs": [],
          "name": "MainOracleDisabled",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "_lastGoodPrice",
              "type": "uint256"
            }
          ],
          "name": "LastGoodPriceUpdated",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousOwner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "OwnershipTransferred",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "enum PriceFeed.Status",
              "name": "newStatus",
              "type": "uint8"
            }
          ],
          "name": "PriceFeedStatusChanged",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "DECIMAL_PRECISION",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "NAME",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "TARGET_DIGITS",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "TIMEOUT",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "backupOracle",
          "outputs": [
            {
              "internalType": "contract IBaseFeeOracle",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "fetchPrice",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "lastGoodPrice",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "mainOracle",
          "outputs": [
            {
              "internalType": "contract IBaseFeeOracle",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "owner",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "renounceOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_mainOracleAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_backupOracleAddress",
              "type": "address"
            }
          ],
          "name": "setAddresses",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "status",
          "outputs": [
            {
              "internalType": "enum PriceFeed.Status",
              "name": "",
              "type": "uint8"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "transferOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ],
      "bytecode": "0x608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6111a58061007e6000396000f3fe608060405234801561001057600080fd5b50600436106100d55760003560e01c806386800a961161008757806386800a96146101635780638da5cb5b1461016b57806390107afe1461017c578063a20baee61461018f578063a3f4df7e1461019e578063c8e07115146101d3578063f2fde38b146101e6578063f56f48f2146101f957600080fd5b80630490be83146100da5780630fdb11cf146100f65780631be5c92f146100fe578063200d2ed21461010657806345079cb414610120578063715018a61461012e578063836efd3114610138575b600080fd5b6100e360035481565b6040519081526020015b60405180910390f35b6100e3610201565b6100e3601281565b6004546101139060ff1681565b6040516100ed9190610e91565b6100e366b1a2bc2ec5000081565b61013661066a565b005b60025461014b906001600160a01b031681565b6040516001600160a01b0390911681526020016100ed565b6100e360b081565b6000546001600160a01b031661014b565b61013661018a366004610ed0565b61067e565b6100e3670de0b6b3a764000081565b6101c660405180604001604052806009815260200168141c9a58d95199595960ba1b81525081565b6040516100ed9190610f03565b60015461014b906001600160a01b031681565b6101366101f4366004610f51565b6107a3565b6100e3604581565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610257573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027b9190610f6c565b90506000610287610821565b9050600061029882604001516108c4565b905060006102a461097f565b905060006102b582604001516109f3565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103309190610f6c565b905060006004805460ff169081111561034b5761034b610e7b565b036104545761035a8585610a17565b156103bc5761036883610a3a565b15610385576103776002610a8a565b600354965050505050505090565b61038e83610ae7565b1561039d576103776001610a8a565b6103a76001610a8a565b6103b18382610b0b565b965050505050505090565b6103c585610ae7565b15610408576103d383610a3a565b156103e2576103776004610a8a565b6103ec6003610a8a565b6103f583610ae7565b156103a757600354965050505050505090565b610413858588610b2a565b156104325761042183610a3a565b806103685750610368838383610b2a565b61043b83610a3a565b1561044a5761044a6004610a8a565b6103b18587610b0b565b60016004805460ff169081111561046d5761046d610e7b565b036104dc5761047f8585858985610ba9565b1561048e5761044a6000610a8a565b61049783610a3a565b156104a6576103776002610a8a565b6104af83610ae7565b156104c257600354965050505050505090565b6104cd838383610b2a565b156103a7576103776002610a8a565b60026004805460ff16908111156104f5576104f5610e7b565b03610516576105078585858985610ba9565b156103775761044a6000610a8a565b60036004805460ff169081111561052f5761052f610e7b565b036105da5761053e8585610a17565b156105655761054c83610a3a565b1561055b576103776002610a8a565b6103ec6001610a8a565b61056e85610ae7565b1561058b5761057c83610a3a565b156103ec576103776004610a8a565b61059483610a3a565b156105a35761044a6004610a8a565b6105ac83610ae7565b156105bf57600354965050505050505090565b6105cb85848884610c07565b1561039d5761044a6000610a8a565b6004805460ff16818111156105f1576105f1610e7b565b03610661576106008585610a17565b1561060f576103776002610a8a565b61061885610ae7565b1561062b57600354965050505050505090565b6106388585858985610ba9565b156106475761044a6000610a8a565b610652858588610b2a565b1561044a576103776002610a8a565b50505050505090565b610672610c90565b61067c6000610cea565b565b610686610c90565b600180546001600160a01b038481166001600160a01b03199283161790925560028054928416929091169190911790556004805460ff1916905560006106ca610821565b905060006106db82604001516108c4565b90506106e78282610a17565b806106f657506106f682610ae7565b156107145760405163062a774160e51b815260040160405180910390fd5b61079482600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561076b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078f9190610f6c565b610b0b565b5061079d61066a565b50505050565b6107ab610c90565b6001600160a01b0381166108155760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61081e81610cea565b50565b610829610e5b565b600160009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b60015b61089f5790565b506001600160501b0390931660408501525082526001600160401b0316602082015290565b6108cc610e5b565b600180546001600160a01b031690639a6fc8f5906108ea908561100c565b6040516001600160e01b031960e084901b1681526001600160501b03909116600482015260240160a060405180830381865afa92505050801561094a575060408051601f3d908101601f1916820190925261094791810190610fa6565b60015b61095357919050565b506001600160501b0390931660408501525082526001600160401b03166020820152919050565b919050565b610987610e5b565b600260009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b6109fb610e5b565b6002546001600160a01b0316639a6fc8f56108ea60018561100c565b6000610a2283610d3a565b80610a315750610a3182610d3a565b90505b92915050565b600081602001516001600160401b031660001480610a6457504382602001516001600160401b0316115b15610a7157506001919050565b8151600003610a8257506001919050565b506000919050565b6004805482919060ff191660018383811115610aa857610aa8610e7b565b02179055507f5c57579a8214fe4f710c1c56fa829f045b9fa6d225a744225a30c32188064d4e81604051610adc9190610e91565b60405180910390a150565b6000604582602001516001600160401b031643610b049190611033565b1192915050565b600080610b1f84600001518460ff16610d9d565b9050610a3181610e00565b600080610b3e85600001518460ff16610d9d565b90506000610b5385600001518560ff16610d9d565b90506000610b618383610e35565b90506000610b6f8484610e4b565b90506000610b7d8383611033565b905060006103e8610b8f60b085611046565b610b99919061105d565b9091119998505050505050505050565b6000610bb484610a3a565b80610bc35750610bc384610ae7565b80610bd35750610bd38686610a17565b80610be25750610be286610ae7565b15610bef57506000610bfe565b610bfb86858585610c07565b90505b95945050505050565b600080610c1b86600001518560ff16610d9d565b90506000610c3086600001518560ff16610d9d565b90506000610c3e8284610e35565b90506000610c4c8385610e4b565b9050600082670de0b6b3a7640000610c648285611033565b610c6e9190611046565b610c78919061105d565b66b1a2bc2ec5000010159a9950505050505050505050565b6000546001600160a01b0316331461067c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161080c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600081604001516001600160501b0316600003610d5957506001919050565b60208201516001600160401b03161580610d7f57504382602001516001600160401b0316115b15610d8c57506001919050565b8151600012610a8257506001919050565b60008060128310610dcf57610db3601284611033565b610dbe90600a611163565b610dc8908561105d565b9050610a31565b6012831015610a3157610de3836012611033565b610dee90600a611163565b610df89085611046565b949350505050565b60038190556040518181527f4d29de21de555af78a62fc82dd4bc05e9ae5b0660a37f04729527e0f22780cd390602001610adc565b6000818310610e445781610a31565b5090919050565b600081831015610e445781610a31565b604080516060810182526000808252602082018190529181019190915290565b634e487b7160e01b600052602160045260246000fd5b6020810160058310610eb357634e487b7160e01b600052602160045260246000fd5b91905290565b80356001600160a01b038116811461097a57600080fd5b60008060408385031215610ee357600080fd5b610eec83610eb9565b9150610efa60208401610eb9565b90509250929050565b600060208083528351808285015260005b81811015610f3057858101830151858201604001528201610f14565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215610f6357600080fd5b610a3182610eb9565b600060208284031215610f7e57600080fd5b815160ff81168114610a3157600080fd5b80516001600160501b038116811461097a57600080fd5b600080600080600060a08688031215610fbe57600080fd5b610fc786610f8f565b9450602086015193506040860151925060608601519150610fea60808701610f8f565b90509295509295909350565b634e487b7160e01b600052601160045260246000fd5b6001600160501b0382811682821603908082111561102c5761102c610ff6565b5092915050565b81810381811115610a3457610a34610ff6565b8082028115828204841417610a3457610a34610ff6565b60008261107a57634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156110ba5781600019048211156110a0576110a0610ff6565b808516156110ad57918102915b93841c9390800290611084565b509250929050565b6000826110d157506001610a34565b816110de57506000610a34565b81600181146110f457600281146110fe5761111a565b6001915050610a34565b60ff84111561110f5761110f610ff6565b50506001821b610a34565b5060208310610133831016604e8410600b841016171561113d575081810a610a34565b611147838361107f565b806000190482111561115b5761115b610ff6565b029392505050565b6000610a3183836110c256fea264697066735822122001009bba11d0396e6ace2f028614dc7f72a0d919338e760a544930daa4b324f064736f6c63430008130033",
      "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100d55760003560e01c806386800a961161008757806386800a96146101635780638da5cb5b1461016b57806390107afe1461017c578063a20baee61461018f578063a3f4df7e1461019e578063c8e07115146101d3578063f2fde38b146101e6578063f56f48f2146101f957600080fd5b80630490be83146100da5780630fdb11cf146100f65780631be5c92f146100fe578063200d2ed21461010657806345079cb414610120578063715018a61461012e578063836efd3114610138575b600080fd5b6100e360035481565b6040519081526020015b60405180910390f35b6100e3610201565b6100e3601281565b6004546101139060ff1681565b6040516100ed9190610e91565b6100e366b1a2bc2ec5000081565b61013661066a565b005b60025461014b906001600160a01b031681565b6040516001600160a01b0390911681526020016100ed565b6100e360b081565b6000546001600160a01b031661014b565b61013661018a366004610ed0565b61067e565b6100e3670de0b6b3a764000081565b6101c660405180604001604052806009815260200168141c9a58d95199595960ba1b81525081565b6040516100ed9190610f03565b60015461014b906001600160a01b031681565b6101366101f4366004610f51565b6107a3565b6100e3604581565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610257573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027b9190610f6c565b90506000610287610821565b9050600061029882604001516108c4565b905060006102a461097f565b905060006102b582604001516109f3565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103309190610f6c565b905060006004805460ff169081111561034b5761034b610e7b565b036104545761035a8585610a17565b156103bc5761036883610a3a565b15610385576103776002610a8a565b600354965050505050505090565b61038e83610ae7565b1561039d576103776001610a8a565b6103a76001610a8a565b6103b18382610b0b565b965050505050505090565b6103c585610ae7565b15610408576103d383610a3a565b156103e2576103776004610a8a565b6103ec6003610a8a565b6103f583610ae7565b156103a757600354965050505050505090565b610413858588610b2a565b156104325761042183610a3a565b806103685750610368838383610b2a565b61043b83610a3a565b1561044a5761044a6004610a8a565b6103b18587610b0b565b60016004805460ff169081111561046d5761046d610e7b565b036104dc5761047f8585858985610ba9565b1561048e5761044a6000610a8a565b61049783610a3a565b156104a6576103776002610a8a565b6104af83610ae7565b156104c257600354965050505050505090565b6104cd838383610b2a565b156103a7576103776002610a8a565b60026004805460ff16908111156104f5576104f5610e7b565b03610516576105078585858985610ba9565b156103775761044a6000610a8a565b60036004805460ff169081111561052f5761052f610e7b565b036105da5761053e8585610a17565b156105655761054c83610a3a565b1561055b576103776002610a8a565b6103ec6001610a8a565b61056e85610ae7565b1561058b5761057c83610a3a565b156103ec576103776004610a8a565b61059483610a3a565b156105a35761044a6004610a8a565b6105ac83610ae7565b156105bf57600354965050505050505090565b6105cb85848884610c07565b1561039d5761044a6000610a8a565b6004805460ff16818111156105f1576105f1610e7b565b03610661576106008585610a17565b1561060f576103776002610a8a565b61061885610ae7565b1561062b57600354965050505050505090565b6106388585858985610ba9565b156106475761044a6000610a8a565b610652858588610b2a565b1561044a576103776002610a8a565b50505050505090565b610672610c90565b61067c6000610cea565b565b610686610c90565b600180546001600160a01b038481166001600160a01b03199283161790925560028054928416929091169190911790556004805460ff1916905560006106ca610821565b905060006106db82604001516108c4565b90506106e78282610a17565b806106f657506106f682610ae7565b156107145760405163062a774160e51b815260040160405180910390fd5b61079482600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561076b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078f9190610f6c565b610b0b565b5061079d61066a565b50505050565b6107ab610c90565b6001600160a01b0381166108155760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61081e81610cea565b50565b610829610e5b565b600160009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b60015b61089f5790565b506001600160501b0390931660408501525082526001600160401b0316602082015290565b6108cc610e5b565b600180546001600160a01b031690639a6fc8f5906108ea908561100c565b6040516001600160e01b031960e084901b1681526001600160501b03909116600482015260240160a060405180830381865afa92505050801561094a575060408051601f3d908101601f1916820190925261094791810190610fa6565b60015b61095357919050565b506001600160501b0390931660408501525082526001600160401b03166020820152919050565b919050565b610987610e5b565b600260009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b6109fb610e5b565b6002546001600160a01b0316639a6fc8f56108ea60018561100c565b6000610a2283610d3a565b80610a315750610a3182610d3a565b90505b92915050565b600081602001516001600160401b031660001480610a6457504382602001516001600160401b0316115b15610a7157506001919050565b8151600003610a8257506001919050565b506000919050565b6004805482919060ff191660018383811115610aa857610aa8610e7b565b02179055507f5c57579a8214fe4f710c1c56fa829f045b9fa6d225a744225a30c32188064d4e81604051610adc9190610e91565b60405180910390a150565b6000604582602001516001600160401b031643610b049190611033565b1192915050565b600080610b1f84600001518460ff16610d9d565b9050610a3181610e00565b600080610b3e85600001518460ff16610d9d565b90506000610b5385600001518560ff16610d9d565b90506000610b618383610e35565b90506000610b6f8484610e4b565b90506000610b7d8383611033565b905060006103e8610b8f60b085611046565b610b99919061105d565b9091119998505050505050505050565b6000610bb484610a3a565b80610bc35750610bc384610ae7565b80610bd35750610bd38686610a17565b80610be25750610be286610ae7565b15610bef57506000610bfe565b610bfb86858585610c07565b90505b95945050505050565b600080610c1b86600001518560ff16610d9d565b90506000610c3086600001518560ff16610d9d565b90506000610c3e8284610e35565b90506000610c4c8385610e4b565b9050600082670de0b6b3a7640000610c648285611033565b610c6e9190611046565b610c78919061105d565b66b1a2bc2ec5000010159a9950505050505050505050565b6000546001600160a01b0316331461067c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161080c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600081604001516001600160501b0316600003610d5957506001919050565b60208201516001600160401b03161580610d7f57504382602001516001600160401b0316115b15610d8c57506001919050565b8151600012610a8257506001919050565b60008060128310610dcf57610db3601284611033565b610dbe90600a611163565b610dc8908561105d565b9050610a31565b6012831015610a3157610de3836012611033565b610dee90600a611163565b610df89085611046565b949350505050565b60038190556040518181527f4d29de21de555af78a62fc82dd4bc05e9ae5b0660a37f04729527e0f22780cd390602001610adc565b6000818310610e445781610a31565b5090919050565b600081831015610e445781610a31565b604080516060810182526000808252602082018190529181019190915290565b634e487b7160e01b600052602160045260246000fd5b6020810160058310610eb357634e487b7160e01b600052602160045260246000fd5b91905290565b80356001600160a01b038116811461097a57600080fd5b60008060408385031215610ee357600080fd5b610eec83610eb9565b9150610efa60208401610eb9565b90509250929050565b600060208083528351808285015260005b81811015610f3057858101830151858201604001528201610f14565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215610f6357600080fd5b610a3182610eb9565b600060208284031215610f7e57600080fd5b815160ff81168114610a3157600080fd5b80516001600160501b038116811461097a57600080fd5b600080600080600060a08688031215610fbe57600080fd5b610fc786610f8f565b9450602086015193506040860151925060608601519150610fea60808701610f8f565b90509295509295909350565b634e487b7160e01b600052601160045260246000fd5b6001600160501b0382811682821603908082111561102c5761102c610ff6565b5092915050565b81810381811115610a3457610a34610ff6565b8082028115828204841417610a3457610a34610ff6565b60008261107a57634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156110ba5781600019048211156110a0576110a0610ff6565b808516156110ad57918102915b93841c9390800290611084565b509250929050565b6000826110d157506001610a34565b816110de57506000610a34565b81600181146110f457600281146110fe5761111a565b6001915050610a34565b60ff84111561110f5761110f610ff6565b50506001821b610a34565b5060208310610133831016604e8410600b841016171561113d575081810a610a34565b611147838361107f565b806000190482111561115b5761115b610ff6565b029392505050565b6000610a3183836110c256fea264697066735822122001009bba11d0396e6ace2f028614dc7f72a0d919338e760a544930daa4b324f064736f6c63430008130033",
      "linkReferences": {},
      "deployedLinkReferences": {},
      "devdoc": {
        "kind": "dev",
        "methods": {
          "owner()": {
            "details": "Returns the address of the current owner."
          },
          "renounceOwnership()": {
            "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
          },
          "transferOwnership(address)": {
            "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
          }
        },
        "version": 1
      },
      "evm": {
        "bytecode": {
          "functionDebugData": {
            "@_412": {
              "entryPoint": null,
              "id": 412,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@_msgSender_1333": {
              "entryPoint": null,
              "id": 1333,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@_transferOwnership_500": {
              "entryPoint": 31,
              "id": 500,
              "parameterSlots": 1,
              "returnSlots": 0
            }
          },
          "generatedSources": [],
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6111a58061007e6000396000f3fe608060405234801561001057600080fd5b50600436106100d55760003560e01c806386800a961161008757806386800a96146101635780638da5cb5b1461016b57806390107afe1461017c578063a20baee61461018f578063a3f4df7e1461019e578063c8e07115146101d3578063f2fde38b146101e6578063f56f48f2146101f957600080fd5b80630490be83146100da5780630fdb11cf146100f65780631be5c92f146100fe578063200d2ed21461010657806345079cb414610120578063715018a61461012e578063836efd3114610138575b600080fd5b6100e360035481565b6040519081526020015b60405180910390f35b6100e3610201565b6100e3601281565b6004546101139060ff1681565b6040516100ed9190610e91565b6100e366b1a2bc2ec5000081565b61013661066a565b005b60025461014b906001600160a01b031681565b6040516001600160a01b0390911681526020016100ed565b6100e360b081565b6000546001600160a01b031661014b565b61013661018a366004610ed0565b61067e565b6100e3670de0b6b3a764000081565b6101c660405180604001604052806009815260200168141c9a58d95199595960ba1b81525081565b6040516100ed9190610f03565b60015461014b906001600160a01b031681565b6101366101f4366004610f51565b6107a3565b6100e3604581565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610257573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027b9190610f6c565b90506000610287610821565b9050600061029882604001516108c4565b905060006102a461097f565b905060006102b582604001516109f3565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103309190610f6c565b905060006004805460ff169081111561034b5761034b610e7b565b036104545761035a8585610a17565b156103bc5761036883610a3a565b15610385576103776002610a8a565b600354965050505050505090565b61038e83610ae7565b1561039d576103776001610a8a565b6103a76001610a8a565b6103b18382610b0b565b965050505050505090565b6103c585610ae7565b15610408576103d383610a3a565b156103e2576103776004610a8a565b6103ec6003610a8a565b6103f583610ae7565b156103a757600354965050505050505090565b610413858588610b2a565b156104325761042183610a3a565b806103685750610368838383610b2a565b61043b83610a3a565b1561044a5761044a6004610a8a565b6103b18587610b0b565b60016004805460ff169081111561046d5761046d610e7b565b036104dc5761047f8585858985610ba9565b1561048e5761044a6000610a8a565b61049783610a3a565b156104a6576103776002610a8a565b6104af83610ae7565b156104c257600354965050505050505090565b6104cd838383610b2a565b156103a7576103776002610a8a565b60026004805460ff16908111156104f5576104f5610e7b565b03610516576105078585858985610ba9565b156103775761044a6000610a8a565b60036004805460ff169081111561052f5761052f610e7b565b036105da5761053e8585610a17565b156105655761054c83610a3a565b1561055b576103776002610a8a565b6103ec6001610a8a565b61056e85610ae7565b1561058b5761057c83610a3a565b156103ec576103776004610a8a565b61059483610a3a565b156105a35761044a6004610a8a565b6105ac83610ae7565b156105bf57600354965050505050505090565b6105cb85848884610c07565b1561039d5761044a6000610a8a565b6004805460ff16818111156105f1576105f1610e7b565b03610661576106008585610a17565b1561060f576103776002610a8a565b61061885610ae7565b1561062b57600354965050505050505090565b6106388585858985610ba9565b156106475761044a6000610a8a565b610652858588610b2a565b1561044a576103776002610a8a565b50505050505090565b610672610c90565b61067c6000610cea565b565b610686610c90565b600180546001600160a01b038481166001600160a01b03199283161790925560028054928416929091169190911790556004805460ff1916905560006106ca610821565b905060006106db82604001516108c4565b90506106e78282610a17565b806106f657506106f682610ae7565b156107145760405163062a774160e51b815260040160405180910390fd5b61079482600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561076b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078f9190610f6c565b610b0b565b5061079d61066a565b50505050565b6107ab610c90565b6001600160a01b0381166108155760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61081e81610cea565b50565b610829610e5b565b600160009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b60015b61089f5790565b506001600160501b0390931660408501525082526001600160401b0316602082015290565b6108cc610e5b565b600180546001600160a01b031690639a6fc8f5906108ea908561100c565b6040516001600160e01b031960e084901b1681526001600160501b03909116600482015260240160a060405180830381865afa92505050801561094a575060408051601f3d908101601f1916820190925261094791810190610fa6565b60015b61095357919050565b506001600160501b0390931660408501525082526001600160401b03166020820152919050565b919050565b610987610e5b565b600260009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b6109fb610e5b565b6002546001600160a01b0316639a6fc8f56108ea60018561100c565b6000610a2283610d3a565b80610a315750610a3182610d3a565b90505b92915050565b600081602001516001600160401b031660001480610a6457504382602001516001600160401b0316115b15610a7157506001919050565b8151600003610a8257506001919050565b506000919050565b6004805482919060ff191660018383811115610aa857610aa8610e7b565b02179055507f5c57579a8214fe4f710c1c56fa829f045b9fa6d225a744225a30c32188064d4e81604051610adc9190610e91565b60405180910390a150565b6000604582602001516001600160401b031643610b049190611033565b1192915050565b600080610b1f84600001518460ff16610d9d565b9050610a3181610e00565b600080610b3e85600001518460ff16610d9d565b90506000610b5385600001518560ff16610d9d565b90506000610b618383610e35565b90506000610b6f8484610e4b565b90506000610b7d8383611033565b905060006103e8610b8f60b085611046565b610b99919061105d565b9091119998505050505050505050565b6000610bb484610a3a565b80610bc35750610bc384610ae7565b80610bd35750610bd38686610a17565b80610be25750610be286610ae7565b15610bef57506000610bfe565b610bfb86858585610c07565b90505b95945050505050565b600080610c1b86600001518560ff16610d9d565b90506000610c3086600001518560ff16610d9d565b90506000610c3e8284610e35565b90506000610c4c8385610e4b565b9050600082670de0b6b3a7640000610c648285611033565b610c6e9190611046565b610c78919061105d565b66b1a2bc2ec5000010159a9950505050505050505050565b6000546001600160a01b0316331461067c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161080c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600081604001516001600160501b0316600003610d5957506001919050565b60208201516001600160401b03161580610d7f57504382602001516001600160401b0316115b15610d8c57506001919050565b8151600012610a8257506001919050565b60008060128310610dcf57610db3601284611033565b610dbe90600a611163565b610dc8908561105d565b9050610a31565b6012831015610a3157610de3836012611033565b610dee90600a611163565b610df89085611046565b949350505050565b60038190556040518181527f4d29de21de555af78a62fc82dd4bc05e9ae5b0660a37f04729527e0f22780cd390602001610adc565b6000818310610e445781610a31565b5090919050565b600081831015610e445781610a31565b604080516060810182526000808252602082018190529181019190915290565b634e487b7160e01b600052602160045260246000fd5b6020810160058310610eb357634e487b7160e01b600052602160045260246000fd5b91905290565b80356001600160a01b038116811461097a57600080fd5b60008060408385031215610ee357600080fd5b610eec83610eb9565b9150610efa60208401610eb9565b90509250929050565b600060208083528351808285015260005b81811015610f3057858101830151858201604001528201610f14565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215610f6357600080fd5b610a3182610eb9565b600060208284031215610f7e57600080fd5b815160ff81168114610a3157600080fd5b80516001600160501b038116811461097a57600080fd5b600080600080600060a08688031215610fbe57600080fd5b610fc786610f8f565b9450602086015193506040860151925060608601519150610fea60808701610f8f565b90509295509295909350565b634e487b7160e01b600052601160045260246000fd5b6001600160501b0382811682821603908082111561102c5761102c610ff6565b5092915050565b81810381811115610a3457610a34610ff6565b8082028115828204841417610a3457610a34610ff6565b60008261107a57634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156110ba5781600019048211156110a0576110a0610ff6565b808516156110ad57918102915b93841c9390800290611084565b509250929050565b6000826110d157506001610a34565b816110de57506000610a34565b81600181146110f457600281146110fe5761111a565b6001915050610a34565b60ff84111561110f5761110f610ff6565b50506001821b610a34565b5060208310610133831016604e8410600b841016171561113d575081810a610a34565b611147838361107f565b806000190482111561115b5761115b610ff6565b029392505050565b6000610a3183836110c256fea264697066735822122001009bba11d0396e6ace2f028614dc7f72a0d919338e760a544930daa4b324f064736f6c63430008130033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x1A CALLER PUSH2 0x1F JUMP JUMPDEST PUSH2 0x6F JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT DUP4 AND DUP2 OR DUP5 SSTORE PUSH1 0x40 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP3 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH2 0x11A5 DUP1 PUSH2 0x7E PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0xD5 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x86800A96 GT PUSH2 0x87 JUMPI DUP1 PUSH4 0x86800A96 EQ PUSH2 0x163 JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x16B JUMPI DUP1 PUSH4 0x90107AFE EQ PUSH2 0x17C JUMPI DUP1 PUSH4 0xA20BAEE6 EQ PUSH2 0x18F JUMPI DUP1 PUSH4 0xA3F4DF7E EQ PUSH2 0x19E JUMPI DUP1 PUSH4 0xC8E07115 EQ PUSH2 0x1D3 JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0x1E6 JUMPI DUP1 PUSH4 0xF56F48F2 EQ PUSH2 0x1F9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x490BE83 EQ PUSH2 0xDA JUMPI DUP1 PUSH4 0xFDB11CF EQ PUSH2 0xF6 JUMPI DUP1 PUSH4 0x1BE5C92F EQ PUSH2 0xFE JUMPI DUP1 PUSH4 0x200D2ED2 EQ PUSH2 0x106 JUMPI DUP1 PUSH4 0x45079CB4 EQ PUSH2 0x120 JUMPI DUP1 PUSH4 0x715018A6 EQ PUSH2 0x12E JUMPI DUP1 PUSH4 0x836EFD31 EQ PUSH2 0x138 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xE3 PUSH1 0x3 SLOAD DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xE3 PUSH2 0x201 JUMP JUMPDEST PUSH2 0xE3 PUSH1 0x12 DUP2 JUMP JUMPDEST PUSH1 0x4 SLOAD PUSH2 0x113 SWAP1 PUSH1 0xFF AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xED SWAP2 SWAP1 PUSH2 0xE91 JUMP JUMPDEST PUSH2 0xE3 PUSH7 0xB1A2BC2EC50000 DUP2 JUMP JUMPDEST PUSH2 0x136 PUSH2 0x66A JUMP JUMPDEST STOP JUMPDEST PUSH1 0x2 SLOAD PUSH2 0x14B SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xED JUMP JUMPDEST PUSH2 0xE3 PUSH1 0xB0 DUP2 JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH2 0x14B JUMP JUMPDEST PUSH2 0x136 PUSH2 0x18A CALLDATASIZE PUSH1 0x4 PUSH2 0xED0 JUMP JUMPDEST PUSH2 0x67E JUMP JUMPDEST PUSH2 0xE3 PUSH8 0xDE0B6B3A7640000 DUP2 JUMP JUMPDEST PUSH2 0x1C6 PUSH1 0x40 MLOAD DUP1 PUSH1 0x40 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x9 DUP2 MSTORE PUSH1 0x20 ADD PUSH9 0x141C9A58D951995959 PUSH1 0xBA SHL DUP2 MSTORE POP DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xED SWAP2 SWAP1 PUSH2 0xF03 JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH2 0x14B SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH2 0x136 PUSH2 0x1F4 CALLDATASIZE PUSH1 0x4 PUSH2 0xF51 JUMP JUMPDEST PUSH2 0x7A3 JUMP JUMPDEST PUSH2 0xE3 PUSH1 0x45 DUP2 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x313CE567 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x257 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x27B SWAP2 SWAP1 PUSH2 0xF6C JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x287 PUSH2 0x821 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x298 DUP3 PUSH1 0x40 ADD MLOAD PUSH2 0x8C4 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x2A4 PUSH2 0x97F JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x2B5 DUP3 PUSH1 0x40 ADD MLOAD PUSH2 0x9F3 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x313CE567 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x30C JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x330 SWAP2 SWAP1 PUSH2 0xF6C JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x34B JUMPI PUSH2 0x34B PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x454 JUMPI PUSH2 0x35A DUP6 DUP6 PUSH2 0xA17 JUMP JUMPDEST ISZERO PUSH2 0x3BC JUMPI PUSH2 0x368 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x385 JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x38E DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x39D JUMPI PUSH2 0x377 PUSH1 0x1 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3A7 PUSH1 0x1 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3B1 DUP4 DUP3 PUSH2 0xB0B JUMP JUMPDEST SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x3C5 DUP6 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x408 JUMPI PUSH2 0x3D3 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x3E2 JUMPI PUSH2 0x377 PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3EC PUSH1 0x3 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3F5 DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x3A7 JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x413 DUP6 DUP6 DUP9 PUSH2 0xB2A JUMP JUMPDEST ISZERO PUSH2 0x432 JUMPI PUSH2 0x421 DUP4 PUSH2 0xA3A JUMP JUMPDEST DUP1 PUSH2 0x368 JUMPI POP PUSH2 0x368 DUP4 DUP4 DUP4 PUSH2 0xB2A JUMP JUMPDEST PUSH2 0x43B DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x44A JUMPI PUSH2 0x44A PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3B1 DUP6 DUP8 PUSH2 0xB0B JUMP JUMPDEST PUSH1 0x1 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x46D JUMPI PUSH2 0x46D PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x4DC JUMPI PUSH2 0x47F DUP6 DUP6 DUP6 DUP10 DUP6 PUSH2 0xBA9 JUMP JUMPDEST ISZERO PUSH2 0x48E JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x497 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x4A6 JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x4AF DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x4C2 JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x4CD DUP4 DUP4 DUP4 PUSH2 0xB2A JUMP JUMPDEST ISZERO PUSH2 0x3A7 JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x2 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x4F5 JUMPI PUSH2 0x4F5 PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x516 JUMPI PUSH2 0x507 DUP6 DUP6 DUP6 DUP10 DUP6 PUSH2 0xBA9 JUMP JUMPDEST ISZERO PUSH2 0x377 JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x3 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x52F JUMPI PUSH2 0x52F PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x5DA JUMPI PUSH2 0x53E DUP6 DUP6 PUSH2 0xA17 JUMP JUMPDEST ISZERO PUSH2 0x565 JUMPI PUSH2 0x54C DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x55B JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3EC PUSH1 0x1 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x56E DUP6 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x58B JUMPI PUSH2 0x57C DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x3EC JUMPI PUSH2 0x377 PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x594 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x5A3 JUMPI PUSH2 0x44A PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x5AC DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x5BF JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x5CB DUP6 DUP5 DUP9 DUP5 PUSH2 0xC07 JUMP JUMPDEST ISZERO PUSH2 0x39D JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND DUP2 DUP2 GT ISZERO PUSH2 0x5F1 JUMPI PUSH2 0x5F1 PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x661 JUMPI PUSH2 0x600 DUP6 DUP6 PUSH2 0xA17 JUMP JUMPDEST ISZERO PUSH2 0x60F JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x618 DUP6 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x62B JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x638 DUP6 DUP6 DUP6 DUP10 DUP6 PUSH2 0xBA9 JUMP JUMPDEST ISZERO PUSH2 0x647 JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x652 DUP6 DUP6 DUP9 PUSH2 0xB2A JUMP JUMPDEST ISZERO PUSH2 0x44A JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x672 PUSH2 0xC90 JUMP JUMPDEST PUSH2 0x67C PUSH1 0x0 PUSH2 0xCEA JUMP JUMPDEST JUMP JUMPDEST PUSH2 0x686 PUSH2 0xC90 JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP3 DUP4 AND OR SWAP1 SWAP3 SSTORE PUSH1 0x2 DUP1 SLOAD SWAP3 DUP5 AND SWAP3 SWAP1 SWAP2 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF NOT AND SWAP1 SSTORE PUSH1 0x0 PUSH2 0x6CA PUSH2 0x821 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x6DB DUP3 PUSH1 0x40 ADD MLOAD PUSH2 0x8C4 JUMP JUMPDEST SWAP1 POP PUSH2 0x6E7 DUP3 DUP3 PUSH2 0xA17 JUMP JUMPDEST DUP1 PUSH2 0x6F6 JUMPI POP PUSH2 0x6F6 DUP3 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x714 JUMPI PUSH1 0x40 MLOAD PUSH4 0x62A7741 PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x794 DUP3 PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x313CE567 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x76B JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x78F SWAP2 SWAP1 PUSH2 0xF6C JUMP JUMPDEST PUSH2 0xB0B JUMP JUMPDEST POP PUSH2 0x79D PUSH2 0x66A JUMP JUMPDEST POP POP POP POP JUMP JUMPDEST PUSH2 0x7AB PUSH2 0xC90 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND PUSH2 0x815 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x26 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4F776E61626C653A206E6577206F776E657220697320746865207A65726F2061 PUSH1 0x44 DUP3 ADD MSTORE PUSH6 0x646472657373 PUSH1 0xD0 SHL PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x81E DUP2 PUSH2 0xCEA JUMP JUMPDEST POP JUMP JUMPDEST PUSH2 0x829 PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xFEAF968C PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0xA0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL SWAP3 POP POP POP DUP1 ISZERO PUSH2 0x898 JUMPI POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x1F RETURNDATASIZE SWAP1 DUP2 ADD PUSH1 0x1F NOT AND DUP3 ADD SWAP1 SWAP3 MSTORE PUSH2 0x895 SWAP2 DUP2 ADD SWAP1 PUSH2 0xFA6 JUMP JUMPDEST PUSH1 0x1 JUMPDEST PUSH2 0x89F JUMPI SWAP1 JUMP JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB SWAP1 SWAP4 AND PUSH1 0x40 DUP6 ADD MSTORE POP DUP3 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST PUSH2 0x8CC PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 PUSH4 0x9A6FC8F5 SWAP1 PUSH2 0x8EA SWAP1 DUP6 PUSH2 0x100C JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT PUSH1 0xE0 DUP5 SWAP1 SHL AND DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB SWAP1 SWAP2 AND PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 ADD PUSH1 0xA0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL SWAP3 POP POP POP DUP1 ISZERO PUSH2 0x94A JUMPI POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x1F RETURNDATASIZE SWAP1 DUP2 ADD PUSH1 0x1F NOT AND DUP3 ADD SWAP1 SWAP3 MSTORE PUSH2 0x947 SWAP2 DUP2 ADD SWAP1 PUSH2 0xFA6 JUMP JUMPDEST PUSH1 0x1 JUMPDEST PUSH2 0x953 JUMPI SWAP2 SWAP1 POP JUMP JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB SWAP1 SWAP4 AND PUSH1 0x40 DUP6 ADD MSTORE POP DUP3 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND PUSH1 0x20 DUP3 ADD MSTORE SWAP2 SWAP1 POP JUMP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0x987 PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xFEAF968C PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0xA0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL SWAP3 POP POP POP DUP1 ISZERO PUSH2 0x898 JUMPI POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x1F RETURNDATASIZE SWAP1 DUP2 ADD PUSH1 0x1F NOT AND DUP3 ADD SWAP1 SWAP3 MSTORE PUSH2 0x895 SWAP2 DUP2 ADD SWAP1 PUSH2 0xFA6 JUMP JUMPDEST PUSH2 0x9FB PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x2 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x9A6FC8F5 PUSH2 0x8EA PUSH1 0x1 DUP6 PUSH2 0x100C JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA22 DUP4 PUSH2 0xD3A JUMP JUMPDEST DUP1 PUSH2 0xA31 JUMPI POP PUSH2 0xA31 DUP3 PUSH2 0xD3A JUMP JUMPDEST SWAP1 POP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND PUSH1 0x0 EQ DUP1 PUSH2 0xA64 JUMPI POP NUMBER DUP3 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND GT JUMPDEST ISZERO PUSH2 0xA71 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST DUP2 MLOAD PUSH1 0x0 SUB PUSH2 0xA82 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST POP PUSH1 0x0 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x4 DUP1 SLOAD DUP3 SWAP2 SWAP1 PUSH1 0xFF NOT AND PUSH1 0x1 DUP4 DUP4 DUP2 GT ISZERO PUSH2 0xAA8 JUMPI PUSH2 0xAA8 PUSH2 0xE7B JUMP JUMPDEST MUL OR SWAP1 SSTORE POP PUSH32 0x5C57579A8214FE4F710C1C56FA829F045B9FA6D225A744225A30C32188064D4E DUP2 PUSH1 0x40 MLOAD PUSH2 0xADC SWAP2 SWAP1 PUSH2 0xE91 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x45 DUP3 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND NUMBER PUSH2 0xB04 SWAP2 SWAP1 PUSH2 0x1033 JUMP JUMPDEST GT SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xB1F DUP5 PUSH1 0x0 ADD MLOAD DUP5 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH2 0xA31 DUP2 PUSH2 0xE00 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xB3E DUP6 PUSH1 0x0 ADD MLOAD DUP5 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB53 DUP6 PUSH1 0x0 ADD MLOAD DUP6 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB61 DUP4 DUP4 PUSH2 0xE35 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB6F DUP5 DUP5 PUSH2 0xE4B JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB7D DUP4 DUP4 PUSH2 0x1033 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x3E8 PUSH2 0xB8F PUSH1 0xB0 DUP6 PUSH2 0x1046 JUMP JUMPDEST PUSH2 0xB99 SWAP2 SWAP1 PUSH2 0x105D JUMP JUMPDEST SWAP1 SWAP2 GT SWAP10 SWAP9 POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xBB4 DUP5 PUSH2 0xA3A JUMP JUMPDEST DUP1 PUSH2 0xBC3 JUMPI POP PUSH2 0xBC3 DUP5 PUSH2 0xAE7 JUMP JUMPDEST DUP1 PUSH2 0xBD3 JUMPI POP PUSH2 0xBD3 DUP7 DUP7 PUSH2 0xA17 JUMP JUMPDEST DUP1 PUSH2 0xBE2 JUMPI POP PUSH2 0xBE2 DUP7 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0xBEF JUMPI POP PUSH1 0x0 PUSH2 0xBFE JUMP JUMPDEST PUSH2 0xBFB DUP7 DUP6 DUP6 DUP6 PUSH2 0xC07 JUMP JUMPDEST SWAP1 POP JUMPDEST SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xC1B DUP7 PUSH1 0x0 ADD MLOAD DUP6 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xC30 DUP7 PUSH1 0x0 ADD MLOAD DUP6 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xC3E DUP3 DUP5 PUSH2 0xE35 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xC4C DUP4 DUP6 PUSH2 0xE4B JUMP JUMPDEST SWAP1 POP PUSH1 0x0 DUP3 PUSH8 0xDE0B6B3A7640000 PUSH2 0xC64 DUP3 DUP6 PUSH2 0x1033 JUMP JUMPDEST PUSH2 0xC6E SWAP2 SWAP1 PUSH2 0x1046 JUMP JUMPDEST PUSH2 0xC78 SWAP2 SWAP1 PUSH2 0x105D JUMP JUMPDEST PUSH7 0xB1A2BC2EC50000 LT ISZERO SWAP11 SWAP10 POP POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x67C JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD DUP2 SWAP1 MSTORE PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4F776E61626C653A2063616C6C6572206973206E6F7420746865206F776E6572 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x80C JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT DUP4 AND DUP2 OR DUP5 SSTORE PUSH1 0x40 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP3 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x40 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB AND PUSH1 0x0 SUB PUSH2 0xD59 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x20 DUP3 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND ISZERO DUP1 PUSH2 0xD7F JUMPI POP NUMBER DUP3 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND GT JUMPDEST ISZERO PUSH2 0xD8C JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST DUP2 MLOAD PUSH1 0x0 SLT PUSH2 0xA82 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x12 DUP4 LT PUSH2 0xDCF JUMPI PUSH2 0xDB3 PUSH1 0x12 DUP5 PUSH2 0x1033 JUMP JUMPDEST PUSH2 0xDBE SWAP1 PUSH1 0xA PUSH2 0x1163 JUMP JUMPDEST PUSH2 0xDC8 SWAP1 DUP6 PUSH2 0x105D JUMP JUMPDEST SWAP1 POP PUSH2 0xA31 JUMP JUMPDEST PUSH1 0x12 DUP4 LT ISZERO PUSH2 0xA31 JUMPI PUSH2 0xDE3 DUP4 PUSH1 0x12 PUSH2 0x1033 JUMP JUMPDEST PUSH2 0xDEE SWAP1 PUSH1 0xA PUSH2 0x1163 JUMP JUMPDEST PUSH2 0xDF8 SWAP1 DUP6 PUSH2 0x1046 JUMP JUMPDEST SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x3 DUP2 SWAP1 SSTORE PUSH1 0x40 MLOAD DUP2 DUP2 MSTORE PUSH32 0x4D29DE21DE555AF78A62FC82DD4BC05E9AE5B0660A37F04729527E0F22780CD3 SWAP1 PUSH1 0x20 ADD PUSH2 0xADC JUMP JUMPDEST PUSH1 0x0 DUP2 DUP4 LT PUSH2 0xE44 JUMPI DUP2 PUSH2 0xA31 JUMP JUMPDEST POP SWAP1 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 DUP4 LT ISZERO PUSH2 0xE44 JUMPI DUP2 PUSH2 0xA31 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x60 DUP2 ADD DUP3 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD DUP2 SWAP1 MSTORE SWAP2 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x21 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x20 DUP2 ADD PUSH1 0x5 DUP4 LT PUSH2 0xEB3 JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x21 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST SWAP2 SWAP1 MSTORE SWAP1 JUMP JUMPDEST DUP1 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x97A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xEE3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xEEC DUP4 PUSH2 0xEB9 JUMP JUMPDEST SWAP2 POP PUSH2 0xEFA PUSH1 0x20 DUP5 ADD PUSH2 0xEB9 JUMP JUMPDEST SWAP1 POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP1 DUP4 MSTORE DUP4 MLOAD DUP1 DUP3 DUP6 ADD MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0xF30 JUMPI DUP6 DUP2 ADD DUP4 ADD MLOAD DUP6 DUP3 ADD PUSH1 0x40 ADD MSTORE DUP3 ADD PUSH2 0xF14 JUMP JUMPDEST POP PUSH1 0x0 PUSH1 0x40 DUP3 DUP7 ADD ADD MSTORE PUSH1 0x40 PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND DUP6 ADD ADD SWAP3 POP POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xF63 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xA31 DUP3 PUSH2 0xEB9 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xF7E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD PUSH1 0xFF DUP2 AND DUP2 EQ PUSH2 0xA31 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x97A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0xA0 DUP7 DUP9 SUB SLT ISZERO PUSH2 0xFBE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xFC7 DUP7 PUSH2 0xF8F JUMP JUMPDEST SWAP5 POP PUSH1 0x20 DUP7 ADD MLOAD SWAP4 POP PUSH1 0x40 DUP7 ADD MLOAD SWAP3 POP PUSH1 0x60 DUP7 ADD MLOAD SWAP2 POP PUSH2 0xFEA PUSH1 0x80 DUP8 ADD PUSH2 0xF8F JUMP JUMPDEST SWAP1 POP SWAP3 SWAP6 POP SWAP3 SWAP6 SWAP1 SWAP4 POP JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB DUP3 DUP2 AND DUP3 DUP3 AND SUB SWAP1 DUP1 DUP3 GT ISZERO PUSH2 0x102C JUMPI PUSH2 0x102C PUSH2 0xFF6 JUMP JUMPDEST POP SWAP3 SWAP2 POP POP JUMP JUMPDEST DUP2 DUP2 SUB DUP2 DUP2 GT ISZERO PUSH2 0xA34 JUMPI PUSH2 0xA34 PUSH2 0xFF6 JUMP JUMPDEST DUP1 DUP3 MUL DUP2 ISZERO DUP3 DUP3 DIV DUP5 EQ OR PUSH2 0xA34 JUMPI PUSH2 0xA34 PUSH2 0xFF6 JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH2 0x107A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x12 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST POP DIV SWAP1 JUMP JUMPDEST PUSH1 0x1 DUP2 DUP2 JUMPDEST DUP1 DUP6 GT ISZERO PUSH2 0x10BA JUMPI DUP2 PUSH1 0x0 NOT DIV DUP3 GT ISZERO PUSH2 0x10A0 JUMPI PUSH2 0x10A0 PUSH2 0xFF6 JUMP JUMPDEST DUP1 DUP6 AND ISZERO PUSH2 0x10AD JUMPI SWAP2 DUP2 MUL SWAP2 JUMPDEST SWAP4 DUP5 SHR SWAP4 SWAP1 DUP1 MUL SWAP1 PUSH2 0x1084 JUMP JUMPDEST POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH2 0x10D1 JUMPI POP PUSH1 0x1 PUSH2 0xA34 JUMP JUMPDEST DUP2 PUSH2 0x10DE JUMPI POP PUSH1 0x0 PUSH2 0xA34 JUMP JUMPDEST DUP2 PUSH1 0x1 DUP2 EQ PUSH2 0x10F4 JUMPI PUSH1 0x2 DUP2 EQ PUSH2 0x10FE JUMPI PUSH2 0x111A JUMP JUMPDEST PUSH1 0x1 SWAP2 POP POP PUSH2 0xA34 JUMP JUMPDEST PUSH1 0xFF DUP5 GT ISZERO PUSH2 0x110F JUMPI PUSH2 0x110F PUSH2 0xFF6 JUMP JUMPDEST POP POP PUSH1 0x1 DUP3 SHL PUSH2 0xA34 JUMP JUMPDEST POP PUSH1 0x20 DUP4 LT PUSH2 0x133 DUP4 LT AND PUSH1 0x4E DUP5 LT PUSH1 0xB DUP5 LT AND OR ISZERO PUSH2 0x113D JUMPI POP DUP2 DUP2 EXP PUSH2 0xA34 JUMP JUMPDEST PUSH2 0x1147 DUP4 DUP4 PUSH2 0x107F JUMP JUMPDEST DUP1 PUSH1 0x0 NOT DIV DUP3 GT ISZERO PUSH2 0x115B JUMPI PUSH2 0x115B PUSH2 0xFF6 JUMP JUMPDEST MUL SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA31 DUP4 DUP4 PUSH2 0x10C2 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 ADD STOP SWAP12 0xBA GT 0xD0 CODECOPY PUSH15 0x6ACE2F028614DC7F72A0D919338E76 EXP SLOAD 0x49 ADDRESS 0xDA LOG4 0xB3 0x24 CREATE PUSH5 0x736F6C6343 STOP ADDMOD SGT STOP CALLER ",
          "sourceMap": "744:25942:18:-:0;;;;;;;;;;;;-1:-1:-1;936:32:2;719:10:7;936:18:2;:32::i;:::-;744:25942:18;;2426:187:2;2499:16;2518:6;;-1:-1:-1;;;;;2534:17:2;;;-1:-1:-1;;;;;;2534:17:2;;;;;;2566:40;;2518:6;;;;;;;2566:40;;2499:16;2566:40;2489:124;2426:187;:::o;744:25942:18:-;;;;;;;"
        },
        "deployedBytecode": {
          "functionDebugData": {
            "@DECIMAL_PRECISION_14146": {
              "entryPoint": null,
              "id": 14146,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND_5908": {
              "entryPoint": null,
              "id": 5908,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES_5911": {
              "entryPoint": null,
              "id": 5911,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@NAME_5893": {
              "entryPoint": null,
              "id": 5893,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@TARGET_DIGITS_5902": {
              "entryPoint": null,
              "id": 5902,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@TIMEOUT_5905": {
              "entryPoint": null,
              "id": 5905,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@_backupIsFrozen_6676": {
              "entryPoint": 2791,
              "id": 6676,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@_backupOracleIsBroken_6659": {
              "entryPoint": 2618,
              "id": 6659,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@_badMainOracleResponse_6537": {
              "entryPoint": 3386,
              "id": 6537,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@_bothOraclesLiveAndUnbrokenAndSimilarPrice_6722": {
              "entryPoint": 2985,
              "id": 6722,
              "parameterSlots": 5,
              "returnSlots": 1
            },
            "@_bothOraclesSimilarPrice_6792": {
              "entryPoint": 3079,
              "id": 6792,
              "parameterSlots": 4,
              "returnSlots": 1
            },
            "@_changeStatus_6856": {
              "entryPoint": 2698,
              "id": 6856,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@_checkOwner_443": {
              "entryPoint": 3216,
              "id": 443,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@_getCurrentBackupResponse_7000": {
              "entryPoint": 2431,
              "id": 7000,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@_getCurrentMainOracleResponse_6949": {
              "entryPoint": 2081,
              "id": 6949,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@_getPrevBackupOracleResponse_7112": {
              "entryPoint": 2547,
              "id": 7112,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@_getPrevOracleResponse_7056": {
              "entryPoint": 2244,
              "id": 7056,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@_mainOracleIsBroken_6496": {
              "entryPoint": 2583,
              "id": 6496,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@_mainOracleIsFrozen_6555": {
              "entryPoint": null,
              "id": 6555,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@_max_14483": {
              "entryPoint": 3659,
              "id": 14483,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@_min_14465": {
              "entryPoint": 3637,
              "id": 14465,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@_msgSender_1333": {
              "entryPoint": null,
              "id": 1333,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@_priceChangeAboveMax_6626": {
              "entryPoint": 2858,
              "id": 6626,
              "parameterSlots": 3,
              "returnSlots": 1
            },
            "@_scalePriceByDigits_6841": {
              "entryPoint": 3485,
              "id": 6841,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@_storeGoodPrice_6898": {
              "entryPoint": 2827,
              "id": 6898,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "@_storePrice_6870": {
              "entryPoint": 3584,
              "id": 6870,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@_transferOwnership_500": {
              "entryPoint": 3306,
              "id": 500,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@backupOracle_5899": {
              "entryPoint": null,
              "id": 5899,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@fetchPrice_6476": {
              "entryPoint": 513,
              "id": 6476,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@isContract_1009": {
              "entryPoint": null,
              "id": 1009,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@lastGoodPrice_5913": {
              "entryPoint": null,
              "id": 5913,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@mainOracle_5896": {
              "entryPoint": null,
              "id": 5896,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@owner_429": {
              "entryPoint": null,
              "id": 429,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@renounceOwnership_457": {
              "entryPoint": 1642,
              "id": 457,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@setAddresses_6014": {
              "entryPoint": 1662,
              "id": 6014,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@status_5929": {
              "entryPoint": null,
              "id": 5929,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@transferOwnership_480": {
              "entryPoint": 1955,
              "id": 480,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "abi_decode_address": {
              "entryPoint": 3769,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_address": {
              "entryPoint": 3921,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_addresst_address": {
              "entryPoint": 3792,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 2
            },
            "abi_decode_tuple_t_uint80t_int256t_uint256t_uint256t_uint80_fromMemory": {
              "entryPoint": 4006,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 5
            },
            "abi_decode_tuple_t_uint8_fromMemory": {
              "entryPoint": 3948,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_uint80_fromMemory": {
              "entryPoint": 3983,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_address__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_contract$_IBaseFeeOracle_$14928__to_t_address__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_enum$_Status_$5926__to_t_uint8__fromStack_reversed": {
              "entryPoint": 3729,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": 3843,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_stringliteral_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_stringliteral_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_uint80__to_t_uint80__fromStack_reversed": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "checked_div_t_uint256": {
              "entryPoint": 4189,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "checked_exp_helper": {
              "entryPoint": 4223,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 2
            },
            "checked_exp_t_uint256_t_uint256": {
              "entryPoint": 4451,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "checked_exp_unsigned": {
              "entryPoint": 4290,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "checked_mul_t_uint256": {
              "entryPoint": 4166,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "checked_sub_t_uint256": {
              "entryPoint": 4147,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "checked_sub_t_uint80": {
              "entryPoint": 4108,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "panic_error_0x11": {
              "entryPoint": 4086,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "panic_error_0x21": {
              "entryPoint": 3707,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 0
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nodeType": "YulBlock",
                "src": "0:6439:42",
                "statements": [
                  {
                    "nodeType": "YulBlock",
                    "src": "6:3:42",
                    "statements": []
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "115:76:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "125:26:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "137:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "148:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "133:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "133:18:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "125:4:42"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "167:9:42"
                              },
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "178:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "160:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "160:25:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "160:25:42"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "84:9:42",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "95:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "106:4:42",
                        "type": ""
                      }
                    ],
                    "src": "14:177:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "228:95:42",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "245:1:42",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "252:3:42",
                                    "type": "",
                                    "value": "224"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "257:10:42",
                                    "type": "",
                                    "value": "0x4e487b71"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "248:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "248:20:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "238:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "238:31:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "238:31:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "285:1:42",
                                "type": "",
                                "value": "4"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "288:4:42",
                                "type": "",
                                "value": "0x21"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "278:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "278:15:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "278:15:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "309:1:42",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "312:4:42",
                                "type": "",
                                "value": "0x24"
                              }
                            ],
                            "functionName": {
                              "name": "revert",
                              "nodeType": "YulIdentifier",
                              "src": "302:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "302:15:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "302:15:42"
                        }
                      ]
                    },
                    "name": "panic_error_0x21",
                    "nodeType": "YulFunctionDefinition",
                    "src": "196:127:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "438:229:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "448:26:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "460:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "471:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "456:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "456:18:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "448:4:42"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "516:111:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "537:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "544:3:42",
                                          "type": "",
                                          "value": "224"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "549:10:42",
                                          "type": "",
                                          "value": "0x4e487b71"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "shl",
                                        "nodeType": "YulIdentifier",
                                        "src": "540:3:42"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "540:20:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "530:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "530:31:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "530:31:42"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "581:1:42",
                                      "type": "",
                                      "value": "4"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "584:4:42",
                                      "type": "",
                                      "value": "0x21"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "574:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "574:15:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "574:15:42"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "609:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "612:4:42",
                                      "type": "",
                                      "value": "0x24"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "602:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "602:15:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "602:15:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "496:6:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "504:1:42",
                                    "type": "",
                                    "value": "5"
                                  }
                                ],
                                "functionName": {
                                  "name": "lt",
                                  "nodeType": "YulIdentifier",
                                  "src": "493:2:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "493:13:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "486:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "486:21:42"
                          },
                          "nodeType": "YulIf",
                          "src": "483:144:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "643:9:42"
                              },
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "654:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "636:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "636:25:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "636:25:42"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_enum$_Status_$5926__to_t_uint8__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "407:9:42",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "418:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "429:4:42",
                        "type": ""
                      }
                    ],
                    "src": "328:339:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "797:102:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "807:26:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "819:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "830:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "815:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "815:18:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "807:4:42"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "849:9:42"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "864:6:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "880:3:42",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "885:1:42",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "876:3:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "876:11:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "889:1:42",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "872:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "872:19:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "860:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "860:32:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "842:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "842:51:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "842:51:42"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_contract$_IBaseFeeOracle_$14928__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "766:9:42",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "777:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "788:4:42",
                        "type": ""
                      }
                    ],
                    "src": "672:227:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1005:102:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1015:26:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1027:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1038:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1023:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1023:18:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "1015:4:42"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1057:9:42"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "1072:6:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "1088:3:42",
                                            "type": "",
                                            "value": "160"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "1093:1:42",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "shl",
                                          "nodeType": "YulIdentifier",
                                          "src": "1084:3:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "1084:11:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "1097:1:42",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "sub",
                                      "nodeType": "YulIdentifier",
                                      "src": "1080:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1080:19:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "1068:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1068:32:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1050:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1050:51:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1050:51:42"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "974:9:42",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "985:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "996:4:42",
                        "type": ""
                      }
                    ],
                    "src": "904:203:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1161:124:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1171:29:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "1193:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "1180:12:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1180:20:42"
                          },
                          "variableNames": [
                            {
                              "name": "value",
                              "nodeType": "YulIdentifier",
                              "src": "1171:5:42"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1263:16:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1272:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1275:1:42",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1265:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1265:12:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1265:12:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "1222:5:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "1233:5:42"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "arguments": [
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "1248:3:42",
                                                "type": "",
                                                "value": "160"
                                              },
                                              {
                                                "kind": "number",
                                                "nodeType": "YulLiteral",
                                                "src": "1253:1:42",
                                                "type": "",
                                                "value": "1"
                                              }
                                            ],
                                            "functionName": {
                                              "name": "shl",
                                              "nodeType": "YulIdentifier",
                                              "src": "1244:3:42"
                                            },
                                            "nodeType": "YulFunctionCall",
                                            "src": "1244:11:42"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "1257:1:42",
                                            "type": "",
                                            "value": "1"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "sub",
                                          "nodeType": "YulIdentifier",
                                          "src": "1240:3:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "1240:19:42"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "1229:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1229:31:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "1219:2:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1219:42:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "1212:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1212:50:42"
                          },
                          "nodeType": "YulIf",
                          "src": "1209:70:42"
                        }
                      ]
                    },
                    "name": "abi_decode_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "1140:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "1151:5:42",
                        "type": ""
                      }
                    ],
                    "src": "1112:173:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1377:173:42",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1423:16:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1432:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1435:1:42",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1425:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1425:12:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1425:12:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1398:7:42"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1407:9:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "1394:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1394:23:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1419:2:42",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "1390:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1390:32:42"
                          },
                          "nodeType": "YulIf",
                          "src": "1387:52:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1448:39:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1477:9:42"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address",
                              "nodeType": "YulIdentifier",
                              "src": "1458:18:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1458:29:42"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "1448:6:42"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1496:48:42",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1529:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "1540:2:42",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1525:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1525:18:42"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address",
                              "nodeType": "YulIdentifier",
                              "src": "1506:18:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1506:38:42"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "1496:6:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_addresst_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1335:9:42",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "1346:7:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1358:6:42",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "1366:6:42",
                        "type": ""
                      }
                    ],
                    "src": "1290:260:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1676:427:42",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1686:12:42",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "1696:2:42",
                            "type": "",
                            "value": "32"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "1690:2:42",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1714:9:42"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "1725:2:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1707:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1707:21:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1707:21:42"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1737:27:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "1757:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "1751:5:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1751:13:42"
                          },
                          "variables": [
                            {
                              "name": "length",
                              "nodeType": "YulTypedName",
                              "src": "1741:6:42",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1784:9:42"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "1795:2:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1780:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1780:18:42"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "1800:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1773:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1773:34:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1773:34:42"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1816:10:42",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "1825:1:42",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "i",
                              "nodeType": "YulTypedName",
                              "src": "1820:1:42",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1885:90:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "name": "headStart",
                                              "nodeType": "YulIdentifier",
                                              "src": "1914:9:42"
                                            },
                                            {
                                              "name": "i",
                                              "nodeType": "YulIdentifier",
                                              "src": "1925:1:42"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "1910:3:42"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "1910:17:42"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "1929:2:42",
                                          "type": "",
                                          "value": "64"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "add",
                                        "nodeType": "YulIdentifier",
                                        "src": "1906:3:42"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "1906:26:42"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "arguments": [
                                                {
                                                  "name": "value0",
                                                  "nodeType": "YulIdentifier",
                                                  "src": "1948:6:42"
                                                },
                                                {
                                                  "name": "i",
                                                  "nodeType": "YulIdentifier",
                                                  "src": "1956:1:42"
                                                }
                                              ],
                                              "functionName": {
                                                "name": "add",
                                                "nodeType": "YulIdentifier",
                                                "src": "1944:3:42"
                                              },
                                              "nodeType": "YulFunctionCall",
                                              "src": "1944:14:42"
                                            },
                                            {
                                              "name": "_1",
                                              "nodeType": "YulIdentifier",
                                              "src": "1960:2:42"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "1940:3:42"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "1940:23:42"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "mload",
                                        "nodeType": "YulIdentifier",
                                        "src": "1934:5:42"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "1934:30:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "1899:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1899:66:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1899:66:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "i",
                                "nodeType": "YulIdentifier",
                                "src": "1846:1:42"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "1849:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "lt",
                              "nodeType": "YulIdentifier",
                              "src": "1843:2:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1843:13:42"
                          },
                          "nodeType": "YulForLoop",
                          "post": {
                            "nodeType": "YulBlock",
                            "src": "1857:19:42",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "1859:15:42",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "i",
                                      "nodeType": "YulIdentifier",
                                      "src": "1868:1:42"
                                    },
                                    {
                                      "name": "_1",
                                      "nodeType": "YulIdentifier",
                                      "src": "1871:2:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "add",
                                    "nodeType": "YulIdentifier",
                                    "src": "1864:3:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1864:10:42"
                                },
                                "variableNames": [
                                  {
                                    "name": "i",
                                    "nodeType": "YulIdentifier",
                                    "src": "1859:1:42"
                                  }
                                ]
                              }
                            ]
                          },
                          "pre": {
                            "nodeType": "YulBlock",
                            "src": "1839:3:42",
                            "statements": []
                          },
                          "src": "1835:140:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "headStart",
                                        "nodeType": "YulIdentifier",
                                        "src": "1999:9:42"
                                      },
                                      {
                                        "name": "length",
                                        "nodeType": "YulIdentifier",
                                        "src": "2010:6:42"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "1995:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1995:22:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2019:2:42",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1991:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1991:31:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2024:1:42",
                                "type": "",
                                "value": "0"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1984:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1984:42:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1984:42:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2035:62:42",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2051:9:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "arguments": [
                                          {
                                            "name": "length",
                                            "nodeType": "YulIdentifier",
                                            "src": "2070:6:42"
                                          },
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2078:2:42",
                                            "type": "",
                                            "value": "31"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "add",
                                          "nodeType": "YulIdentifier",
                                          "src": "2066:3:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "2066:15:42"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "kind": "number",
                                            "nodeType": "YulLiteral",
                                            "src": "2087:2:42",
                                            "type": "",
                                            "value": "31"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "not",
                                          "nodeType": "YulIdentifier",
                                          "src": "2083:3:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "2083:7:42"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "2062:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2062:29:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2047:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2047:45:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2094:2:42",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2043:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2043:54:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "2035:4:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1645:9:42",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1656:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "1667:4:42",
                        "type": ""
                      }
                    ],
                    "src": "1555:548:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2178:116:42",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2224:16:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2233:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2236:1:42",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "2226:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2226:12:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2226:12:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "2199:7:42"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2208:9:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "2195:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2195:23:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2220:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "2191:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2191:32:42"
                          },
                          "nodeType": "YulIf",
                          "src": "2188:52:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2249:39:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2278:9:42"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address",
                              "nodeType": "YulIdentifier",
                              "src": "2259:18:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2259:29:42"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "2249:6:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2144:9:42",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "2155:7:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2167:6:42",
                        "type": ""
                      }
                    ],
                    "src": "2108:186:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2378:194:42",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2424:16:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2433:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2436:1:42",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "2426:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2426:12:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2426:12:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "2399:7:42"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2408:9:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "2395:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2395:23:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2420:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "2391:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2391:32:42"
                          },
                          "nodeType": "YulIf",
                          "src": "2388:52:42"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "2449:29:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2468:9:42"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "2462:5:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2462:16:42"
                          },
                          "variables": [
                            {
                              "name": "value",
                              "nodeType": "YulTypedName",
                              "src": "2453:5:42",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2526:16:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2535:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "2538:1:42",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "2528:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2528:12:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2528:12:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "2500:5:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "2511:5:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "2518:4:42",
                                        "type": "",
                                        "value": "0xff"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "2507:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "2507:16:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "2497:2:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2497:27:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "2490:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2490:35:42"
                          },
                          "nodeType": "YulIf",
                          "src": "2487:55:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2551:15:42",
                          "value": {
                            "name": "value",
                            "nodeType": "YulIdentifier",
                            "src": "2561:5:42"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "2551:6:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_uint8_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2344:9:42",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "2355:7:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2367:6:42",
                        "type": ""
                      }
                    ],
                    "src": "2299:273:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2751:228:42",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2768:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2779:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2761:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2761:21:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2761:21:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2802:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2813:2:42",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2798:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2798:18:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2818:2:42",
                                "type": "",
                                "value": "38"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2791:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2791:30:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2791:30:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2841:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2852:2:42",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2837:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2837:18:42"
                              },
                              {
                                "hexValue": "4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "2857:34:42",
                                "type": "",
                                "value": "Ownable: new owner is the zero a"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2830:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2830:62:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2830:62:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2912:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2923:2:42",
                                    "type": "",
                                    "value": "96"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2908:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2908:18:42"
                              },
                              {
                                "hexValue": "646472657373",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "2928:8:42",
                                "type": "",
                                "value": "ddress"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2901:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2901:36:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2901:36:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2946:27:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "2958:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2969:3:42",
                                "type": "",
                                "value": "128"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2954:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2954:19:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "2946:4:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_stringliteral_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2728:9:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "2742:4:42",
                        "type": ""
                      }
                    ],
                    "src": "2577:402:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3043:120:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "3053:22:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "3068:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "3062:5:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3062:13:42"
                          },
                          "variableNames": [
                            {
                              "name": "value",
                              "nodeType": "YulIdentifier",
                              "src": "3053:5:42"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3141:16:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3150:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3153:1:42",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "3143:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3143:12:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3143:12:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "3097:5:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "3108:5:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "3115:22:42",
                                        "type": "",
                                        "value": "0xffffffffffffffffffff"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "and",
                                      "nodeType": "YulIdentifier",
                                      "src": "3104:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "3104:34:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "3094:2:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3094:45:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "3087:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3087:53:42"
                          },
                          "nodeType": "YulIf",
                          "src": "3084:73:42"
                        }
                      ]
                    },
                    "name": "abi_decode_uint80_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "3022:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "3033:5:42",
                        "type": ""
                      }
                    ],
                    "src": "2984:179:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3314:327:42",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3361:16:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3370:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "3373:1:42",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "3363:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3363:12:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3363:12:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "3335:7:42"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3344:9:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "3331:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3331:23:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3356:3:42",
                                "type": "",
                                "value": "160"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "3327:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3327:33:42"
                          },
                          "nodeType": "YulIf",
                          "src": "3324:53:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3386:49:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "3425:9:42"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_uint80_fromMemory",
                              "nodeType": "YulIdentifier",
                              "src": "3396:28:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3396:39:42"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "3386:6:42"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3444:35:42",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3464:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3475:2:42",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3460:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3460:18:42"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "3454:5:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3454:25:42"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "3444:6:42"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3488:35:42",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3508:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3519:2:42",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3504:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3504:18:42"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "3498:5:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3498:25:42"
                          },
                          "variableNames": [
                            {
                              "name": "value2",
                              "nodeType": "YulIdentifier",
                              "src": "3488:6:42"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3532:35:42",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3552:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3563:2:42",
                                    "type": "",
                                    "value": "96"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3548:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3548:18:42"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "3542:5:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3542:25:42"
                          },
                          "variableNames": [
                            {
                              "name": "value3",
                              "nodeType": "YulIdentifier",
                              "src": "3532:6:42"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3576:59:42",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "3619:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3630:3:42",
                                    "type": "",
                                    "value": "128"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3615:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3615:19:42"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_uint80_fromMemory",
                              "nodeType": "YulIdentifier",
                              "src": "3586:28:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3586:49:42"
                          },
                          "variableNames": [
                            {
                              "name": "value4",
                              "nodeType": "YulIdentifier",
                              "src": "3576:6:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_uint80t_int256t_uint256t_uint256t_uint80_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "3248:9:42",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "3259:7:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "3271:6:42",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "3279:6:42",
                        "type": ""
                      },
                      {
                        "name": "value2",
                        "nodeType": "YulTypedName",
                        "src": "3287:6:42",
                        "type": ""
                      },
                      {
                        "name": "value3",
                        "nodeType": "YulTypedName",
                        "src": "3295:6:42",
                        "type": ""
                      },
                      {
                        "name": "value4",
                        "nodeType": "YulTypedName",
                        "src": "3303:6:42",
                        "type": ""
                      }
                    ],
                    "src": "3168:473:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3678:95:42",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3695:1:42",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3702:3:42",
                                    "type": "",
                                    "value": "224"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "3707:10:42",
                                    "type": "",
                                    "value": "0x4e487b71"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "3698:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3698:20:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3688:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3688:31:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3688:31:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3735:1:42",
                                "type": "",
                                "value": "4"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3738:4:42",
                                "type": "",
                                "value": "0x11"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3728:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3728:15:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3728:15:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3759:1:42",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3762:4:42",
                                "type": "",
                                "value": "0x24"
                              }
                            ],
                            "functionName": {
                              "name": "revert",
                              "nodeType": "YulIdentifier",
                              "src": "3752:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3752:15:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3752:15:42"
                        }
                      ]
                    },
                    "name": "panic_error_0x11",
                    "nodeType": "YulFunctionDefinition",
                    "src": "3646:127:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3826:139:42",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "3836:32:42",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "3846:22:42",
                            "type": "",
                            "value": "0xffffffffffffffffffff"
                          },
                          "variables": [
                            {
                              "name": "_1",
                              "nodeType": "YulTypedName",
                              "src": "3840:2:42",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3877:35:42",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "x",
                                    "nodeType": "YulIdentifier",
                                    "src": "3893:1:42"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "3896:2:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "3889:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3889:10:42"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "y",
                                    "nodeType": "YulIdentifier",
                                    "src": "3905:1:42"
                                  },
                                  {
                                    "name": "_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "3908:2:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "3901:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3901:10:42"
                              }
                            ],
                            "functionName": {
                              "name": "sub",
                              "nodeType": "YulIdentifier",
                              "src": "3885:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3885:27:42"
                          },
                          "variableNames": [
                            {
                              "name": "diff",
                              "nodeType": "YulIdentifier",
                              "src": "3877:4:42"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3937:22:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x11",
                                    "nodeType": "YulIdentifier",
                                    "src": "3939:16:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3939:18:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3939:18:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "diff",
                                "nodeType": "YulIdentifier",
                                "src": "3927:4:42"
                              },
                              {
                                "name": "_1",
                                "nodeType": "YulIdentifier",
                                "src": "3933:2:42"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "3924:2:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3924:12:42"
                          },
                          "nodeType": "YulIf",
                          "src": "3921:38:42"
                        }
                      ]
                    },
                    "name": "checked_sub_t_uint80",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "x",
                        "nodeType": "YulTypedName",
                        "src": "3808:1:42",
                        "type": ""
                      },
                      {
                        "name": "y",
                        "nodeType": "YulTypedName",
                        "src": "3811:1:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "diff",
                        "nodeType": "YulTypedName",
                        "src": "3817:4:42",
                        "type": ""
                      }
                    ],
                    "src": "3778:187:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4069:105:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4079:26:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4091:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4102:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "4087:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4087:18:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "4079:4:42"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4121:9:42"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value0",
                                    "nodeType": "YulIdentifier",
                                    "src": "4136:6:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4144:22:42",
                                    "type": "",
                                    "value": "0xffffffffffffffffffff"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "4132:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4132:35:42"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4114:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4114:54:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4114:54:42"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_uint80__to_t_uint80__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4038:9:42",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "4049:6:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "4060:4:42",
                        "type": ""
                      }
                    ],
                    "src": "3970:204:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4228:79:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4238:17:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "x",
                                "nodeType": "YulIdentifier",
                                "src": "4250:1:42"
                              },
                              {
                                "name": "y",
                                "nodeType": "YulIdentifier",
                                "src": "4253:1:42"
                              }
                            ],
                            "functionName": {
                              "name": "sub",
                              "nodeType": "YulIdentifier",
                              "src": "4246:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4246:9:42"
                          },
                          "variableNames": [
                            {
                              "name": "diff",
                              "nodeType": "YulIdentifier",
                              "src": "4238:4:42"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4279:22:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x11",
                                    "nodeType": "YulIdentifier",
                                    "src": "4281:16:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4281:18:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4281:18:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "diff",
                                "nodeType": "YulIdentifier",
                                "src": "4270:4:42"
                              },
                              {
                                "name": "x",
                                "nodeType": "YulIdentifier",
                                "src": "4276:1:42"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "4267:2:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4267:11:42"
                          },
                          "nodeType": "YulIf",
                          "src": "4264:37:42"
                        }
                      ]
                    },
                    "name": "checked_sub_t_uint256",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "x",
                        "nodeType": "YulTypedName",
                        "src": "4210:1:42",
                        "type": ""
                      },
                      {
                        "name": "y",
                        "nodeType": "YulTypedName",
                        "src": "4213:1:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "diff",
                        "nodeType": "YulTypedName",
                        "src": "4219:4:42",
                        "type": ""
                      }
                    ],
                    "src": "4179:128:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4364:116:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "4374:20:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "x",
                                "nodeType": "YulIdentifier",
                                "src": "4389:1:42"
                              },
                              {
                                "name": "y",
                                "nodeType": "YulIdentifier",
                                "src": "4392:1:42"
                              }
                            ],
                            "functionName": {
                              "name": "mul",
                              "nodeType": "YulIdentifier",
                              "src": "4385:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4385:9:42"
                          },
                          "variableNames": [
                            {
                              "name": "product",
                              "nodeType": "YulIdentifier",
                              "src": "4374:7:42"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4452:22:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x11",
                                    "nodeType": "YulIdentifier",
                                    "src": "4454:16:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4454:18:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4454:18:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "x",
                                        "nodeType": "YulIdentifier",
                                        "src": "4423:1:42"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "iszero",
                                      "nodeType": "YulIdentifier",
                                      "src": "4416:6:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "4416:9:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "y",
                                        "nodeType": "YulIdentifier",
                                        "src": "4430:1:42"
                                      },
                                      {
                                        "arguments": [
                                          {
                                            "name": "product",
                                            "nodeType": "YulIdentifier",
                                            "src": "4437:7:42"
                                          },
                                          {
                                            "name": "x",
                                            "nodeType": "YulIdentifier",
                                            "src": "4446:1:42"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "div",
                                          "nodeType": "YulIdentifier",
                                          "src": "4433:3:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "4433:15:42"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "eq",
                                      "nodeType": "YulIdentifier",
                                      "src": "4427:2:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "4427:22:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "or",
                                  "nodeType": "YulIdentifier",
                                  "src": "4413:2:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4413:37:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "4406:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4406:45:42"
                          },
                          "nodeType": "YulIf",
                          "src": "4403:71:42"
                        }
                      ]
                    },
                    "name": "checked_mul_t_uint256",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "x",
                        "nodeType": "YulTypedName",
                        "src": "4343:1:42",
                        "type": ""
                      },
                      {
                        "name": "y",
                        "nodeType": "YulTypedName",
                        "src": "4346:1:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "product",
                        "nodeType": "YulTypedName",
                        "src": "4352:7:42",
                        "type": ""
                      }
                    ],
                    "src": "4312:168:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4531:171:42",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4562:111:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4583:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "4590:3:42",
                                          "type": "",
                                          "value": "224"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "4595:10:42",
                                          "type": "",
                                          "value": "0x4e487b71"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "shl",
                                        "nodeType": "YulIdentifier",
                                        "src": "4586:3:42"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "4586:20:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "4576:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4576:31:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4576:31:42"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4627:1:42",
                                      "type": "",
                                      "value": "4"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4630:4:42",
                                      "type": "",
                                      "value": "0x12"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "4620:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4620:15:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4620:15:42"
                              },
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4655:1:42",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "4658:4:42",
                                      "type": "",
                                      "value": "0x24"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "4648:6:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4648:15:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4648:15:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "y",
                                "nodeType": "YulIdentifier",
                                "src": "4551:1:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "4544:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4544:9:42"
                          },
                          "nodeType": "YulIf",
                          "src": "4541:132:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "4682:14:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "x",
                                "nodeType": "YulIdentifier",
                                "src": "4691:1:42"
                              },
                              {
                                "name": "y",
                                "nodeType": "YulIdentifier",
                                "src": "4694:1:42"
                              }
                            ],
                            "functionName": {
                              "name": "div",
                              "nodeType": "YulIdentifier",
                              "src": "4687:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4687:9:42"
                          },
                          "variableNames": [
                            {
                              "name": "r",
                              "nodeType": "YulIdentifier",
                              "src": "4682:1:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "checked_div_t_uint256",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "x",
                        "nodeType": "YulTypedName",
                        "src": "4516:1:42",
                        "type": ""
                      },
                      {
                        "name": "y",
                        "nodeType": "YulTypedName",
                        "src": "4519:1:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "r",
                        "nodeType": "YulTypedName",
                        "src": "4525:1:42",
                        "type": ""
                      }
                    ],
                    "src": "4485:217:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4881:182:42",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "4898:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4909:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4891:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4891:21:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4891:21:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4932:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4943:2:42",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4928:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4928:18:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4948:2:42",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4921:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4921:30:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4921:30:42"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4971:9:42"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4982:2:42",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4967:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4967:18:42"
                              },
                              {
                                "hexValue": "4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "4987:34:42",
                                "type": "",
                                "value": "Ownable: caller is not the owner"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "4960:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4960:62:42"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "4960:62:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5031:26:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "5043:9:42"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5054:2:42",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "5039:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5039:18:42"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "5031:4:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_stringliteral_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4858:9:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "4872:4:42",
                        "type": ""
                      }
                    ],
                    "src": "4707:356:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5132:358:42",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "5142:16:42",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "5157:1:42",
                            "type": "",
                            "value": "1"
                          },
                          "variables": [
                            {
                              "name": "power_1",
                              "nodeType": "YulTypedName",
                              "src": "5146:7:42",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5167:16:42",
                          "value": {
                            "name": "power_1",
                            "nodeType": "YulIdentifier",
                            "src": "5176:7:42"
                          },
                          "variableNames": [
                            {
                              "name": "power",
                              "nodeType": "YulIdentifier",
                              "src": "5167:5:42"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5192:13:42",
                          "value": {
                            "name": "_base",
                            "nodeType": "YulIdentifier",
                            "src": "5200:5:42"
                          },
                          "variableNames": [
                            {
                              "name": "base",
                              "nodeType": "YulIdentifier",
                              "src": "5192:4:42"
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5256:228:42",
                            "statements": [
                              {
                                "body": {
                                  "nodeType": "YulBlock",
                                  "src": "5301:22:42",
                                  "statements": [
                                    {
                                      "expression": {
                                        "arguments": [],
                                        "functionName": {
                                          "name": "panic_error_0x11",
                                          "nodeType": "YulIdentifier",
                                          "src": "5303:16:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "5303:18:42"
                                      },
                                      "nodeType": "YulExpressionStatement",
                                      "src": "5303:18:42"
                                    }
                                  ]
                                },
                                "condition": {
                                  "arguments": [
                                    {
                                      "name": "base",
                                      "nodeType": "YulIdentifier",
                                      "src": "5276:4:42"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "kind": "number",
                                              "nodeType": "YulLiteral",
                                              "src": "5290:1:42",
                                              "type": "",
                                              "value": "0"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "not",
                                            "nodeType": "YulIdentifier",
                                            "src": "5286:3:42"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "5286:6:42"
                                        },
                                        {
                                          "name": "base",
                                          "nodeType": "YulIdentifier",
                                          "src": "5294:4:42"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "div",
                                        "nodeType": "YulIdentifier",
                                        "src": "5282:3:42"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "5282:17:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "gt",
                                    "nodeType": "YulIdentifier",
                                    "src": "5273:2:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5273:27:42"
                                },
                                "nodeType": "YulIf",
                                "src": "5270:53:42"
                              },
                              {
                                "body": {
                                  "nodeType": "YulBlock",
                                  "src": "5362:29:42",
                                  "statements": [
                                    {
                                      "nodeType": "YulAssignment",
                                      "src": "5364:25:42",
                                      "value": {
                                        "arguments": [
                                          {
                                            "name": "power",
                                            "nodeType": "YulIdentifier",
                                            "src": "5377:5:42"
                                          },
                                          {
                                            "name": "base",
                                            "nodeType": "YulIdentifier",
                                            "src": "5384:4:42"
                                          }
                                        ],
                                        "functionName": {
                                          "name": "mul",
                                          "nodeType": "YulIdentifier",
                                          "src": "5373:3:42"
                                        },
                                        "nodeType": "YulFunctionCall",
                                        "src": "5373:16:42"
                                      },
                                      "variableNames": [
                                        {
                                          "name": "power",
                                          "nodeType": "YulIdentifier",
                                          "src": "5364:5:42"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "condition": {
                                  "arguments": [
                                    {
                                      "name": "exponent",
                                      "nodeType": "YulIdentifier",
                                      "src": "5343:8:42"
                                    },
                                    {
                                      "name": "power_1",
                                      "nodeType": "YulIdentifier",
                                      "src": "5353:7:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "and",
                                    "nodeType": "YulIdentifier",
                                    "src": "5339:3:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5339:22:42"
                                },
                                "nodeType": "YulIf",
                                "src": "5336:55:42"
                              },
                              {
                                "nodeType": "YulAssignment",
                                "src": "5404:23:42",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "base",
                                      "nodeType": "YulIdentifier",
                                      "src": "5416:4:42"
                                    },
                                    {
                                      "name": "base",
                                      "nodeType": "YulIdentifier",
                                      "src": "5422:4:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mul",
                                    "nodeType": "YulIdentifier",
                                    "src": "5412:3:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5412:15:42"
                                },
                                "variableNames": [
                                  {
                                    "name": "base",
                                    "nodeType": "YulIdentifier",
                                    "src": "5404:4:42"
                                  }
                                ]
                              },
                              {
                                "nodeType": "YulAssignment",
                                "src": "5440:34:42",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "power_1",
                                      "nodeType": "YulIdentifier",
                                      "src": "5456:7:42"
                                    },
                                    {
                                      "name": "exponent",
                                      "nodeType": "YulIdentifier",
                                      "src": "5465:8:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "shr",
                                    "nodeType": "YulIdentifier",
                                    "src": "5452:3:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5452:22:42"
                                },
                                "variableNames": [
                                  {
                                    "name": "exponent",
                                    "nodeType": "YulIdentifier",
                                    "src": "5440:8:42"
                                  }
                                ]
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "exponent",
                                "nodeType": "YulIdentifier",
                                "src": "5225:8:42"
                              },
                              {
                                "name": "power_1",
                                "nodeType": "YulIdentifier",
                                "src": "5235:7:42"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "5222:2:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5222:21:42"
                          },
                          "nodeType": "YulForLoop",
                          "post": {
                            "nodeType": "YulBlock",
                            "src": "5244:3:42",
                            "statements": []
                          },
                          "pre": {
                            "nodeType": "YulBlock",
                            "src": "5218:3:42",
                            "statements": []
                          },
                          "src": "5214:270:42"
                        }
                      ]
                    },
                    "name": "checked_exp_helper",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "_base",
                        "nodeType": "YulTypedName",
                        "src": "5096:5:42",
                        "type": ""
                      },
                      {
                        "name": "exponent",
                        "nodeType": "YulTypedName",
                        "src": "5103:8:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "power",
                        "nodeType": "YulTypedName",
                        "src": "5116:5:42",
                        "type": ""
                      },
                      {
                        "name": "base",
                        "nodeType": "YulTypedName",
                        "src": "5123:4:42",
                        "type": ""
                      }
                    ],
                    "src": "5068:422:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5554:747:42",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5592:52:42",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "5606:10:42",
                                "value": {
                                  "kind": "number",
                                  "nodeType": "YulLiteral",
                                  "src": "5615:1:42",
                                  "type": "",
                                  "value": "1"
                                },
                                "variableNames": [
                                  {
                                    "name": "power",
                                    "nodeType": "YulIdentifier",
                                    "src": "5606:5:42"
                                  }
                                ]
                              },
                              {
                                "nodeType": "YulLeave",
                                "src": "5629:5:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "exponent",
                                "nodeType": "YulIdentifier",
                                "src": "5574:8:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "5567:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5567:16:42"
                          },
                          "nodeType": "YulIf",
                          "src": "5564:80:42"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5677:52:42",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "5691:10:42",
                                "value": {
                                  "kind": "number",
                                  "nodeType": "YulLiteral",
                                  "src": "5700:1:42",
                                  "type": "",
                                  "value": "0"
                                },
                                "variableNames": [
                                  {
                                    "name": "power",
                                    "nodeType": "YulIdentifier",
                                    "src": "5691:5:42"
                                  }
                                ]
                              },
                              {
                                "nodeType": "YulLeave",
                                "src": "5714:5:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "base",
                                "nodeType": "YulIdentifier",
                                "src": "5663:4:42"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "5656:6:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5656:12:42"
                          },
                          "nodeType": "YulIf",
                          "src": "5653:76:42"
                        },
                        {
                          "cases": [
                            {
                              "body": {
                                "nodeType": "YulBlock",
                                "src": "5765:52:42",
                                "statements": [
                                  {
                                    "nodeType": "YulAssignment",
                                    "src": "5779:10:42",
                                    "value": {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "5788:1:42",
                                      "type": "",
                                      "value": "1"
                                    },
                                    "variableNames": [
                                      {
                                        "name": "power",
                                        "nodeType": "YulIdentifier",
                                        "src": "5779:5:42"
                                      }
                                    ]
                                  },
                                  {
                                    "nodeType": "YulLeave",
                                    "src": "5802:5:42"
                                  }
                                ]
                              },
                              "nodeType": "YulCase",
                              "src": "5758:59:42",
                              "value": {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5763:1:42",
                                "type": "",
                                "value": "1"
                              }
                            },
                            {
                              "body": {
                                "nodeType": "YulBlock",
                                "src": "5833:123:42",
                                "statements": [
                                  {
                                    "body": {
                                      "nodeType": "YulBlock",
                                      "src": "5868:22:42",
                                      "statements": [
                                        {
                                          "expression": {
                                            "arguments": [],
                                            "functionName": {
                                              "name": "panic_error_0x11",
                                              "nodeType": "YulIdentifier",
                                              "src": "5870:16:42"
                                            },
                                            "nodeType": "YulFunctionCall",
                                            "src": "5870:18:42"
                                          },
                                          "nodeType": "YulExpressionStatement",
                                          "src": "5870:18:42"
                                        }
                                      ]
                                    },
                                    "condition": {
                                      "arguments": [
                                        {
                                          "name": "exponent",
                                          "nodeType": "YulIdentifier",
                                          "src": "5853:8:42"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "5863:3:42",
                                          "type": "",
                                          "value": "255"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "gt",
                                        "nodeType": "YulIdentifier",
                                        "src": "5850:2:42"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "5850:17:42"
                                    },
                                    "nodeType": "YulIf",
                                    "src": "5847:43:42"
                                  },
                                  {
                                    "nodeType": "YulAssignment",
                                    "src": "5903:25:42",
                                    "value": {
                                      "arguments": [
                                        {
                                          "name": "exponent",
                                          "nodeType": "YulIdentifier",
                                          "src": "5916:8:42"
                                        },
                                        {
                                          "kind": "number",
                                          "nodeType": "YulLiteral",
                                          "src": "5926:1:42",
                                          "type": "",
                                          "value": "1"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "shl",
                                        "nodeType": "YulIdentifier",
                                        "src": "5912:3:42"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "5912:16:42"
                                    },
                                    "variableNames": [
                                      {
                                        "name": "power",
                                        "nodeType": "YulIdentifier",
                                        "src": "5903:5:42"
                                      }
                                    ]
                                  },
                                  {
                                    "nodeType": "YulLeave",
                                    "src": "5941:5:42"
                                  }
                                ]
                              },
                              "nodeType": "YulCase",
                              "src": "5826:130:42",
                              "value": {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5831:1:42",
                                "type": "",
                                "value": "2"
                              }
                            }
                          ],
                          "expression": {
                            "name": "base",
                            "nodeType": "YulIdentifier",
                            "src": "5745:4:42"
                          },
                          "nodeType": "YulSwitch",
                          "src": "5738:218:42"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "6054:70:42",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "6068:28:42",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "base",
                                      "nodeType": "YulIdentifier",
                                      "src": "6081:4:42"
                                    },
                                    {
                                      "name": "exponent",
                                      "nodeType": "YulIdentifier",
                                      "src": "6087:8:42"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "exp",
                                    "nodeType": "YulIdentifier",
                                    "src": "6077:3:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "6077:19:42"
                                },
                                "variableNames": [
                                  {
                                    "name": "power",
                                    "nodeType": "YulIdentifier",
                                    "src": "6068:5:42"
                                  }
                                ]
                              },
                              {
                                "nodeType": "YulLeave",
                                "src": "6109:5:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "base",
                                        "nodeType": "YulIdentifier",
                                        "src": "5978:4:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "5984:2:42",
                                        "type": "",
                                        "value": "11"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "lt",
                                      "nodeType": "YulIdentifier",
                                      "src": "5975:2:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "5975:12:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "exponent",
                                        "nodeType": "YulIdentifier",
                                        "src": "5992:8:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "6002:2:42",
                                        "type": "",
                                        "value": "78"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "lt",
                                      "nodeType": "YulIdentifier",
                                      "src": "5989:2:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "5989:16:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "5971:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5971:35:42"
                              },
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "base",
                                        "nodeType": "YulIdentifier",
                                        "src": "6015:4:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "6021:3:42",
                                        "type": "",
                                        "value": "307"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "lt",
                                      "nodeType": "YulIdentifier",
                                      "src": "6012:2:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "6012:13:42"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "exponent",
                                        "nodeType": "YulIdentifier",
                                        "src": "6030:8:42"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "6040:2:42",
                                        "type": "",
                                        "value": "32"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "lt",
                                      "nodeType": "YulIdentifier",
                                      "src": "6027:2:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "6027:16:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "and",
                                  "nodeType": "YulIdentifier",
                                  "src": "6008:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "6008:36:42"
                              }
                            ],
                            "functionName": {
                              "name": "or",
                              "nodeType": "YulIdentifier",
                              "src": "5968:2:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5968:77:42"
                          },
                          "nodeType": "YulIf",
                          "src": "5965:159:42"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "6133:57:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "base",
                                "nodeType": "YulIdentifier",
                                "src": "6175:4:42"
                              },
                              {
                                "name": "exponent",
                                "nodeType": "YulIdentifier",
                                "src": "6181:8:42"
                              }
                            ],
                            "functionName": {
                              "name": "checked_exp_helper",
                              "nodeType": "YulIdentifier",
                              "src": "6156:18:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6156:34:42"
                          },
                          "variables": [
                            {
                              "name": "power_1",
                              "nodeType": "YulTypedName",
                              "src": "6137:7:42",
                              "type": ""
                            },
                            {
                              "name": "base_1",
                              "nodeType": "YulTypedName",
                              "src": "6146:6:42",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "6235:22:42",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x11",
                                    "nodeType": "YulIdentifier",
                                    "src": "6237:16:42"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "6237:18:42"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "6237:18:42"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "power_1",
                                "nodeType": "YulIdentifier",
                                "src": "6205:7:42"
                              },
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "6222:1:42",
                                        "type": "",
                                        "value": "0"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "not",
                                      "nodeType": "YulIdentifier",
                                      "src": "6218:3:42"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "6218:6:42"
                                  },
                                  {
                                    "name": "base_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "6226:6:42"
                                  }
                                ],
                                "functionName": {
                                  "name": "div",
                                  "nodeType": "YulIdentifier",
                                  "src": "6214:3:42"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "6214:19:42"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "6202:2:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6202:32:42"
                          },
                          "nodeType": "YulIf",
                          "src": "6199:58:42"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "6266:29:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "power_1",
                                "nodeType": "YulIdentifier",
                                "src": "6279:7:42"
                              },
                              {
                                "name": "base_1",
                                "nodeType": "YulIdentifier",
                                "src": "6288:6:42"
                              }
                            ],
                            "functionName": {
                              "name": "mul",
                              "nodeType": "YulIdentifier",
                              "src": "6275:3:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6275:20:42"
                          },
                          "variableNames": [
                            {
                              "name": "power",
                              "nodeType": "YulIdentifier",
                              "src": "6266:5:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "checked_exp_unsigned",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "base",
                        "nodeType": "YulTypedName",
                        "src": "5525:4:42",
                        "type": ""
                      },
                      {
                        "name": "exponent",
                        "nodeType": "YulTypedName",
                        "src": "5531:8:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "power",
                        "nodeType": "YulTypedName",
                        "src": "5544:5:42",
                        "type": ""
                      }
                    ],
                    "src": "5495:806:42"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "6376:61:42",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "6386:45:42",
                          "value": {
                            "arguments": [
                              {
                                "name": "base",
                                "nodeType": "YulIdentifier",
                                "src": "6416:4:42"
                              },
                              {
                                "name": "exponent",
                                "nodeType": "YulIdentifier",
                                "src": "6422:8:42"
                              }
                            ],
                            "functionName": {
                              "name": "checked_exp_unsigned",
                              "nodeType": "YulIdentifier",
                              "src": "6395:20:42"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6395:36:42"
                          },
                          "variableNames": [
                            {
                              "name": "power",
                              "nodeType": "YulIdentifier",
                              "src": "6386:5:42"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "checked_exp_t_uint256_t_uint256",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "base",
                        "nodeType": "YulTypedName",
                        "src": "6347:4:42",
                        "type": ""
                      },
                      {
                        "name": "exponent",
                        "nodeType": "YulTypedName",
                        "src": "6353:8:42",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "power",
                        "nodeType": "YulTypedName",
                        "src": "6366:5:42",
                        "type": ""
                      }
                    ],
                    "src": "6306:131:42"
                  }
                ]
              },
              "contents": "{\n    { }\n    function abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n    function panic_error_0x21()\n    {\n        mstore(0, shl(224, 0x4e487b71))\n        mstore(4, 0x21)\n        revert(0, 0x24)\n    }\n    function abi_encode_tuple_t_enum$_Status_$5926__to_t_uint8__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        if iszero(lt(value0, 5))\n        {\n            mstore(0, shl(224, 0x4e487b71))\n            mstore(4, 0x21)\n            revert(0, 0x24)\n        }\n        mstore(headStart, value0)\n    }\n    function abi_encode_tuple_t_contract$_IBaseFeeOracle_$14928__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_encode_tuple_t_address__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n    }\n    function abi_decode_address(offset) -> value\n    {\n        value := calldataload(offset)\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_addresst_address(headStart, dataEnd) -> value0, value1\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        value0 := abi_decode_address(headStart)\n        value1 := abi_decode_address(add(headStart, 32))\n    }\n    function abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed(headStart, value0) -> tail\n    {\n        let _1 := 32\n        mstore(headStart, _1)\n        let length := mload(value0)\n        mstore(add(headStart, _1), length)\n        let i := 0\n        for { } lt(i, length) { i := add(i, _1) }\n        {\n            mstore(add(add(headStart, i), 64), mload(add(add(value0, i), _1)))\n        }\n        mstore(add(add(headStart, length), 64), 0)\n        tail := add(add(headStart, and(add(length, 31), not(31))), 64)\n    }\n    function abi_decode_tuple_t_address(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        value0 := abi_decode_address(headStart)\n    }\n    function abi_decode_tuple_t_uint8_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := mload(headStart)\n        if iszero(eq(value, and(value, 0xff))) { revert(0, 0) }\n        value0 := value\n    }\n    function abi_encode_tuple_t_stringliteral_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        mstore(headStart, 32)\n        mstore(add(headStart, 32), 38)\n        mstore(add(headStart, 64), \"Ownable: new owner is the zero a\")\n        mstore(add(headStart, 96), \"ddress\")\n        tail := add(headStart, 128)\n    }\n    function abi_decode_uint80_fromMemory(offset) -> value\n    {\n        value := mload(offset)\n        if iszero(eq(value, and(value, 0xffffffffffffffffffff))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_uint80t_int256t_uint256t_uint256t_uint80_fromMemory(headStart, dataEnd) -> value0, value1, value2, value3, value4\n    {\n        if slt(sub(dataEnd, headStart), 160) { revert(0, 0) }\n        value0 := abi_decode_uint80_fromMemory(headStart)\n        value1 := mload(add(headStart, 32))\n        value2 := mload(add(headStart, 64))\n        value3 := mload(add(headStart, 96))\n        value4 := abi_decode_uint80_fromMemory(add(headStart, 128))\n    }\n    function panic_error_0x11()\n    {\n        mstore(0, shl(224, 0x4e487b71))\n        mstore(4, 0x11)\n        revert(0, 0x24)\n    }\n    function checked_sub_t_uint80(x, y) -> diff\n    {\n        let _1 := 0xffffffffffffffffffff\n        diff := sub(and(x, _1), and(y, _1))\n        if gt(diff, _1) { panic_error_0x11() }\n    }\n    function abi_encode_tuple_t_uint80__to_t_uint80__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, 0xffffffffffffffffffff))\n    }\n    function checked_sub_t_uint256(x, y) -> diff\n    {\n        diff := sub(x, y)\n        if gt(diff, x) { panic_error_0x11() }\n    }\n    function checked_mul_t_uint256(x, y) -> product\n    {\n        product := mul(x, y)\n        if iszero(or(iszero(x), eq(y, div(product, x)))) { panic_error_0x11() }\n    }\n    function checked_div_t_uint256(x, y) -> r\n    {\n        if iszero(y)\n        {\n            mstore(0, shl(224, 0x4e487b71))\n            mstore(4, 0x12)\n            revert(0, 0x24)\n        }\n        r := div(x, y)\n    }\n    function abi_encode_tuple_t_stringliteral_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        mstore(headStart, 32)\n        mstore(add(headStart, 32), 32)\n        mstore(add(headStart, 64), \"Ownable: caller is not the owner\")\n        tail := add(headStart, 96)\n    }\n    function checked_exp_helper(_base, exponent) -> power, base\n    {\n        let power_1 := 1\n        power := power_1\n        base := _base\n        for { } gt(exponent, power_1) { }\n        {\n            if gt(base, div(not(0), base)) { panic_error_0x11() }\n            if and(exponent, power_1) { power := mul(power, base) }\n            base := mul(base, base)\n            exponent := shr(power_1, exponent)\n        }\n    }\n    function checked_exp_unsigned(base, exponent) -> power\n    {\n        if iszero(exponent)\n        {\n            power := 1\n            leave\n        }\n        if iszero(base)\n        {\n            power := 0\n            leave\n        }\n        switch base\n        case 1 {\n            power := 1\n            leave\n        }\n        case 2 {\n            if gt(exponent, 255) { panic_error_0x11() }\n            power := shl(exponent, 1)\n            leave\n        }\n        if or(and(lt(base, 11), lt(exponent, 78)), and(lt(base, 307), lt(exponent, 32)))\n        {\n            power := exp(base, exponent)\n            leave\n        }\n        let power_1, base_1 := checked_exp_helper(base, exponent)\n        if gt(power_1, div(not(0), base_1)) { panic_error_0x11() }\n        power := mul(power_1, base_1)\n    }\n    function checked_exp_t_uint256_t_uint256(base, exponent) -> power\n    {\n        power := checked_exp_unsigned(base, exponent)\n    }\n}",
              "id": 42,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "immutableReferences": {},
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b50600436106100d55760003560e01c806386800a961161008757806386800a96146101635780638da5cb5b1461016b57806390107afe1461017c578063a20baee61461018f578063a3f4df7e1461019e578063c8e07115146101d3578063f2fde38b146101e6578063f56f48f2146101f957600080fd5b80630490be83146100da5780630fdb11cf146100f65780631be5c92f146100fe578063200d2ed21461010657806345079cb414610120578063715018a61461012e578063836efd3114610138575b600080fd5b6100e360035481565b6040519081526020015b60405180910390f35b6100e3610201565b6100e3601281565b6004546101139060ff1681565b6040516100ed9190610e91565b6100e366b1a2bc2ec5000081565b61013661066a565b005b60025461014b906001600160a01b031681565b6040516001600160a01b0390911681526020016100ed565b6100e360b081565b6000546001600160a01b031661014b565b61013661018a366004610ed0565b61067e565b6100e3670de0b6b3a764000081565b6101c660405180604001604052806009815260200168141c9a58d95199595960ba1b81525081565b6040516100ed9190610f03565b60015461014b906001600160a01b031681565b6101366101f4366004610f51565b6107a3565b6100e3604581565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610257573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027b9190610f6c565b90506000610287610821565b9050600061029882604001516108c4565b905060006102a461097f565b905060006102b582604001516109f3565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103309190610f6c565b905060006004805460ff169081111561034b5761034b610e7b565b036104545761035a8585610a17565b156103bc5761036883610a3a565b15610385576103776002610a8a565b600354965050505050505090565b61038e83610ae7565b1561039d576103776001610a8a565b6103a76001610a8a565b6103b18382610b0b565b965050505050505090565b6103c585610ae7565b15610408576103d383610a3a565b156103e2576103776004610a8a565b6103ec6003610a8a565b6103f583610ae7565b156103a757600354965050505050505090565b610413858588610b2a565b156104325761042183610a3a565b806103685750610368838383610b2a565b61043b83610a3a565b1561044a5761044a6004610a8a565b6103b18587610b0b565b60016004805460ff169081111561046d5761046d610e7b565b036104dc5761047f8585858985610ba9565b1561048e5761044a6000610a8a565b61049783610a3a565b156104a6576103776002610a8a565b6104af83610ae7565b156104c257600354965050505050505090565b6104cd838383610b2a565b156103a7576103776002610a8a565b60026004805460ff16908111156104f5576104f5610e7b565b03610516576105078585858985610ba9565b156103775761044a6000610a8a565b60036004805460ff169081111561052f5761052f610e7b565b036105da5761053e8585610a17565b156105655761054c83610a3a565b1561055b576103776002610a8a565b6103ec6001610a8a565b61056e85610ae7565b1561058b5761057c83610a3a565b156103ec576103776004610a8a565b61059483610a3a565b156105a35761044a6004610a8a565b6105ac83610ae7565b156105bf57600354965050505050505090565b6105cb85848884610c07565b1561039d5761044a6000610a8a565b6004805460ff16818111156105f1576105f1610e7b565b03610661576106008585610a17565b1561060f576103776002610a8a565b61061885610ae7565b1561062b57600354965050505050505090565b6106388585858985610ba9565b156106475761044a6000610a8a565b610652858588610b2a565b1561044a576103776002610a8a565b50505050505090565b610672610c90565b61067c6000610cea565b565b610686610c90565b600180546001600160a01b038481166001600160a01b03199283161790925560028054928416929091169190911790556004805460ff1916905560006106ca610821565b905060006106db82604001516108c4565b90506106e78282610a17565b806106f657506106f682610ae7565b156107145760405163062a774160e51b815260040160405180910390fd5b61079482600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561076b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078f9190610f6c565b610b0b565b5061079d61066a565b50505050565b6107ab610c90565b6001600160a01b0381166108155760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61081e81610cea565b50565b610829610e5b565b600160009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b60015b61089f5790565b506001600160501b0390931660408501525082526001600160401b0316602082015290565b6108cc610e5b565b600180546001600160a01b031690639a6fc8f5906108ea908561100c565b6040516001600160e01b031960e084901b1681526001600160501b03909116600482015260240160a060405180830381865afa92505050801561094a575060408051601f3d908101601f1916820190925261094791810190610fa6565b60015b61095357919050565b506001600160501b0390931660408501525082526001600160401b03166020820152919050565b919050565b610987610e5b565b600260009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b6109fb610e5b565b6002546001600160a01b0316639a6fc8f56108ea60018561100c565b6000610a2283610d3a565b80610a315750610a3182610d3a565b90505b92915050565b600081602001516001600160401b031660001480610a6457504382602001516001600160401b0316115b15610a7157506001919050565b8151600003610a8257506001919050565b506000919050565b6004805482919060ff191660018383811115610aa857610aa8610e7b565b02179055507f5c57579a8214fe4f710c1c56fa829f045b9fa6d225a744225a30c32188064d4e81604051610adc9190610e91565b60405180910390a150565b6000604582602001516001600160401b031643610b049190611033565b1192915050565b600080610b1f84600001518460ff16610d9d565b9050610a3181610e00565b600080610b3e85600001518460ff16610d9d565b90506000610b5385600001518560ff16610d9d565b90506000610b618383610e35565b90506000610b6f8484610e4b565b90506000610b7d8383611033565b905060006103e8610b8f60b085611046565b610b99919061105d565b9091119998505050505050505050565b6000610bb484610a3a565b80610bc35750610bc384610ae7565b80610bd35750610bd38686610a17565b80610be25750610be286610ae7565b15610bef57506000610bfe565b610bfb86858585610c07565b90505b95945050505050565b600080610c1b86600001518560ff16610d9d565b90506000610c3086600001518560ff16610d9d565b90506000610c3e8284610e35565b90506000610c4c8385610e4b565b9050600082670de0b6b3a7640000610c648285611033565b610c6e9190611046565b610c78919061105d565b66b1a2bc2ec5000010159a9950505050505050505050565b6000546001600160a01b0316331461067c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161080c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600081604001516001600160501b0316600003610d5957506001919050565b60208201516001600160401b03161580610d7f57504382602001516001600160401b0316115b15610d8c57506001919050565b8151600012610a8257506001919050565b60008060128310610dcf57610db3601284611033565b610dbe90600a611163565b610dc8908561105d565b9050610a31565b6012831015610a3157610de3836012611033565b610dee90600a611163565b610df89085611046565b949350505050565b60038190556040518181527f4d29de21de555af78a62fc82dd4bc05e9ae5b0660a37f04729527e0f22780cd390602001610adc565b6000818310610e445781610a31565b5090919050565b600081831015610e445781610a31565b604080516060810182526000808252602082018190529181019190915290565b634e487b7160e01b600052602160045260246000fd5b6020810160058310610eb357634e487b7160e01b600052602160045260246000fd5b91905290565b80356001600160a01b038116811461097a57600080fd5b60008060408385031215610ee357600080fd5b610eec83610eb9565b9150610efa60208401610eb9565b90509250929050565b600060208083528351808285015260005b81811015610f3057858101830151858201604001528201610f14565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215610f6357600080fd5b610a3182610eb9565b600060208284031215610f7e57600080fd5b815160ff81168114610a3157600080fd5b80516001600160501b038116811461097a57600080fd5b600080600080600060a08688031215610fbe57600080fd5b610fc786610f8f565b9450602086015193506040860151925060608601519150610fea60808701610f8f565b90509295509295909350565b634e487b7160e01b600052601160045260246000fd5b6001600160501b0382811682821603908082111561102c5761102c610ff6565b5092915050565b81810381811115610a3457610a34610ff6565b8082028115828204841417610a3457610a34610ff6565b60008261107a57634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156110ba5781600019048211156110a0576110a0610ff6565b808516156110ad57918102915b93841c9390800290611084565b509250929050565b6000826110d157506001610a34565b816110de57506000610a34565b81600181146110f457600281146110fe5761111a565b6001915050610a34565b60ff84111561110f5761110f610ff6565b50506001821b610a34565b5060208310610133831016604e8410600b841016171561113d575081810a610a34565b611147838361107f565b806000190482111561115b5761115b610ff6565b029392505050565b6000610a3183836110c256fea264697066735822122001009bba11d0396e6ace2f028614dc7f72a0d919338e760a544930daa4b324f064736f6c63430008130033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0xD5 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x86800A96 GT PUSH2 0x87 JUMPI DUP1 PUSH4 0x86800A96 EQ PUSH2 0x163 JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x16B JUMPI DUP1 PUSH4 0x90107AFE EQ PUSH2 0x17C JUMPI DUP1 PUSH4 0xA20BAEE6 EQ PUSH2 0x18F JUMPI DUP1 PUSH4 0xA3F4DF7E EQ PUSH2 0x19E JUMPI DUP1 PUSH4 0xC8E07115 EQ PUSH2 0x1D3 JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0x1E6 JUMPI DUP1 PUSH4 0xF56F48F2 EQ PUSH2 0x1F9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x490BE83 EQ PUSH2 0xDA JUMPI DUP1 PUSH4 0xFDB11CF EQ PUSH2 0xF6 JUMPI DUP1 PUSH4 0x1BE5C92F EQ PUSH2 0xFE JUMPI DUP1 PUSH4 0x200D2ED2 EQ PUSH2 0x106 JUMPI DUP1 PUSH4 0x45079CB4 EQ PUSH2 0x120 JUMPI DUP1 PUSH4 0x715018A6 EQ PUSH2 0x12E JUMPI DUP1 PUSH4 0x836EFD31 EQ PUSH2 0x138 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xE3 PUSH1 0x3 SLOAD DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xE3 PUSH2 0x201 JUMP JUMPDEST PUSH2 0xE3 PUSH1 0x12 DUP2 JUMP JUMPDEST PUSH1 0x4 SLOAD PUSH2 0x113 SWAP1 PUSH1 0xFF AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xED SWAP2 SWAP1 PUSH2 0xE91 JUMP JUMPDEST PUSH2 0xE3 PUSH7 0xB1A2BC2EC50000 DUP2 JUMP JUMPDEST PUSH2 0x136 PUSH2 0x66A JUMP JUMPDEST STOP JUMPDEST PUSH1 0x2 SLOAD PUSH2 0x14B SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0xED JUMP JUMPDEST PUSH2 0xE3 PUSH1 0xB0 DUP2 JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH2 0x14B JUMP JUMPDEST PUSH2 0x136 PUSH2 0x18A CALLDATASIZE PUSH1 0x4 PUSH2 0xED0 JUMP JUMPDEST PUSH2 0x67E JUMP JUMPDEST PUSH2 0xE3 PUSH8 0xDE0B6B3A7640000 DUP2 JUMP JUMPDEST PUSH2 0x1C6 PUSH1 0x40 MLOAD DUP1 PUSH1 0x40 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x9 DUP2 MSTORE PUSH1 0x20 ADD PUSH9 0x141C9A58D951995959 PUSH1 0xBA SHL DUP2 MSTORE POP DUP2 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xED SWAP2 SWAP1 PUSH2 0xF03 JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH2 0x14B SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND DUP2 JUMP JUMPDEST PUSH2 0x136 PUSH2 0x1F4 CALLDATASIZE PUSH1 0x4 PUSH2 0xF51 JUMP JUMPDEST PUSH2 0x7A3 JUMP JUMPDEST PUSH2 0xE3 PUSH1 0x45 DUP2 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x313CE567 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x257 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x27B SWAP2 SWAP1 PUSH2 0xF6C JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x287 PUSH2 0x821 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x298 DUP3 PUSH1 0x40 ADD MLOAD PUSH2 0x8C4 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x2A4 PUSH2 0x97F JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x2B5 DUP3 PUSH1 0x40 ADD MLOAD PUSH2 0x9F3 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x313CE567 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x30C JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x330 SWAP2 SWAP1 PUSH2 0xF6C JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x34B JUMPI PUSH2 0x34B PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x454 JUMPI PUSH2 0x35A DUP6 DUP6 PUSH2 0xA17 JUMP JUMPDEST ISZERO PUSH2 0x3BC JUMPI PUSH2 0x368 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x385 JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x38E DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x39D JUMPI PUSH2 0x377 PUSH1 0x1 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3A7 PUSH1 0x1 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3B1 DUP4 DUP3 PUSH2 0xB0B JUMP JUMPDEST SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x3C5 DUP6 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x408 JUMPI PUSH2 0x3D3 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x3E2 JUMPI PUSH2 0x377 PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3EC PUSH1 0x3 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3F5 DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x3A7 JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x413 DUP6 DUP6 DUP9 PUSH2 0xB2A JUMP JUMPDEST ISZERO PUSH2 0x432 JUMPI PUSH2 0x421 DUP4 PUSH2 0xA3A JUMP JUMPDEST DUP1 PUSH2 0x368 JUMPI POP PUSH2 0x368 DUP4 DUP4 DUP4 PUSH2 0xB2A JUMP JUMPDEST PUSH2 0x43B DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x44A JUMPI PUSH2 0x44A PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3B1 DUP6 DUP8 PUSH2 0xB0B JUMP JUMPDEST PUSH1 0x1 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x46D JUMPI PUSH2 0x46D PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x4DC JUMPI PUSH2 0x47F DUP6 DUP6 DUP6 DUP10 DUP6 PUSH2 0xBA9 JUMP JUMPDEST ISZERO PUSH2 0x48E JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x497 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x4A6 JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x4AF DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x4C2 JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x4CD DUP4 DUP4 DUP4 PUSH2 0xB2A JUMP JUMPDEST ISZERO PUSH2 0x3A7 JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x2 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x4F5 JUMPI PUSH2 0x4F5 PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x516 JUMPI PUSH2 0x507 DUP6 DUP6 DUP6 DUP10 DUP6 PUSH2 0xBA9 JUMP JUMPDEST ISZERO PUSH2 0x377 JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x3 PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND SWAP1 DUP2 GT ISZERO PUSH2 0x52F JUMPI PUSH2 0x52F PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x5DA JUMPI PUSH2 0x53E DUP6 DUP6 PUSH2 0xA17 JUMP JUMPDEST ISZERO PUSH2 0x565 JUMPI PUSH2 0x54C DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x55B JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x3EC PUSH1 0x1 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x56E DUP6 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x58B JUMPI PUSH2 0x57C DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x3EC JUMPI PUSH2 0x377 PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x594 DUP4 PUSH2 0xA3A JUMP JUMPDEST ISZERO PUSH2 0x5A3 JUMPI PUSH2 0x44A PUSH1 0x4 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x5AC DUP4 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x5BF JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x5CB DUP6 DUP5 DUP9 DUP5 PUSH2 0xC07 JUMP JUMPDEST ISZERO PUSH2 0x39D JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF AND DUP2 DUP2 GT ISZERO PUSH2 0x5F1 JUMPI PUSH2 0x5F1 PUSH2 0xE7B JUMP JUMPDEST SUB PUSH2 0x661 JUMPI PUSH2 0x600 DUP6 DUP6 PUSH2 0xA17 JUMP JUMPDEST ISZERO PUSH2 0x60F JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x618 DUP6 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x62B JUMPI PUSH1 0x3 SLOAD SWAP7 POP POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x638 DUP6 DUP6 DUP6 DUP10 DUP6 PUSH2 0xBA9 JUMP JUMPDEST ISZERO PUSH2 0x647 JUMPI PUSH2 0x44A PUSH1 0x0 PUSH2 0xA8A JUMP JUMPDEST PUSH2 0x652 DUP6 DUP6 DUP9 PUSH2 0xB2A JUMP JUMPDEST ISZERO PUSH2 0x44A JUMPI PUSH2 0x377 PUSH1 0x2 PUSH2 0xA8A JUMP JUMPDEST POP POP POP POP POP POP SWAP1 JUMP JUMPDEST PUSH2 0x672 PUSH2 0xC90 JUMP JUMPDEST PUSH2 0x67C PUSH1 0x0 PUSH2 0xCEA JUMP JUMPDEST JUMP JUMPDEST PUSH2 0x686 PUSH2 0xC90 JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT SWAP3 DUP4 AND OR SWAP1 SWAP3 SSTORE PUSH1 0x2 DUP1 SLOAD SWAP3 DUP5 AND SWAP3 SWAP1 SWAP2 AND SWAP2 SWAP1 SWAP2 OR SWAP1 SSTORE PUSH1 0x4 DUP1 SLOAD PUSH1 0xFF NOT AND SWAP1 SSTORE PUSH1 0x0 PUSH2 0x6CA PUSH2 0x821 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x6DB DUP3 PUSH1 0x40 ADD MLOAD PUSH2 0x8C4 JUMP JUMPDEST SWAP1 POP PUSH2 0x6E7 DUP3 DUP3 PUSH2 0xA17 JUMP JUMPDEST DUP1 PUSH2 0x6F6 JUMPI POP PUSH2 0x6F6 DUP3 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0x714 JUMPI PUSH1 0x40 MLOAD PUSH4 0x62A7741 PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x794 DUP3 PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x313CE567 PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x76B JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x78F SWAP2 SWAP1 PUSH2 0xF6C JUMP JUMPDEST PUSH2 0xB0B JUMP JUMPDEST POP PUSH2 0x79D PUSH2 0x66A JUMP JUMPDEST POP POP POP POP JUMP JUMPDEST PUSH2 0x7AB PUSH2 0xC90 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND PUSH2 0x815 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x26 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4F776E61626C653A206E6577206F776E657220697320746865207A65726F2061 PUSH1 0x44 DUP3 ADD MSTORE PUSH6 0x646472657373 PUSH1 0xD0 SHL PUSH1 0x64 DUP3 ADD MSTORE PUSH1 0x84 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x81E DUP2 PUSH2 0xCEA JUMP JUMPDEST POP JUMP JUMPDEST PUSH2 0x829 PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xFEAF968C PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0xA0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL SWAP3 POP POP POP DUP1 ISZERO PUSH2 0x898 JUMPI POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x1F RETURNDATASIZE SWAP1 DUP2 ADD PUSH1 0x1F NOT AND DUP3 ADD SWAP1 SWAP3 MSTORE PUSH2 0x895 SWAP2 DUP2 ADD SWAP1 PUSH2 0xFA6 JUMP JUMPDEST PUSH1 0x1 JUMPDEST PUSH2 0x89F JUMPI SWAP1 JUMP JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB SWAP1 SWAP4 AND PUSH1 0x40 DUP6 ADD MSTORE POP DUP3 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND PUSH1 0x20 DUP3 ADD MSTORE SWAP1 JUMP JUMPDEST PUSH2 0x8CC PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 PUSH4 0x9A6FC8F5 SWAP1 PUSH2 0x8EA SWAP1 DUP6 PUSH2 0x100C JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT PUSH1 0xE0 DUP5 SWAP1 SHL AND DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB SWAP1 SWAP2 AND PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x24 ADD PUSH1 0xA0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL SWAP3 POP POP POP DUP1 ISZERO PUSH2 0x94A JUMPI POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x1F RETURNDATASIZE SWAP1 DUP2 ADD PUSH1 0x1F NOT AND DUP3 ADD SWAP1 SWAP3 MSTORE PUSH2 0x947 SWAP2 DUP2 ADD SWAP1 PUSH2 0xFA6 JUMP JUMPDEST PUSH1 0x1 JUMPDEST PUSH2 0x953 JUMPI SWAP2 SWAP1 POP JUMP JUMPDEST POP PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB SWAP1 SWAP4 AND PUSH1 0x40 DUP6 ADD MSTORE POP DUP3 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND PUSH1 0x20 DUP3 ADD MSTORE SWAP2 SWAP1 POP JUMP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0x987 PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0xFEAF968C PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0xA0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 GAS STATICCALL SWAP3 POP POP POP DUP1 ISZERO PUSH2 0x898 JUMPI POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x1F RETURNDATASIZE SWAP1 DUP2 ADD PUSH1 0x1F NOT AND DUP3 ADD SWAP1 SWAP3 MSTORE PUSH2 0x895 SWAP2 DUP2 ADD SWAP1 PUSH2 0xFA6 JUMP JUMPDEST PUSH2 0x9FB PUSH2 0xE5B JUMP JUMPDEST PUSH1 0x2 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH4 0x9A6FC8F5 PUSH2 0x8EA PUSH1 0x1 DUP6 PUSH2 0x100C JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA22 DUP4 PUSH2 0xD3A JUMP JUMPDEST DUP1 PUSH2 0xA31 JUMPI POP PUSH2 0xA31 DUP3 PUSH2 0xD3A JUMP JUMPDEST SWAP1 POP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND PUSH1 0x0 EQ DUP1 PUSH2 0xA64 JUMPI POP NUMBER DUP3 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND GT JUMPDEST ISZERO PUSH2 0xA71 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST DUP2 MLOAD PUSH1 0x0 SUB PUSH2 0xA82 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST POP PUSH1 0x0 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x4 DUP1 SLOAD DUP3 SWAP2 SWAP1 PUSH1 0xFF NOT AND PUSH1 0x1 DUP4 DUP4 DUP2 GT ISZERO PUSH2 0xAA8 JUMPI PUSH2 0xAA8 PUSH2 0xE7B JUMP JUMPDEST MUL OR SWAP1 SSTORE POP PUSH32 0x5C57579A8214FE4F710C1C56FA829F045B9FA6D225A744225A30C32188064D4E DUP2 PUSH1 0x40 MLOAD PUSH2 0xADC SWAP2 SWAP1 PUSH2 0xE91 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x45 DUP3 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND NUMBER PUSH2 0xB04 SWAP2 SWAP1 PUSH2 0x1033 JUMP JUMPDEST GT SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xB1F DUP5 PUSH1 0x0 ADD MLOAD DUP5 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH2 0xA31 DUP2 PUSH2 0xE00 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xB3E DUP6 PUSH1 0x0 ADD MLOAD DUP5 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB53 DUP6 PUSH1 0x0 ADD MLOAD DUP6 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB61 DUP4 DUP4 PUSH2 0xE35 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB6F DUP5 DUP5 PUSH2 0xE4B JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xB7D DUP4 DUP4 PUSH2 0x1033 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0x3E8 PUSH2 0xB8F PUSH1 0xB0 DUP6 PUSH2 0x1046 JUMP JUMPDEST PUSH2 0xB99 SWAP2 SWAP1 PUSH2 0x105D JUMP JUMPDEST SWAP1 SWAP2 GT SWAP10 SWAP9 POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xBB4 DUP5 PUSH2 0xA3A JUMP JUMPDEST DUP1 PUSH2 0xBC3 JUMPI POP PUSH2 0xBC3 DUP5 PUSH2 0xAE7 JUMP JUMPDEST DUP1 PUSH2 0xBD3 JUMPI POP PUSH2 0xBD3 DUP7 DUP7 PUSH2 0xA17 JUMP JUMPDEST DUP1 PUSH2 0xBE2 JUMPI POP PUSH2 0xBE2 DUP7 PUSH2 0xAE7 JUMP JUMPDEST ISZERO PUSH2 0xBEF JUMPI POP PUSH1 0x0 PUSH2 0xBFE JUMP JUMPDEST PUSH2 0xBFB DUP7 DUP6 DUP6 DUP6 PUSH2 0xC07 JUMP JUMPDEST SWAP1 POP JUMPDEST SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH2 0xC1B DUP7 PUSH1 0x0 ADD MLOAD DUP6 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xC30 DUP7 PUSH1 0x0 ADD MLOAD DUP6 PUSH1 0xFF AND PUSH2 0xD9D JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xC3E DUP3 DUP5 PUSH2 0xE35 JUMP JUMPDEST SWAP1 POP PUSH1 0x0 PUSH2 0xC4C DUP4 DUP6 PUSH2 0xE4B JUMP JUMPDEST SWAP1 POP PUSH1 0x0 DUP3 PUSH8 0xDE0B6B3A7640000 PUSH2 0xC64 DUP3 DUP6 PUSH2 0x1033 JUMP JUMPDEST PUSH2 0xC6E SWAP2 SWAP1 PUSH2 0x1046 JUMP JUMPDEST PUSH2 0xC78 SWAP2 SWAP1 PUSH2 0x105D JUMP JUMPDEST PUSH7 0xB1A2BC2EC50000 LT ISZERO SWAP11 SWAP10 POP POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND CALLER EQ PUSH2 0x67C JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD DUP2 SWAP1 MSTORE PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4F776E61626C653A2063616C6C6572206973206E6F7420746865206F776E6572 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x80C JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT DUP4 AND DUP2 OR DUP5 SSTORE PUSH1 0x40 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP3 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x40 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB AND PUSH1 0x0 SUB PUSH2 0xD59 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x20 DUP3 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND ISZERO DUP1 PUSH2 0xD7F JUMPI POP NUMBER DUP3 PUSH1 0x20 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND GT JUMPDEST ISZERO PUSH2 0xD8C JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST DUP2 MLOAD PUSH1 0x0 SLT PUSH2 0xA82 JUMPI POP PUSH1 0x1 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x12 DUP4 LT PUSH2 0xDCF JUMPI PUSH2 0xDB3 PUSH1 0x12 DUP5 PUSH2 0x1033 JUMP JUMPDEST PUSH2 0xDBE SWAP1 PUSH1 0xA PUSH2 0x1163 JUMP JUMPDEST PUSH2 0xDC8 SWAP1 DUP6 PUSH2 0x105D JUMP JUMPDEST SWAP1 POP PUSH2 0xA31 JUMP JUMPDEST PUSH1 0x12 DUP4 LT ISZERO PUSH2 0xA31 JUMPI PUSH2 0xDE3 DUP4 PUSH1 0x12 PUSH2 0x1033 JUMP JUMPDEST PUSH2 0xDEE SWAP1 PUSH1 0xA PUSH2 0x1163 JUMP JUMPDEST PUSH2 0xDF8 SWAP1 DUP6 PUSH2 0x1046 JUMP JUMPDEST SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x3 DUP2 SWAP1 SSTORE PUSH1 0x40 MLOAD DUP2 DUP2 MSTORE PUSH32 0x4D29DE21DE555AF78A62FC82DD4BC05E9AE5B0660A37F04729527E0F22780CD3 SWAP1 PUSH1 0x20 ADD PUSH2 0xADC JUMP JUMPDEST PUSH1 0x0 DUP2 DUP4 LT PUSH2 0xE44 JUMPI DUP2 PUSH2 0xA31 JUMP JUMPDEST POP SWAP1 SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 DUP4 LT ISZERO PUSH2 0xE44 JUMPI DUP2 PUSH2 0xA31 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x60 DUP2 ADD DUP3 MSTORE PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD DUP2 SWAP1 MSTORE SWAP2 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x21 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x20 DUP2 ADD PUSH1 0x5 DUP4 LT PUSH2 0xEB3 JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x21 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST SWAP2 SWAP1 MSTORE SWAP1 JUMP JUMPDEST DUP1 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x97A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xEE3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xEEC DUP4 PUSH2 0xEB9 JUMP JUMPDEST SWAP2 POP PUSH2 0xEFA PUSH1 0x20 DUP5 ADD PUSH2 0xEB9 JUMP JUMPDEST SWAP1 POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP1 DUP4 MSTORE DUP4 MLOAD DUP1 DUP3 DUP6 ADD MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0xF30 JUMPI DUP6 DUP2 ADD DUP4 ADD MLOAD DUP6 DUP3 ADD PUSH1 0x40 ADD MSTORE DUP3 ADD PUSH2 0xF14 JUMP JUMPDEST POP PUSH1 0x0 PUSH1 0x40 DUP3 DUP7 ADD ADD MSTORE PUSH1 0x40 PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND DUP6 ADD ADD SWAP3 POP POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xF63 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xA31 DUP3 PUSH2 0xEB9 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xF7E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 MLOAD PUSH1 0xFF DUP2 AND DUP2 EQ PUSH2 0xA31 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x97A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0xA0 DUP7 DUP9 SUB SLT ISZERO PUSH2 0xFBE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xFC7 DUP7 PUSH2 0xF8F JUMP JUMPDEST SWAP5 POP PUSH1 0x20 DUP7 ADD MLOAD SWAP4 POP PUSH1 0x40 DUP7 ADD MLOAD SWAP3 POP PUSH1 0x60 DUP7 ADD MLOAD SWAP2 POP PUSH2 0xFEA PUSH1 0x80 DUP8 ADD PUSH2 0xF8F JUMP JUMPDEST SWAP1 POP SWAP3 SWAP6 POP SWAP3 SWAP6 SWAP1 SWAP4 POP JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0x50 SHL SUB DUP3 DUP2 AND DUP3 DUP3 AND SUB SWAP1 DUP1 DUP3 GT ISZERO PUSH2 0x102C JUMPI PUSH2 0x102C PUSH2 0xFF6 JUMP JUMPDEST POP SWAP3 SWAP2 POP POP JUMP JUMPDEST DUP2 DUP2 SUB DUP2 DUP2 GT ISZERO PUSH2 0xA34 JUMPI PUSH2 0xA34 PUSH2 0xFF6 JUMP JUMPDEST DUP1 DUP3 MUL DUP2 ISZERO DUP3 DUP3 DIV DUP5 EQ OR PUSH2 0xA34 JUMPI PUSH2 0xA34 PUSH2 0xFF6 JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH2 0x107A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x12 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST POP DIV SWAP1 JUMP JUMPDEST PUSH1 0x1 DUP2 DUP2 JUMPDEST DUP1 DUP6 GT ISZERO PUSH2 0x10BA JUMPI DUP2 PUSH1 0x0 NOT DIV DUP3 GT ISZERO PUSH2 0x10A0 JUMPI PUSH2 0x10A0 PUSH2 0xFF6 JUMP JUMPDEST DUP1 DUP6 AND ISZERO PUSH2 0x10AD JUMPI SWAP2 DUP2 MUL SWAP2 JUMPDEST SWAP4 DUP5 SHR SWAP4 SWAP1 DUP1 MUL SWAP1 PUSH2 0x1084 JUMP JUMPDEST POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH2 0x10D1 JUMPI POP PUSH1 0x1 PUSH2 0xA34 JUMP JUMPDEST DUP2 PUSH2 0x10DE JUMPI POP PUSH1 0x0 PUSH2 0xA34 JUMP JUMPDEST DUP2 PUSH1 0x1 DUP2 EQ PUSH2 0x10F4 JUMPI PUSH1 0x2 DUP2 EQ PUSH2 0x10FE JUMPI PUSH2 0x111A JUMP JUMPDEST PUSH1 0x1 SWAP2 POP POP PUSH2 0xA34 JUMP JUMPDEST PUSH1 0xFF DUP5 GT ISZERO PUSH2 0x110F JUMPI PUSH2 0x110F PUSH2 0xFF6 JUMP JUMPDEST POP POP PUSH1 0x1 DUP3 SHL PUSH2 0xA34 JUMP JUMPDEST POP PUSH1 0x20 DUP4 LT PUSH2 0x133 DUP4 LT AND PUSH1 0x4E DUP5 LT PUSH1 0xB DUP5 LT AND OR ISZERO PUSH2 0x113D JUMPI POP DUP2 DUP2 EXP PUSH2 0xA34 JUMP JUMPDEST PUSH2 0x1147 DUP4 DUP4 PUSH2 0x107F JUMP JUMPDEST DUP1 PUSH1 0x0 NOT DIV DUP3 GT ISZERO PUSH2 0x115B JUMPI PUSH2 0x115B PUSH2 0xFF6 JUMP JUMPDEST MUL SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA31 DUP4 DUP4 PUSH2 0x10C2 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 ADD STOP SWAP12 0xBA GT 0xD0 CODECOPY PUSH15 0x6ACE2F028614DC7F72A0D919338E76 EXP SLOAD 0x49 ADDRESS 0xDA LOG4 0xB3 0x24 CREATE PUSH5 0x736F6C6343 STOP ADDMOD SGT STOP CALLER ",
          "sourceMap": "744:25942:18:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1863:28;;;;;;;;;160:25:42;;;148:2;133:18;1863:28:18;;;;;;;;4098:11979;;;:::i;960:39::-;;997:2;960:39;;2290:20;;;;;;;;;;;;;;;;:::i;1727:64::-;;1787:4;1727:64;;1824:101:2;;;:::i;:::-;;902:34:18;;;;;-1:-1:-1;;;;;902:34:18;;;;;;-1:-1:-1;;;;;860:32:42;;;842:51;;830:2;815:18;902:34:18;672:227:42;1448:85:18;;1530:3;1448:85;;1201::2;1247:7;1273:6;-1:-1:-1;;;;;1273:6:2;1201:85;;2458:1041:18;;;;;;:::i;:::-;;:::i;81:45:21:-;;122:4;81:45;;790:41:18;;;;;;;;;;;;;;;-1:-1:-1;;;790:41:18;;;;;;;;;;;;:::i;838:32::-;;;;;-1:-1:-1;;;;;838:32:18;;;2074:198:2;;;;;;:::i;:::-;;:::i;1139:33:18:-;;1170:2;1139:33;;4098:11979;4138:7;4257:14;4274:10;;;;;;;;;-1:-1:-1;;;;;4274:10:18;-1:-1:-1;;;;;4274:19:18;;:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;4257:38;;4306:34;4343:31;:29;:31::i;:::-;4306:68;;4384:38;4425:72;4461:18;:26;;;4425:22;:72::i;:::-;4384:113;;4507:36;4546:27;:25;:27::i;:::-;4507:66;;4583:40;4626:80;4668:20;:28;;;4626;:80::i;:::-;4583:123;;4716:20;4739:12;;;;;;;;;-1:-1:-1;;;;;4739:12:18;-1:-1:-1;;;;;4739:21:18;;:23;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;4716:46;-1:-1:-1;4858:24:18;4848:6;;;;;;:34;;;;;;;:::i;:::-;;4844:3614;;4972:63;4992:18;5012:22;4972:19;:63::i;:::-;4951:1002;;;5174:43;5196:20;5174:21;:43::i;:::-;5170:174;;;5241:42;5255:27;5241:13;:42::i;:::-;5312:13;;5305:20;;;;;;;;4098:11979;:::o;5170:174::-;5512:37;5528:20;5512:15;:37::i;:::-;5508:172;;;5573:46;5587:31;5573:13;:46::i;5508:172::-;5814:46;5828:31;5814:13;:46::i;:::-;5885:53;5901:20;5923:14;5885:15;:53::i;:::-;5878:60;;;;;;;;4098:11979;:::o;4951:1002::-;6023:39;6043:18;6023:19;:39::i;:::-;6019:760;;;6180:43;6202:20;6180:21;:43::i;:::-;6176:178;;;6247:46;6261:31;6247:13;:46::i;6176:178::-;6472:43;6486:28;6472:13;:43::i;:::-;6538:37;6554:20;6538:15;:37::i;:::-;6534:104;;;6606:13;;6599:20;;;;;;;;4098:11979;:::o;6019:760::-;6933:152;6975:18;7015:22;7059:8;6933:20;:152::i;:::-;6912:1146;;;7238:43;7260:20;7238:21;:43::i;:::-;:245;;;;7305:178;7351:20;7397:24;7447:14;7305:20;:178::i;6912:1146::-;8165:43;8187:20;8165:21;:43::i;:::-;8161:128;;;8228:46;8242:31;8228:13;:46::i;:::-;8402:45;8418:18;8438:8;8402:15;:45::i;4844:3614::-;8551:31;8541:6;;;;;;:41;;;;;;;:::i;:::-;;8537:1554;;8735:252;8799:18;8839:22;8883:20;8925:8;8955:14;8735:42;:252::i;:::-;8714:430;;;9020:39;9034:24;9020:13;:39::i;8714:430::-;9162:43;9184:20;9162:21;:43::i;:::-;9158:162;;;9225:42;9239:27;9225:13;:42::i;9158:162::-;9546:37;9562:20;9546:15;:37::i;:::-;9542:96;;;9610:13;;9603:20;;;;;;;;4098:11979;:::o;9542:96::-;9673:162;9715:20;9757:24;9803:14;9673:20;:162::i;:::-;9652:311;;;9868:42;9882:27;9868:13;:42::i;8537:1554::-;10194:27;10184:6;;;;;;:37;;;;;;;:::i;:::-;;10180:842;;10461:252;10525:18;10565:22;10609:20;10651:8;10681:14;10461:42;:252::i;:::-;10440:430;;;10746:39;10760:24;10746:13;:39::i;10180:842::-;11113:28;11103:6;;;;;;:38;;;;;;;:::i;:::-;;11099:3005;;11178:63;11198:18;11218:22;11178:19;:63::i;:::-;11157:794;;;11348:43;11370:20;11348:21;:43::i;:::-;11344:174;;;11415:42;11429:27;11415:13;:42::i;11344:174::-;11620:46;11634:31;11620:13;:46::i;11157:794::-;11969:39;11989:18;11969:19;:39::i;:::-;11965:738;;;12148:43;12170:20;12148:21;:43::i;:::-;12144:178;;;12215:46;12229:31;12215:13;:46::i;11965:738::-;12833:43;12855:20;12833:21;:43::i;:::-;12829:198;;;12896:46;12910:31;12896:13;:46::i;12829:198::-;13187:37;13203:20;13187:15;:37::i;:::-;13183:96;;;13251:13;;13244:20;;;;;;;;4098:11979;:::o;13183:96::-;13483:190;13529:18;13569:20;13611:8;13641:14;13483:24;:190::i;:::-;13462:368;;;13706:39;13720:24;13706:13;:39::i;11099:3005::-;14195:31;14185:6;;;;:41;;;;;;;;:::i;:::-;;14181:1890;;14332:63;14352:18;14372:22;14332:19;:63::i;:::-;14311:212;;;14428:42;14442:27;14428:13;:42::i;14311:212::-;14624:39;14644:18;14624:19;:39::i;:::-;14620:98;;;14690:13;;14683:20;;;;;;;;4098:11979;:::o;14620:98::-;14900:252;14964:18;15004:22;15048:20;15090:8;15120:14;14900:42;:252::i;:::-;14879:430;;;15185:39;15199:24;15185:13;:39::i;14879:430::-;15531:152;15573:18;15613:22;15657:8;15531:20;:152::i;:::-;15510:301;;;15716:42;15730:27;15716:13;:42::i;14181:1890::-;4147:11930;;;;;;4098:11979;:::o;1824:101:2:-;1094:13;:11;:13::i;:::-;1888:30:::1;1915:1;1888:18;:30::i;:::-;1824:101::o:0;2458:1041:18:-;1094:13:2;:11;:13::i;:::-;2688:10:18::1;:47:::0;;-1:-1:-1;;;;;2688:47:18;;::::1;-1:-1:-1::0;;;;;;2688:47:18;;::::1;;::::0;;;2745:12:::1;:51:::0;;;;::::1;::::0;;;::::1;::::0;;;::::1;::::0;;2855:6:::1;:33:::0;;-1:-1:-1;;2855:33:18::1;::::0;;-1:-1:-1;3031:31:18::1;:29;:31::i;:::-;2994:68;;3072:38;3113:72;3149:18;:26;;;3113:22;:72::i;:::-;3072:113;;3213:63;3233:18;3253:22;3213:19;:63::i;:::-;:118;;;;3292:39;3312:18;3292:19;:39::i;:::-;3196:198;;;3363:20;;-1:-1:-1::0;;;3363:20:18::1;;;;;;;;;;;3196:198;3404:58;3420:18;3440:10;;;;;;;;;-1:-1:-1::0;;;;;3440:10:18::1;-1:-1:-1::0;;;;;3440:19:18::1;;:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3404:15;:58::i;:::-;;3473:19;:17;:19::i;:::-;2579:920;;2458:1041:::0;;:::o;2074:198:2:-;1094:13;:11;:13::i;:::-;-1:-1:-1;;;;;2162:22:2;::::1;2154:73;;;::::0;-1:-1:-1;;;2154:73:2;;2779:2:42;2154:73:2::1;::::0;::::1;2761:21:42::0;2818:2;2798:18;;;2791:30;2857:34;2837:18;;;2830:62;-1:-1:-1;;;2908:18:42;;;2901:36;2954:19;;2154:73:2::1;;;;;;;;;2237:28;2256:8;2237:18;:28::i;:::-;2074:198:::0;:::o;23051:663:18:-;23139:24;;:::i;:::-;23224:10;;;;;;;;;-1:-1:-1;;;;;23224:10:18;-1:-1:-1;;;;;23224:26:18;;:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;23224:28:18;;;;;;;;-1:-1:-1;;23224:28:18;;;;;;;;;;;;:::i;:::-;;;23220:488;;23051:663;:::o;23220:488::-;-1:-1:-1;;;;;;23440:26:18;;;:16;;;:26;-1:-1:-1;23480:24:18;;-1:-1:-1;;;;;23518:45:18;:20;;;:45;23440:8;23051:663::o;24402:1128::-;24495:38;;:::i;:::-;24871:10;;;-1:-1:-1;;;;;24871:10:18;;:23;;24895:19;;:15;:19;:::i;:::-;24871:44;;-1:-1:-1;;;;;;24871:44:18;;;;;;;-1:-1:-1;;;;;4132:35:42;;;24871:44:18;;;4114:54:42;4087:18;;24871:44:18;;;;;;;;;;;;;;;;;;-1:-1:-1;24871:44:18;;;;;;;;-1:-1:-1;;24871:44:18;;;;;;;;;;;;:::i;:::-;;;24867:657;;24402:1128;;;:::o;24867:657::-;-1:-1:-1;;;;;;25187:40:18;;;:30;;;:40;-1:-1:-1;25241:38:18;;-1:-1:-1;;;;;25293:59:18;:34;;;:59;25187:22;24402:1128;-1:-1:-1;24402:1128:18:o;24867:657::-;24402:1128;;;:::o;23720:676::-;23804:24;;:::i;:::-;23889:12;;;;;;;;;-1:-1:-1;;;;;23889:12:18;-1:-1:-1;;;;;23889:28:18;;:30;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;23889:30:18;;;;;;;;-1:-1:-1;;23889:30:18;;;;;;;;;;;;:::i;25536:1148::-;25635:40;;:::i;:::-;26013:12;;-1:-1:-1;;;;;26013:12:18;:25;26039:19;26013:12;26039:15;:19;:::i;16542:274::-;16681:4;16716:40;16739:16;16716:22;:40::i;:::-;:93;;;;16772:37;16795:13;16772:22;:37::i;:::-;16697:112;;16542:274;;;;;:::o;18751:444::-;18846:4;18949:9;:21;;;-1:-1:-1;;;;;18949:26:18;18974:1;18949:26;:66;;;;19003:12;18979:9;:21;;;-1:-1:-1;;;;;18979:36:18;;18949:66;18932:130;;;-1:-1:-1;19047:4:18;;18751:444;-1:-1:-1;18751:444:18:o;18932:130::-;19107:16;;;:21;19103:63;;-1:-1:-1;19151:4:18;;18751:444;-1:-1:-1;18751:444:18:o;19103:63::-;-1:-1:-1;19183:5:18;;18751:444;-1:-1:-1;18751:444:18:o;22454:127::-;22512:6;:16;;22521:7;;22512:6;-1:-1:-1;;22512:16:18;;22521:7;22512:16;;;;;;;;:::i;:::-;;;;;;22543:31;22566:7;22543:31;;;;;;:::i;:::-;;;;;;;;22454:127;:::o;19201:177::-;19296:4;1170:2;19334:15;:27;;;-1:-1:-1;;;;;19319:42:18;:12;:42;;;;:::i;:::-;:52;;19201:177;-1:-1:-1;;19201:177:18:o;22739:306::-;22848:4;22864:16;22883:91;22924:9;:16;;;22955:9;22883:91;;:19;:91::i;:::-;22864:110;;22985:24;22997:11;22985;:24::i;17581:1164::-;17746:4;17762:23;17788:98;17829:16;:23;;;17867:9;17788:98;;:19;:98::i;:::-;17762:124;;17896:20;17919:95;17960:13;:20;;;17995:9;17919:95;;:19;:95::i;:::-;17896:118;;18025:13;18041:53;18058:18;18078:15;18041:16;:53::i;:::-;18025:69;;18104:13;18120:53;18137:18;18157:15;18120:16;:53::i;:::-;18104:69;-1:-1:-1;18454:15:18;18472:19;18483:8;18104:69;18472:19;:::i;:::-;18454:37;-1:-1:-1;18501:14:18;18596:4;18519:73;1530:3;18519:8;:73;:::i;:::-;18518:82;;;;:::i;:::-;18716:22;;;;17581:1164;-1:-1:-1;;;;;;;;;17581:1164:18:o;19384:873::-;19672:4;19766:38;19788:15;19766:21;:38::i;:::-;:86;;;;19820:32;19836:15;19820;:32::i;:::-;19766:167;;;;19868:65;19888:19;19909:23;19868:19;:65::i;:::-;19766:223;;;;19949:40;19969:19;19949;:40::i;:::-;19749:288;;;-1:-1:-1;20021:5:18;20014:12;;19749:288;20066:184;20108:19;20145:15;20178:19;20215:21;20066:24;:184::i;:::-;20047:203;;19384:873;;;;;;;;:::o;20263:1350::-;20484:4;20500:26;20529:111;20570:19;:26;;;20611:19;20529:111;;:19;:111::i;:::-;20500:140;;20650:22;20675:109;20716:15;:22;;;20753:21;20675:109;;:19;:109::i;:::-;20650:134;;20941:13;20957:92;20987:17;21018:21;20957:16;:92::i;:::-;20941:108;;21059:13;21075:92;21105:17;21136:21;21075:16;:92::i;:::-;21059:108;-1:-1:-1;21177:27:18;21265:8;122:4:21;21209:19:18;21265:8;21059:108;21209:19;:::i;:::-;21208:53;;;;:::i;:::-;21207:66;;;;:::i;:::-;1787:4;-1:-1:-1;21544:62:18;;20263:1350;-1:-1:-1;;;;;;;;;;20263:1350:18:o;1359:130:2:-;1247:7;1273:6;-1:-1:-1;;;;;1273:6:2;719:10:7;1422:23:2;1414:68;;;;-1:-1:-1;;;1414:68:2;;4909:2:42;1414:68:2;;;4891:21:42;;;4928:18;;;4921:30;4987:34;4967:18;;;4960:62;5039:18;;1414:68:2;4707:356:42;2426:187:2;2499:16;2518:6;;-1:-1:-1;;;;;2534:17:2;;;-1:-1:-1;;;;;;2534:17:2;;;;;;2566:40;;2518:6;;;;;;;2566:40;;2499:16;2566:40;2489:124;2426:187;:::o;16822:576:18:-;16918:4;16988:9;:17;;;-1:-1:-1;;;;;16988:22:18;17009:1;16988:22;16984:64;;-1:-1:-1;17033:4:18;;16822:576;-1:-1:-1;16822:576:18:o;16984:64::-;17144:21;;;;-1:-1:-1;;;;;17144:26:18;;;:66;;;17198:12;17174:9;:21;;;-1:-1:-1;;;;;17174:36:18;;17144:66;17127:130;;;-1:-1:-1;17242:4:18;;16822:576;-1:-1:-1;16822:576:18:o;17127:130::-;17310:16;;17330:1;-1:-1:-1;17306:63:18;;-1:-1:-1;17354:4:18;;16822:576;-1:-1:-1;16822:576:18:o;21619:829::-;21726:4;21999:10;997:2;22023:13;:30;22019:401;;22176:29;997:2;22176:13;:29;:::i;:::-;22169:37;;:2;:37;:::i;:::-;22159:48;;:6;:48;:::i;:::-;22151:56;;22019:401;;;997:2;22228:13;:29;22224:196;;;22378:29;22394:13;997:2;22378:29;:::i;:::-;22371:37;;:2;:37;:::i;:::-;22361:48;;:6;:48;:::i;:::-;22353:56;21619:829;-1:-1:-1;;;;21619:829:18:o;22587:146::-;22647:13;:29;;;22691:35;;160:25:42;;;22691:35:18;;148:2:42;133:18;22691:35:18;14:177:42;963:104:25;1018:4;1047:2;1042;:7;1041:19;;1058:2;1041:19;;;-1:-1:-1;1053:2:25;;963:104;-1:-1:-1;963:104:25:o;1073:105::-;1128:4;1158:2;1152;:8;;1151:20;;1169:2;1151:20;;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;196:127:42:-;257:10;252:3;248:20;245:1;238:31;288:4;285:1;278:15;312:4;309:1;302:15;328:339;471:2;456:18;;504:1;493:13;;483:144;;549:10;544:3;540:20;537:1;530:31;584:4;581:1;574:15;612:4;609:1;602:15;483:144;636:25;;;328:339;:::o;1112:173::-;1180:20;;-1:-1:-1;;;;;1229:31:42;;1219:42;;1209:70;;1275:1;1272;1265:12;1290:260;1358:6;1366;1419:2;1407:9;1398:7;1394:23;1390:32;1387:52;;;1435:1;1432;1425:12;1387:52;1458:29;1477:9;1458:29;:::i;:::-;1448:39;;1506:38;1540:2;1529:9;1525:18;1506:38;:::i;:::-;1496:48;;1290:260;;;;;:::o;1555:548::-;1667:4;1696:2;1725;1714:9;1707:21;1757:6;1751:13;1800:6;1795:2;1784:9;1780:18;1773:34;1825:1;1835:140;1849:6;1846:1;1843:13;1835:140;;;1944:14;;;1940:23;;1934:30;1910:17;;;1929:2;1906:26;1899:66;1864:10;;1835:140;;;1839:3;2024:1;2019:2;2010:6;1999:9;1995:22;1991:31;1984:42;2094:2;2087;2083:7;2078:2;2070:6;2066:15;2062:29;2051:9;2047:45;2043:54;2035:62;;;;1555:548;;;;:::o;2108:186::-;2167:6;2220:2;2208:9;2199:7;2195:23;2191:32;2188:52;;;2236:1;2233;2226:12;2188:52;2259:29;2278:9;2259:29;:::i;2299:273::-;2367:6;2420:2;2408:9;2399:7;2395:23;2391:32;2388:52;;;2436:1;2433;2426:12;2388:52;2468:9;2462:16;2518:4;2511:5;2507:16;2500:5;2497:27;2487:55;;2538:1;2535;2528:12;2984:179;3062:13;;-1:-1:-1;;;;;3104:34:42;;3094:45;;3084:73;;3153:1;3150;3143:12;3168:473;3271:6;3279;3287;3295;3303;3356:3;3344:9;3335:7;3331:23;3327:33;3324:53;;;3373:1;3370;3363:12;3324:53;3396:39;3425:9;3396:39;:::i;:::-;3386:49;;3475:2;3464:9;3460:18;3454:25;3444:35;;3519:2;3508:9;3504:18;3498:25;3488:35;;3563:2;3552:9;3548:18;3542:25;3532:35;;3586:49;3630:3;3619:9;3615:19;3586:49;:::i;:::-;3576:59;;3168:473;;;;;;;;:::o;3646:127::-;3707:10;3702:3;3698:20;3695:1;3688:31;3738:4;3735:1;3728:15;3762:4;3759:1;3752:15;3778:187;-1:-1:-1;;;;;3901:10:42;;;3889;;;3885:27;;3924:12;;;3921:38;;;3939:18;;:::i;:::-;3921:38;3778:187;;;;:::o;4179:128::-;4246:9;;;4267:11;;;4264:37;;;4281:18;;:::i;4312:168::-;4385:9;;;4416;;4433:15;;;4427:22;;4413:37;4403:71;;4454:18;;:::i;4485:217::-;4525:1;4551;4541:132;;4595:10;4590:3;4586:20;4583:1;4576:31;4630:4;4627:1;4620:15;4658:4;4655:1;4648:15;4541:132;-1:-1:-1;4687:9:42;;4485:217::o;5068:422::-;5157:1;5200:5;5157:1;5214:270;5235:7;5225:8;5222:21;5214:270;;;5294:4;5290:1;5286:6;5282:17;5276:4;5273:27;5270:53;;;5303:18;;:::i;:::-;5353:7;5343:8;5339:22;5336:55;;;5373:16;;;;5336:55;5452:22;;;;5412:15;;;;5214:270;;;5218:3;5068:422;;;;;:::o;5495:806::-;5544:5;5574:8;5564:80;;-1:-1:-1;5615:1:42;5629:5;;5564:80;5663:4;5653:76;;-1:-1:-1;5700:1:42;5714:5;;5653:76;5745:4;5763:1;5758:59;;;;5831:1;5826:130;;;;5738:218;;5758:59;5788:1;5779:10;;5802:5;;;5826:130;5863:3;5853:8;5850:17;5847:43;;;5870:18;;:::i;:::-;-1:-1:-1;;5926:1:42;5912:16;;5941:5;;5738:218;;6040:2;6030:8;6027:16;6021:3;6015:4;6012:13;6008:36;6002:2;5992:8;5989:16;5984:2;5978:4;5975:12;5971:35;5968:77;5965:159;;;-1:-1:-1;6077:19:42;;;6109:5;;5965:159;6156:34;6181:8;6175:4;6156:34;:::i;:::-;6226:6;6222:1;6218:6;6214:19;6205:7;6202:32;6199:58;;;6237:18;;:::i;:::-;6275:20;;5495:806;-1:-1:-1;;;5495:806:42:o;6306:131::-;6366:5;6395:36;6422:8;6416:4;6395:36;:::i"
        },
        "gasEstimates": {
          "creation": {
            "codeDepositCost": "903400",
            "executionCost": "26783",
            "totalCost": "930183"
          },
          "external": {
            "DECIMAL_PRECISION()": "250",
            "MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND()": "184",
            "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES()": "273",
            "NAME()": "infinite",
            "TARGET_DIGITS()": "229",
            "TIMEOUT()": "338",
            "backupOracle()": "2470",
            "fetchPrice()": "infinite",
            "lastGoodPrice()": "2285",
            "mainOracle()": "2447",
            "owner()": "2353",
            "renounceOwnership()": "infinite",
            "setAddresses(address,address)": "infinite",
            "status()": "2418",
            "transferOwnership(address)": "28469"
          },
          "internal": {
            "_backupIsFrozen(struct PriceFeed.Response memory)": "infinite",
            "_backupOracleIsBroken(struct PriceFeed.Response memory)": "infinite",
            "_badMainOracleResponse(struct PriceFeed.Response memory)": "infinite",
            "_bothOraclesLiveAndUnbrokenAndSimilarPrice(struct PriceFeed.Response memory,struct PriceFeed.Response memory,struct PriceFeed.Response memory,uint8,uint8)": "infinite",
            "_bothOraclesSimilarPrice(struct PriceFeed.Response memory,struct PriceFeed.Response memory,uint8,uint8)": "infinite",
            "_changeStatus(enum PriceFeed.Status)": "infinite",
            "_getCurrentBackupResponse()": "infinite",
            "_getCurrentMainOracleResponse()": "infinite",
            "_getPrevBackupOracleResponse(uint80)": "infinite",
            "_getPrevOracleResponse(uint80)": "infinite",
            "_mainOracleIsBroken(struct PriceFeed.Response memory,struct PriceFeed.Response memory)": "infinite",
            "_mainOracleIsFrozen(struct PriceFeed.Response memory)": "infinite",
            "_priceChangeAboveMax(struct PriceFeed.Response memory,struct PriceFeed.Response memory,uint8)": "infinite",
            "_scalePriceByDigits(uint256,uint256)": "infinite",
            "_storeGoodPrice(struct PriceFeed.Response memory,uint8)": "infinite",
            "_storePrice(uint256)": "infinite"
          }
        },
        "methodIdentifiers": {
          "DECIMAL_PRECISION()": "a20baee6",
          "MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND()": "86800a96",
          "MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES()": "45079cb4",
          "NAME()": "a3f4df7e",
          "TARGET_DIGITS()": "1be5c92f",
          "TIMEOUT()": "f56f48f2",
          "backupOracle()": "836efd31",
          "fetchPrice()": "0fdb11cf",
          "lastGoodPrice()": "0490be83",
          "mainOracle()": "c8e07115",
          "owner()": "8da5cb5b",
          "renounceOwnership()": "715018a6",
          "setAddresses(address,address)": "90107afe",
          "status()": "200d2ed2",
          "transferOwnership(address)": "f2fde38b"
        }
      },
      "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MainOracleDisabled\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastGoodPrice\",\"type\":\"uint256\"}],\"name\":\"LastGoodPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum PriceFeed.Status\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"PriceFeedStatusChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TARGET_DIGITS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backupOracle\",\"outputs\":[{\"internalType\":\"contract IBaseFeeOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastGoodPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainOracle\",\"outputs\":[{\"internalType\":\"contract IBaseFeeOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mainOracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_backupOracleAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum PriceFeed.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PriceFeed.sol\":\"PriceFeed\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"contracts/PriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/IBaseFeeOracle.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./dependencies/BaseMath.sol\\\";\\nimport \\\"./dependencies/LiquityMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nerror MainOracleDisabled();\\n\\n/*\\n * PriceFeed for production deployment, to be connected to Main Oracle's live BaseFee:WstETH aggregator reference\\n * contract, and a Backup oracle contract.\\n *\\n * The PriceFeed uses \\\"Main Oracle\\\" as primary oracle, and \\\"Back Up\\\" as fallback. It contains logic for\\n * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\\n * \\\"Main Oracle\\\" oracle.\\n *\\n * Based on Liquity Protocol.\\n */\\ncontract PriceFeed is Ownable, BaseMath {\\n    string public constant NAME = \\\"PriceFeed\\\";\\n\\n    IBaseFeeOracle public mainOracle; // Main Oracle aggregator\\n    IBaseFeeOracle public backupOracle; // Backup Oracle\\n\\n    uint public constant TARGET_DIGITS = 18;\\n\\n    // Maximum time period allowed since Main Oracle's latest round data blockNumber, beyond which Main Oracle is considered frozen.\\n    uint public constant TIMEOUT = 69;\\n\\n    // HEDGEHOG UPDATES: decrease to 176\\n    // Maximum deviation allowed between two consecutive Main oracle prices. Hedgehog oracles are getting updated in case there is a 5% diviation price\\n    // Meaning that there might be max 17.5% price diviation between rounds\\n    uint public constant MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND =\\n        176;\\n\\n    /*\\n     * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\\n     * to return to using the Main oracle. 18-digit precision.\\n     */\\n    uint public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\\n\\n    // The last good price seen from an oracle by Hedgehog\\n    uint256 public lastGoodPrice;\\n\\n    struct Response {\\n        int256 answer;\\n        uint64 blockNumber;\\n        uint80 roundId;\\n    }\\n\\n    enum Status {\\n        mainOracleWorking,\\n        usingBackupMainUntrusted,\\n        bothOraclesUntrusted,\\n        usingBackupMainFrozen,\\n        usingMainBackupUntrusted\\n    }\\n\\n    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt\\n    Status public status;\\n\\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\\n    event PriceFeedStatusChanged(Status newStatus);\\n\\n    // --- Dependency setters ---\\n\\n    function setAddresses(\\n        address _mainOracleAddress,\\n        address _backupOracleAddress\\n    ) external onlyOwner {\\n        Address.isContract(_mainOracleAddress);\\n        Address.isContract(_backupOracleAddress);\\n\\n        mainOracle = IBaseFeeOracle(_mainOracleAddress);\\n        backupOracle = IBaseFeeOracle(_backupOracleAddress);\\n\\n        // Explicitly set initial system status\\n        status = Status.mainOracleWorking;\\n\\n        // Get an initial price from Main Oracle to serve as first reference for lastGoodPrice\\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\\n            mainOracleResponse.roundId\\n        );\\n\\n        if (\\n            _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse) ||\\n            _mainOracleIsFrozen(mainOracleResponse)\\n        ) {\\n            revert MainOracleDisabled();\\n        }\\n\\n        _storeGoodPrice(mainOracleResponse, mainOracle.decimals());\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Functions ---\\n\\n    /*\\n     * fetchPrice():\\n     * Returns the latest price obtained from the Oracle. Called by Hedgehog functions that require a current price.\\n     *\\n     * Also callable by anyone externally.\\n     *\\n     * Non-view function - it stores the last good price seen by Hedgehog.\\n     *\\n     * Uses a main oracle and a fallback oracle in case main one fails. If both fail,\\n     * it uses the last good price seen by Hedgehog.\\n     *\\n     * Hedgehog updates: now both oracles are not allowed to have a price diviation of more then 12.5% between consecutive block\\n     */\\n    function fetchPrice() external returns (uint256) {\\n        // Get current and previous price data from Main oracle, and current price data from Backup\\n        uint8 decimals = mainOracle.decimals();\\n\\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\\n            mainOracleResponse.roundId\\n        );\\n        Response memory backupOracleResponse = _getCurrentBackupResponse();\\n        Response memory prevBackupOracleResponse = _getPrevBackupOracleResponse(\\n            backupOracleResponse.roundId\\n        );\\n        uint8 backupDecimals = backupOracle.decimals();\\n\\n        // --- CASE 1: System fetched last price from Main Oracle  ---\\n        if (status == Status.mainOracleWorking) {\\n            // If Main Oracle is broken, try backup\\n\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                // If backup is broken then both oracles are untrusted, so return the last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n                /*\\n                 * If Backup is only frozen but otherwise returning valid data, return the last good price.\\n                 */\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    _changeStatus(Status.usingBackupMainUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Main Oracle is broken and Backup is working, switch to Backup and return current Backup price\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If Main oracle is frozen, try Backup\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                // If Backup is broken too, remember Backup broke, and return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.usingMainBackupUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is frozen or working, remember Main Oracle froze, and switch to backup\\n                _changeStatus(Status.usingBackupMainFrozen);\\n\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is working, use it\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If MainOracle price has changed by > 12,5% between two consecutive rounds, compare it to Backup's price\\n            if (\\n                _priceChangeAboveMax(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    decimals\\n                )\\n            ) {\\n                // If Backup is broken, both oracles are untrusted, and return last good price\\n                if (\\n                    _backupOracleIsBroken(backupOracleResponse) ||\\n                    _priceChangeAboveMax(\\n                        backupOracleResponse,\\n                        prevBackupOracleResponse,\\n                        backupDecimals\\n                    )\\n                ) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If backup is frozen, switch to backup and return last good price\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    _changeStatus(Status.usingBackupMainUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If Main oracle is working and Backup is broken, remember Backup is broken\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.usingMainBackupUntrusted);\\n            }\\n\\n            // If MainOracle is working, return MainOracle current price (no status change)\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n\\n        // --- CASE 2: The system fetched last price from Backup ---\\n        if (status == Status.usingBackupMainUntrusted) {\\n            // If both Backup and Main oracle are live, unbroken, and reporting similar prices, switch back to Main\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            /*\\n             * If Backup is only frozen but otherwise returning valid data, just return the last good price.\\n             * Backup may need to be tipped to return current data.\\n             */\\n            if (_backupIsFrozen(backupOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            if (\\n                _priceChangeAboveMax(\\n                    backupOracleResponse,\\n                    prevBackupOracleResponse,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // Otherwise, use Backup price\\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n        }\\n\\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\\n        if (status == Status.bothOraclesUntrusted) {\\n            /*\\n             * If both oracles are now live, unbroken and similar price, we assume that they are reporting\\n             * accurately, and so we switch back to Main Oracle.\\n             */\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\\n            return lastGoodPrice;\\n        }\\n\\n        // --- CASE 4: Using Backup, and Main Oracle is frozen ---\\n        if (status == Status.usingBackupMainFrozen) {\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                // If both Oracles are broken, return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Main Oracle is broken, remember it and switch to using Backup\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is working, return Backup current price\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                // if Main Oracle is frozen and Backup is broken, remember Backup broke, and return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.usingMainBackupUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If both are frozen, just use lastGoodPrice\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // if Main Oracle is frozen and Backup is working, keep using Backup (no status change)\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // if Main Oracle is live and Backup is broken, remember Backup broke, and return Main Oracle price\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.usingMainBackupUntrusted);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // If Main Oracle is live and Backup is frozen, just use last good price (no status change) since we have no basis for comparison\\n            if (_backupIsFrozen(backupOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle is live and Backup is working, compare prices. Switch to Main Oracle\\n            // if prices are within 5%, and return Main Oracle price.\\n            if (\\n                _bothOraclesSimilarPrice(\\n                    mainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // Otherwise if Main Oracle is live but price not within 5% of Backup, distrust Main Oracle, and return Backup price\\n            _changeStatus(Status.usingBackupMainUntrusted);\\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n        }\\n\\n        // --- CASE 5: Using Main Oracle, Back up is untrusted ---\\n        if (status == Status.usingMainBackupUntrusted) {\\n            // If Main Oracle breaks, now both oracles are untrusted\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle is frozen, return last good price (no status change)\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle and Backup are both live, unbroken and similar price, switch back to Main Oracle working and return MainOracle price\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // If Main Oracle is live but deviated >17.5% from it's previous price and Backup is still untrusted, switch\\n            // to bothOraclesUntrusted and return last good price\\n            if (\\n                _priceChangeAboveMax(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    decimals\\n                )\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // Otherwise if Main Oracle is live and deviated <17.5% from it's previous price and Backup is still untrusted,\\n            // return Main Oracle price (no status change)\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n    }\\n\\n    // --- Helper functions ---\\n\\n    /* Main Oracle is considered broken if its current or previous round data is in any way bad. We check the previous round\\n     * for two reasons:\\n     *\\n     * 1) It is necessary data for the price deviation check in case 1,\\n     * and\\n     * 2) Main Oracle is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\\n     * peace of mind when using or returning to Main Oracle.\\n     */\\n    function _mainOracleIsBroken(\\n        Response memory _currentResponse,\\n        Response memory _prevResponse\\n    ) internal view returns (bool) {\\n        return\\n            _badMainOracleResponse(_currentResponse) ||\\n            _badMainOracleResponse(_prevResponse);\\n    }\\n\\n    function _badMainOracleResponse(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        // Check for an invalid roundId that is 0\\n        if (_response.roundId == 0) {\\n            return true;\\n        }\\n        // Check for an invalid timeStamp that is 0, or in the future\\n        if (\\n            _response.blockNumber == 0 || _response.blockNumber > block.number\\n        ) {\\n            return true;\\n        }\\n        // Check for non-positive price\\n        if (_response.answer <= 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _mainOracleIsFrozen(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        return (block.number - _response.blockNumber) > TIMEOUT;\\n    }\\n\\n    function _priceChangeAboveMax(\\n        Response memory _currentResponse,\\n        Response memory _prevResponse,\\n        uint8 _decimals\\n    ) internal pure returns (bool) {\\n        uint currentScaledPrice = _scalePriceByDigits(\\n            uint256(_currentResponse.answer),\\n            _decimals\\n        );\\n        uint prevScaledPrice = _scalePriceByDigits(\\n            uint256(_prevResponse.answer),\\n            _decimals\\n        );\\n\\n        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);\\n        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);\\n\\n        /*\\n         * Use the larger price as the denominator:\\n         * - If price decreased, the percentage deviation is in relation to the the previous price.\\n         * - If price increased, the percentage deviation is in relation to the current price.\\n         */\\n        uint difference = maxPrice - minPrice;\\n        uint threshold = (maxPrice *\\n            MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND) / 1000; // 17.5% of max price\\n\\n        // Return true if price has more than doubled, or more than halved.\\n        return difference > threshold;\\n    }\\n\\n    function _backupOracleIsBroken(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        // Check for an invalid timeStamp that is 0, or in the future\\n        if (\\n            _response.blockNumber == 0 || _response.blockNumber > block.number\\n        ) {\\n            return true;\\n        }\\n        // Check for zero price\\n        if (_response.answer == 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _backupIsFrozen(\\n        Response memory _backupResponse\\n    ) internal view returns (bool) {\\n        return block.number - _backupResponse.blockNumber > TIMEOUT;\\n    }\\n\\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n        Response memory _mainOracleResponse,\\n        Response memory _prevMainOracleResponse,\\n        Response memory _backupResponse,\\n        uint8 _mainOracleDecimals,\\n        uint8 _backupOracleDecimals\\n    ) internal view returns (bool) {\\n        // Return false if either oracle is broken or frozen\\n        if (\\n            _backupOracleIsBroken(_backupResponse) ||\\n            _backupIsFrozen(_backupResponse) ||\\n            _mainOracleIsBroken(_mainOracleResponse, _prevMainOracleResponse) ||\\n            _mainOracleIsFrozen(_mainOracleResponse)\\n        ) {\\n            return false;\\n        }\\n\\n        return\\n            _bothOraclesSimilarPrice(\\n                _mainOracleResponse,\\n                _backupResponse,\\n                _mainOracleDecimals,\\n                _backupOracleDecimals\\n            );\\n    }\\n\\n    function _bothOraclesSimilarPrice(\\n        Response memory _mainOracleResponse,\\n        Response memory _backupResponse,\\n        uint8 _mainOracleDecimals,\\n        uint8 _backupOracleDecimals\\n    ) internal pure returns (bool) {\\n        uint scaledMainOraclePrice = _scalePriceByDigits(\\n            uint256(_mainOracleResponse.answer),\\n            _mainOracleDecimals\\n        );\\n        uint scaledBackupPrice = _scalePriceByDigits(\\n            uint256(_backupResponse.answer),\\n            _backupOracleDecimals\\n        );\\n\\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\\n        uint minPrice = LiquityMath._min(\\n            scaledBackupPrice,\\n            scaledMainOraclePrice\\n        );\\n        uint maxPrice = LiquityMath._max(\\n            scaledBackupPrice,\\n            scaledMainOraclePrice\\n        );\\n        uint percentPriceDifference = ((maxPrice - minPrice) *\\n            DECIMAL_PRECISION) / minPrice;\\n\\n        /*\\n         * Return true if the relative price difference is <= 5%: if so, we assume both oracles are probably reporting\\n         * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\\n         */\\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\\n    }\\n\\n    function _scalePriceByDigits(\\n        uint _price,\\n        uint _answerDigits\\n    ) internal pure returns (uint) {\\n        /*\\n         * Convert the price returned by an oracle to an 18-digit decimal for use by Hedgehog.\\n         * At date of Hedgehog launch, MaainOracle uses an 8-digit price, but we also handle the possibility of\\n         * future changes.\\n         */\\n        uint price;\\n        if (_answerDigits >= TARGET_DIGITS) {\\n            // Scale the returned price value down to Hedgehog's target precision\\n            price = _price / (10 ** (_answerDigits - TARGET_DIGITS));\\n        } else if (_answerDigits < TARGET_DIGITS) {\\n            // Scale the returned price value up to Hedgehog's target precision\\n            price = _price * (10 ** (TARGET_DIGITS - _answerDigits));\\n        }\\n        return price;\\n    }\\n\\n    function _changeStatus(Status _status) internal {\\n        status = _status;\\n        emit PriceFeedStatusChanged(_status);\\n    }\\n\\n    function _storePrice(uint _currentPrice) internal {\\n        lastGoodPrice = _currentPrice;\\n        emit LastGoodPriceUpdated(_currentPrice);\\n    }\\n\\n    function _storeGoodPrice(\\n        Response memory _response,\\n        uint8 _decimals\\n    ) internal returns (uint) {\\n        uint scaledPrice = _scalePriceByDigits(\\n            uint256(_response.answer),\\n            _decimals\\n        );\\n\\n        _storePrice(scaledPrice);\\n\\n        return scaledPrice;\\n    }\\n\\n    function _getCurrentMainOracleResponse()\\n        internal\\n        view\\n        returns (Response memory response)\\n    {\\n        // Try to get latest price data:\\n        try mainOracle.latestRoundData() returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            response.roundId = roundId;\\n            response.answer = answer;\\n            response.blockNumber = uint64(currentChainBN);\\n\\n            return response;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts\\n            return response;\\n        }\\n    }\\n\\n    function _getCurrentBackupResponse()\\n        internal\\n        view\\n        returns (Response memory response)\\n    {\\n        // Try to get latest price data:\\n        try backupOracle.latestRoundData() returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            response.roundId = roundId;\\n            response.answer = answer;\\n            response.blockNumber = uint64(currentChainBN);\\n\\n            return response;\\n        } catch {\\n            // If call to Backup aggregator reverts with empty response\\n            return response;\\n        }\\n    }\\n\\n    function _getPrevOracleResponse(\\n        uint80 _currentRoundId\\n    ) internal view returns (Response memory prevMainOracleResponse) {\\n        /*\\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\\n         */\\n\\n        // Try to get the price data from the previous round:\\n        try mainOracle.getRoundData(_currentRoundId - 1) returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            // If call to Hedgehog succeeds, return the response and success = true\\n            prevMainOracleResponse.roundId = roundId;\\n            prevMainOracleResponse.answer = answer;\\n            prevMainOracleResponse.blockNumber = uint64(currentChainBN);\\n            return prevMainOracleResponse;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts\\n            return prevMainOracleResponse;\\n        }\\n    }\\n\\n    function _getPrevBackupOracleResponse(\\n        uint80 _currentRoundId\\n    ) internal view returns (Response memory prevBackupOracleResponse) {\\n        /*\\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\\n         */\\n\\n        // Try to get the price data from the previous round:\\n        try backupOracle.getRoundData(_currentRoundId - 1) returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            // If call to Hedgehog succeeds, return the response and success = true\\n            prevBackupOracleResponse.roundId = roundId;\\n            prevBackupOracleResponse.answer = answer;\\n            prevBackupOracleResponse.blockNumber = uint64(currentChainBN);\\n            return prevBackupOracleResponse;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts\\n            return prevBackupOracleResponse;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x427557e16f3c2f9f92971dd7662b3c3615420654be4a8bbb29a9cde6f856bdce\",\"license\":\"MIT\"},\"contracts/dependencies/BaseMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ncontract BaseMath {\\n    uint public constant DECIMAL_PRECISION = 1e18;\\n}\\n\",\"keccak256\":\"0x5338502be04e32035bbf0310600c8724281edc81b312f5d89c683b23d0bb3fa7\",\"license\":\"MIT\"},\"contracts/dependencies/LiquityMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @notice A fork of Liquity Math library with an upgraded pragma\\n *\\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\\n */\\n\\nlibrary LiquityMath {\\n    using SafeMath for uint;\\n\\n    uint internal constant DECIMAL_PRECISION = 1e18;\\n\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n     *\\n     * - Making it \\u201ctoo high\\u201d could lead to overflows.\\n     * - Making it \\u201ctoo low\\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\n     *\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 WStETH,\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n     *\\n     */\\n    uint internal constant NICR_PRECISION = 1e20;\\n\\n    function _min(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a < _b) ? _a : _b;\\n    }\\n\\n    function _max(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a >= _b) ? _a : _b;\\n    }\\n\\n    /*\\n     * Multiply two decimal numbers and use normal rounding rules:\\n     * -round product up if 19'th mantissa digit >= 5\\n     * -round product down if 19'th mantissa digit < 5\\n     *\\n     * Used only inside the exponentiation, _decPow().\\n     */\\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\\n        uint prod_xy = x.mul(y);\\n\\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\\n    }\\n\\n    /*\\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n     *\\n     * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\n     *\\n     * Called by two functions that represent time in units of minutes:\\n     * 1) TroveManager._calcDecayedBaseRate\\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\\n     *\\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n     * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n     *\\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n     * negligibly different from just passing the cap, since:\\n     *\\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n     */\\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\\n        if (_minutes > 525600000) {\\n            _minutes = 525600000;\\n        } // cap to avoid overflow\\n\\n        if (_minutes == 0) {\\n            return DECIMAL_PRECISION;\\n        }\\n\\n        uint y = DECIMAL_PRECISION;\\n        uint x = _base;\\n        uint n = _minutes;\\n\\n        // Exponentiation-by-squaring\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x = decMul(x, x);\\n                n = n.div(2);\\n            } else {\\n                // if (n % 2 != 0)\\n                y = decMul(x, y);\\n                x = decMul(x, x);\\n                n = (n.sub(1)).div(2);\\n            }\\n        }\\n\\n        return decMul(x, y);\\n    }\\n\\n    function _getAbsoluteDifference(\\n        uint _a,\\n        uint _b\\n    ) internal pure returns (uint) {\\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\\n    }\\n\\n    function _computeNominalCR(\\n        uint _coll,\\n        uint _debt\\n    ) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            return _coll.mul(NICR_PRECISION).div(_debt);\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return 2 ** 256 - 1;\\n        }\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * Change coll ration calculation from [coll] * [price] / [debt] to\\n     * [coll] / [debt] / [gasPrice]\\n     */\\n    function _computeCR(\\n        uint _coll,\\n        uint _debt,\\n        uint _price\\n    ) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            uint newCollRatio = _coll\\n                .mul(DECIMAL_PRECISION)\\n                .div(_debt)\\n                .mul(DECIMAL_PRECISION)\\n                .div(_price);\\n\\n            return newCollRatio;\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return 2 ** 256 - 1;\\n        }\\n    }\\n\\n    function _findPriceBelowMCR(\\n        uint256 _coll,\\n        uint256 _debt,\\n        uint _mcr\\n    ) internal pure returns (uint256 price) {\\n        // Finds an exact price at which CR becomes MCR. Liqudation does not happen in the event of them being equal, hence we add 1 to it to find closest liqudation price\\n        price = ((_coll * DECIMAL_PRECISION) / _debt / _mcr) + 1;\\n    }\\n}\\n\",\"keccak256\":\"0x8a9d92c8aa28cfbdae16a8fbae6e1d809c03d60f90b25e7869ef17ca622cdec0\",\"license\":\"MIT\"},\"contracts/interfaces/IBaseFeeOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IBaseFeeOracle {\\n    function decimals() external view returns (uint8);\\n\\n    function version() external view returns (uint256);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(\\n        uint80 _roundId\\n    )\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        );\\n}\\n\",\"keccak256\":\"0x1ac6a2d44d00a27b0bd047860a900b756909cae25e87cbcba42c7e4d71a7b565\",\"license\":\"MIT\"}},\"version\":1}",
      "storageLayout": {
        "storage": [
          {
            "astId": 396,
            "contract": "contracts/PriceFeed.sol:PriceFeed",
            "label": "_owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 5896,
            "contract": "contracts/PriceFeed.sol:PriceFeed",
            "label": "mainOracle",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IBaseFeeOracle)14928"
          },
          {
            "astId": 5899,
            "contract": "contracts/PriceFeed.sol:PriceFeed",
            "label": "backupOracle",
            "offset": 0,
            "slot": "2",
            "type": "t_contract(IBaseFeeOracle)14928"
          },
          {
            "astId": 5913,
            "contract": "contracts/PriceFeed.sol:PriceFeed",
            "label": "lastGoodPrice",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 5929,
            "contract": "contracts/PriceFeed.sol:PriceFeed",
            "label": "status",
            "offset": 0,
            "slot": "4",
            "type": "t_enum(Status)5926"
          }
        ],
        "types": {
          "t_address": {
            "encoding": "inplace",
            "label": "address",
            "numberOfBytes": "20"
          },
          "t_contract(IBaseFeeOracle)14928": {
            "encoding": "inplace",
            "label": "contract IBaseFeeOracle",
            "numberOfBytes": "20"
          },
          "t_enum(Status)5926": {
            "encoding": "inplace",
            "label": "enum PriceFeed.Status",
            "numberOfBytes": "1"
          },
          "t_uint256": {
            "encoding": "inplace",
            "label": "uint256",
            "numberOfBytes": "32"
          }
        }
      },
      "userdoc": {
        "kind": "user",
        "methods": {},
        "version": 1
      },
      "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Address.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Context.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\n    },\n    \"contracts/BorrowerOperations.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/ITroveManager.sol\\\";\\nimport \\\"./interfaces/IBaseFeeLMAToken.sol\\\";\\nimport \\\"./interfaces/ICollSurplusPool.sol\\\";\\nimport \\\"./interfaces/ISortedTroves.sol\\\";\\nimport \\\"./interfaces/IFeesRouter.sol\\\";\\nimport \\\"./dependencies/HedgehogBase.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./dependencies/CheckContract.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nerror TroveAdjustedThisBlock();\\n\\n/**\\n * @notice Fork of Liquity's BorrowerOperations. . Most of the Logic remains unchanged..\\n * Changes to the contract:\\n * - Raised pragma version\\n * - Removed an import of IBorrowerOperations Interface\\n * - Collateral is now an ERC20 token instead of a native one\\n * - Updated variable names and docs to refer to BaseFeeLMA token and wwstETH as a collateral\\n * - Logic updates with borrowing fees calculation and their distribution\\n * - Removed Native Liquity Protocol Token Staking\\n * - Remove _getUSDValue view method as it's not used anymore\\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\\n */\\n\\ncontract BorrowerOperations is HedgehogBase, Ownable, CheckContract {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    string public constant NAME = \\\"BorrowerOperations\\\";\\n\\n    // --- Connected contract declarations ---\\n\\n    ITroveManager public troveManager;\\n\\n    address stabilityPoolAddress;\\n\\n    address gasPoolAddress;\\n\\n    IERC20 WStETHToken;\\n\\n    ICollSurplusPool collSurplusPool;\\n\\n    IFeesRouter public feesRouter;\\n\\n    IBaseFeeLMAToken baseFeeLMAToken;\\n\\n    // A doubly linked list of Troves, sorted by their collateral ratios\\n    ISortedTroves public sortedTroves;\\n\\n    /* --- Variable container structs  ---\\n\\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\\n    \\\"CompilerError: Stack too deep\\\". */\\n\\n    struct LocalVariables_adjustTrove {\\n        uint price;\\n        uint collChange;\\n        uint netDebtChange;\\n        bool isCollIncrease;\\n        uint debt;\\n        uint coll;\\n        uint oldICR;\\n        uint newICR;\\n        uint newTCR;\\n        uint BaseFeeLMAFee;\\n        uint newDebt;\\n        uint newColl;\\n        uint stake;\\n    }\\n\\n    struct LocalVariables_openTrove {\\n        uint price;\\n        uint BaseFeeLMAFee;\\n        uint netDebt;\\n        uint compositeDebt;\\n        uint ICR;\\n        uint NICR;\\n        uint stake;\\n        uint arrayIndex;\\n    }\\n\\n    struct ContractsCache {\\n        ITroveManager troveManager;\\n        IActivePool activePool;\\n        IBaseFeeLMAToken baseFeeLMAToken;\\n    }\\n\\n    enum BorrowerOperation {\\n        openTrove,\\n        closeTrove,\\n        adjustTrove\\n    }\\n\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event BaseFeeLMATokenAddressChanged(address _BaseFeeLMATokenAddress);\\n    event WStETHTokenAddressUpdated(IERC20 _WStEthAddress);\\n    event FeesRouterAddressUpdated(IFeesRouter _feesRouter);\\n\\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint stake,\\n        BorrowerOperation operation\\n    );\\n    event BaseFeeLMABorrowingFeePaid(\\n        address indexed _borrower,\\n        uint _BaseFeeLMAFee\\n    );\\n\\n    // --- Dependency setters ---\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral instead of native token.\\n     * Setting erc20 address in the initialisation\\n     */\\n    function setAddresses(\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _sortedTrovesAddress,\\n        address _baseFeeLMATokenAddress,\\n        IERC20 _wStETHTokenAddress,\\n        IFeesRouter _feesRouter\\n    ) external onlyOwner {\\n        // This makes impossible to open a trove with zero withdrawn BaseFeeLMA\\n        assert(MIN_NET_DEBT > 0);\\n\\n        checkContract(_troveManagerAddress);\\n        checkContract(_activePoolAddress);\\n        checkContract(_defaultPoolAddress);\\n        checkContract(_stabilityPoolAddress);\\n        checkContract(_gasPoolAddress);\\n        checkContract(_collSurplusPoolAddress);\\n        checkContract(_priceFeedAddress);\\n        checkContract(_sortedTrovesAddress);\\n        checkContract(_baseFeeLMATokenAddress);\\n        checkContract(address(_wStETHTokenAddress));\\n        checkContract(address(_feesRouter));\\n\\n        troveManager = ITroveManager(_troveManagerAddress);\\n        activePool = IActivePool(_activePoolAddress);\\n        defaultPool = IDefaultPool(_defaultPoolAddress);\\n        stabilityPoolAddress = _stabilityPoolAddress;\\n        gasPoolAddress = _gasPoolAddress;\\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\n        baseFeeLMAToken = IBaseFeeLMAToken(_baseFeeLMATokenAddress);\\n        WStETHToken = _wStETHTokenAddress;\\n        feesRouter = _feesRouter;\\n\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\n        emit ActivePoolAddressChanged(_activePoolAddress);\\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\\n        emit GasPoolAddressChanged(_gasPoolAddress);\\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\\n        emit PriceFeedAddressChanged(_priceFeedAddress);\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\n        emit BaseFeeLMATokenAddressChanged(_baseFeeLMATokenAddress);\\n        emit WStETHTokenAddressUpdated(_wStETHTokenAddress);\\n        emit FeesRouterAddressUpdated(_feesRouter);\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Borrower Trove Operations ---\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral, therefore function may not rely on msg.value anymore\\n     * now passing a new param _collAmount\\n     * checking if _amount is greater then 0\\n     * Function is no longer payable\\n     */\\n    function openTrove(\\n        uint _maxFeePercentage,\\n        uint _BaseFeeLMAAmount,\\n        uint _collAmount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external {\\n        // Hedgehog Updates: Check that trove[msg.sender] did not perform adjustTrove transactions in the current block\\n        {\\n            _checkAndSetUpdateBlock(msg.sender);\\n        }\\n        ContractsCache memory contractsCache = ContractsCache(\\n            troveManager,\\n            activePool,\\n            baseFeeLMAToken\\n        );\\n        LocalVariables_openTrove memory vars;\\n\\n        vars.price = priceFeed.fetchPrice();\\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\\n\\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\\n\\n        vars.BaseFeeLMAFee;\\n        vars.netDebt = _BaseFeeLMAAmount;\\n\\n        // HEDGEHOG UPDATES: Triggering borrowing fee in both recovery and normal modes\\n        vars.BaseFeeLMAFee = _triggerBorrowingFee(\\n            contractsCache.troveManager,\\n            _BaseFeeLMAAmount,\\n            _maxFeePercentage\\n        );\\n        _requireAtLeastMinNetDebt(vars.netDebt);\\n\\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\\n        assert(vars.compositeDebt > 0);\\n\\n        vars.ICR = LiquityMath._computeCR(\\n            _collAmount,\\n            vars.compositeDebt,\\n            vars.price\\n        );\\n        vars.NICR = LiquityMath._computeNominalCR(\\n            _collAmount,\\n            vars.compositeDebt\\n        );\\n\\n        if (isRecoveryMode) {\\n            _requireICRisAboveCCR(vars.ICR);\\n        } else {\\n            _requireICRisAboveMCR(vars.ICR);\\n            uint newTCR = _getNewTCRFromTroveChange(\\n                _collAmount,\\n                true,\\n                vars.compositeDebt,\\n                true,\\n                vars.price\\n            ); // bools: coll increase, debt increase\\n            _requireNewTCRisAboveCCR(newTCR);\\n        }\\n\\n        // Set the trove struct's properties\\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\\n        contractsCache.troveManager.increaseTroveColl(msg.sender, _collAmount);\\n        contractsCache.troveManager.increaseTroveDebt(\\n            msg.sender,\\n            vars.compositeDebt\\n        );\\n\\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\\n            msg.sender\\n        );\\n\\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(\\n            msg.sender\\n        );\\n        emit TroveCreated(msg.sender, vars.arrayIndex);\\n\\n        // Move the wStETH to the Active Pool, and mint the BaseFeeLMAAmount to the borrower\\n        _activePoolAddColl(contractsCache.activePool, _collAmount);\\n        // HEDGEHOG UPDATES: Revert if bfe loan is less then fee + gas comp\\n        if (\\n            _BaseFeeLMAAmount <=\\n            vars.BaseFeeLMAFee + BaseFeeLMA_GAS_COMPENSATION\\n        ) {\\n            revert(\\\"BO: Fee exceeds gain\\\");\\n        }\\n\\n        // Hedgehog Updates: Now amount transferred to the user is decreased by Fee\\n        _withdrawBaseFeeLMA(\\n            contractsCache.activePool,\\n            contractsCache.baseFeeLMAToken,\\n            msg.sender,\\n            _BaseFeeLMAAmount - vars.BaseFeeLMAFee,\\n            vars.netDebt\\n        );\\n\\n        // HEDGEHOG UPDATES: Not increasing net debt anymore. only transferring the gas comp tokens\\n        // Move the BaseFeeLMA gas compensation to the Gas Pool\\n        _withdrawBaseFeeLMA(\\n            contractsCache.activePool,\\n            contractsCache.baseFeeLMAToken,\\n            gasPoolAddress,\\n            BaseFeeLMA_GAS_COMPENSATION,\\n            BaseFeeLMA_GAS_COMPENSATION\\n        );\\n        emit TroveUpdated(\\n            msg.sender,\\n            vars.compositeDebt,\\n            _collAmount,\\n            vars.stake,\\n            BorrowerOperation.openTrove\\n        );\\n        emit BaseFeeLMABorrowingFeePaid(msg.sender, vars.BaseFeeLMAFee);\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral, therefore function may not rely on msg.value anymore\\n     * now passing a new param _collIncrease in _adjustTrove function - in this particular case it is a passed param _amount\\n     * checking if _amount is greater then 0\\n     * Function is no longer payable\\n     */\\n    // Send WStETH as collateral to a trove\\n    function addColl(\\n        address _upperHint,\\n        address _lowerHint,\\n        uint _amount\\n    ) external {\\n        require(_amount > 0, \\\"Borrower Operations: Invalid amount\\\");\\n\\n        _adjustTrove(\\n            msg.sender,\\n            0,\\n            _amount,\\n            0,\\n            false,\\n            _upperHint,\\n            _lowerHint,\\n            0\\n        );\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral, therefore function may not rely on msg.value anymore\\n     * now passing a new param _collIncrease in _adjustTrove function - in this particular case it is a passed param _amount\\n     * checking if _amount is greater then 0\\n     * Function is no longer payable\\n     */\\n    // Send WStETH as collateral to a trove. Called by only the Stability Pool.\\n    function moveWStETHGainToTrove(\\n        address _borrower,\\n        address _upperHint,\\n        address _lowerHint,\\n        uint _amount\\n    ) external {\\n        require(_amount > 0, \\\"Borrower Operations: Invalid amount\\\");\\n        _requireCallerIsStabilityPool();\\n        _adjustTrove(\\n            _borrower,\\n            0,\\n            _amount,\\n            0,\\n            false,\\n            _upperHint,\\n            _lowerHint,\\n            0\\n        );\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral, therefore function may not rely on msg.value anymore\\n     * now passing a new param _collIncrease - in this particular case it is 0\\n     */\\n    // Withdraw WStETH collateral from a trove\\n    function withdrawColl(\\n        uint _collWithdrawal,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external {\\n        _adjustTrove(\\n            msg.sender,\\n            _collWithdrawal,\\n            0,\\n            0,\\n            false,\\n            _upperHint,\\n            _lowerHint,\\n            0\\n        );\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral, therefore function may not rely on msg.value anymore\\n     * now passing a new param _collIncrease - in this particular case it is 0\\n     */\\n    // Withdraw BaseFeeLMA tokens from a trove: mint new BaseFeeLMA tokens to the owner, and increase the trove's debt accordingly\\n    function withdrawBaseFeeLMA(\\n        uint _maxFeePercentage,\\n        uint _BaseFeeLMAAmount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external {\\n        _adjustTrove(\\n            msg.sender,\\n            0,\\n            0,\\n            _BaseFeeLMAAmount,\\n            true,\\n            _upperHint,\\n            _lowerHint,\\n            _maxFeePercentage\\n        );\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral, therefore function may not rely on msg.value anymore\\n     * now passing a new param _collIncrease - in this particular case it is 0\\n     */\\n    // Repay BaseFeeLMA tokens to a Trove: Burn the repaid BaseFeeLMA tokens, and reduce the trove's debt accordingly\\n    function repayBaseFeeLMA(\\n        uint _BaseFeeLMAAmount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external {\\n        _adjustTrove(\\n            msg.sender,\\n            0,\\n            0,\\n            _BaseFeeLMAAmount,\\n            false,\\n            _upperHint,\\n            _lowerHint,\\n            0\\n        );\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral, therefore function may not rely on msg.value anymore\\n     * now passing a new param _collIncrease\\n     *\\n     * Function is no longer payable\\n     */\\n    function adjustTrove(\\n        uint _maxFeePercentage,\\n        uint _collWithdrawal,\\n        uint _collIncrease,\\n        uint _BaseFeeLMAChange,\\n        bool _isDebtIncrease,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external {\\n        _adjustTrove(\\n            msg.sender,\\n            _collWithdrawal,\\n            _collIncrease,\\n            _BaseFeeLMAChange,\\n            _isDebtIncrease,\\n            _upperHint,\\n            _lowerHint,\\n            _maxFeePercentage\\n        );\\n    }\\n\\n    /*\\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\\n     *\\n     * It therefore expects either a positive _collIncrease, or a positive _collWithdrawal argument.\\n     *\\n     * If both are positive, it will revert.\\n     */\\n    function _adjustTrove(\\n        address _borrower,\\n        uint _collWithdrawal,\\n        uint _collIncrease,\\n        uint _BaseFeeLMAChange,\\n        bool _isDebtIncrease,\\n        address _upperHint,\\n        address _lowerHint,\\n        uint _maxFeePercentage\\n    ) internal {\\n        {\\n            // Hedgehog Updates: Check that trove[msg.sender] did not perform adjustTrove transactions in the current block\\n            _checkAndSetUpdateBlock(msg.sender);\\n        }\\n        ContractsCache memory contractsCache = ContractsCache(\\n            troveManager,\\n            activePool,\\n            baseFeeLMAToken\\n        );\\n        LocalVariables_adjustTrove memory vars;\\n\\n        vars.price = priceFeed.fetchPrice();\\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\\n\\n        if (_isDebtIncrease) {\\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\\n            _requireNonZeroDebtChange(_BaseFeeLMAChange);\\n        }\\n        _requireSingularCollChange(_collWithdrawal, _collIncrease);\\n        _requireNonZeroAdjustment(\\n            _collWithdrawal,\\n            _collIncrease,\\n            _BaseFeeLMAChange\\n        );\\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\\n\\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure WStETH transfer from the Stability Pool to a trove\\n        assert(\\n            msg.sender == _borrower ||\\n                (msg.sender == stabilityPoolAddress &&\\n                    _collIncrease > 0 &&\\n                    _BaseFeeLMAChange == 0)\\n        );\\n\\n        contractsCache.troveManager.applyPendingRewards(_borrower);\\n\\n        // Get the collChange based on whether or not WStETH was sent in the transaction\\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(\\n            _collIncrease,\\n            _collWithdrawal\\n        );\\n\\n        vars.netDebtChange = _BaseFeeLMAChange;\\n\\n        // If the adjustment incorporates a debt increase then trigger a borrowing fee\\n        // HEDGEHOG UPDATES: Trigger borrowing fee in both recovery and normal modes\\n        if (_isDebtIncrease) {\\n            vars.BaseFeeLMAFee = _triggerBorrowingFee(\\n                contractsCache.troveManager,\\n                _BaseFeeLMAChange,\\n                _maxFeePercentage\\n            );\\n\\n            // Hedgehog Updates: Not adding fee to the position debt anymore\\n            vars.netDebtChange = vars.netDebtChange;\\n        }\\n\\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\\n\\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\\n        vars.newICR = _getNewICRFromTroveChange(\\n            vars.coll,\\n            vars.debt,\\n            vars.collChange,\\n            vars.isCollIncrease,\\n            vars.netDebtChange,\\n            _isDebtIncrease,\\n            vars.price\\n        );\\n        assert(_collWithdrawal <= vars.coll);\\n\\n        // Check the adjustment satisfies all conditions for the current system mode\\n        _requireValidAdjustmentInCurrentMode(\\n            isRecoveryMode,\\n            _collWithdrawal,\\n            _isDebtIncrease,\\n            vars\\n        );\\n\\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough BaseFeeLMA\\n        if (!_isDebtIncrease && _BaseFeeLMAChange > 0) {\\n            _requireAtLeastMinNetDebt(\\n                _getNetDebt(vars.debt).sub(vars.netDebtChange)\\n            );\\n            _requireValidBaseFeeLMARepayment(vars.debt, vars.netDebtChange);\\n            _requireSufficientBaseFeeLMABalance(\\n                contractsCache.baseFeeLMAToken,\\n                _borrower,\\n                vars.netDebtChange\\n            );\\n        }\\n\\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(\\n            contractsCache.troveManager,\\n            _borrower,\\n            vars.collChange,\\n            vars.isCollIncrease,\\n            vars.netDebtChange,\\n            _isDebtIncrease\\n        );\\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(\\n            _borrower\\n        );\\n\\n        // Re-insert trove in to the sorted list\\n        uint newNICR = _getNewNominalICRFromTroveChange(\\n            vars.coll,\\n            vars.debt,\\n            vars.collChange,\\n            vars.isCollIncrease,\\n            vars.netDebtChange,\\n            _isDebtIncrease\\n        );\\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\\n\\n        emit TroveUpdated(\\n            _borrower,\\n            vars.newDebt,\\n            vars.newColl,\\n            vars.stake,\\n            BorrowerOperation.adjustTrove\\n        );\\n        emit BaseFeeLMABorrowingFeePaid(msg.sender, vars.BaseFeeLMAFee);\\n\\n        _moveTokensAndWStETHfromAdjustment(\\n            contractsCache.activePool,\\n            contractsCache.baseFeeLMAToken,\\n            msg.sender,\\n            vars.collChange,\\n            vars.isCollIncrease,\\n            _BaseFeeLMAChange - vars.BaseFeeLMAFee,\\n            _isDebtIncrease,\\n            vars.netDebtChange\\n        );\\n    }\\n\\n    // Hedgehog Updates: Do not deduct gas fee compensation from trove Debt as user just received less tokens during position opening\\n    function closeTrove() external {\\n        // Hedgehog Updates: Check that trove[msg.sender] did not perform adjustTrove transactions in the current block\\n        {\\n            _checkAndSetUpdateBlock(msg.sender);\\n        }\\n        ITroveManager troveManagerCached = troveManager;\\n        IActivePool activePoolCached = activePool;\\n        IBaseFeeLMAToken baseFeeLMATokenCached = baseFeeLMAToken;\\n\\n        _requireTroveisActive(troveManagerCached, msg.sender);\\n        uint price = priceFeed.fetchPrice();\\n        _requireNotInRecoveryMode(price);\\n\\n        troveManagerCached.applyPendingRewards(msg.sender);\\n\\n        uint coll = troveManagerCached.getTroveColl(msg.sender);\\n        uint debt = troveManagerCached.getTroveDebt(msg.sender);\\n\\n        _requireSufficientBaseFeeLMABalance(\\n            baseFeeLMATokenCached,\\n            msg.sender,\\n            debt.sub(BaseFeeLMA_GAS_COMPENSATION)\\n        );\\n\\n        uint newTCR = _getNewTCRFromTroveChange(\\n            coll,\\n            false,\\n            debt,\\n            false,\\n            price\\n        );\\n        _requireNewTCRisAboveCCR(newTCR);\\n\\n        troveManagerCached.removeStake(msg.sender);\\n        troveManagerCached.closeTrove(msg.sender);\\n\\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\\n\\n        // Burn the repaid BaseFeeLMA from the user's balance and the gas compensation from the Gas Pool\\n        _repayBaseFeeLMA(\\n            activePoolCached,\\n            baseFeeLMATokenCached,\\n            msg.sender,\\n            debt.sub(BaseFeeLMA_GAS_COMPENSATION)\\n        );\\n        _repayBaseFeeLMA(\\n            activePoolCached,\\n            baseFeeLMATokenCached,\\n            gasPoolAddress,\\n            BaseFeeLMA_GAS_COMPENSATION\\n        );\\n\\n        // Send the collateral back to the user\\n        activePoolCached.sendWStETH(msg.sender, coll);\\n    }\\n\\n    /**\\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\\n     */\\n    function claimCollateral() external {\\n        // send WStETH from CollSurplus Pool to owner\\n        collSurplusPool.claimColl(msg.sender);\\n    }\\n\\n    // --- Helper functions ---\\n\\n    // HedgehogUpdates: new private function, that checks if there was a transaction with a trove in the current block\\n    function _checkAndSetUpdateBlock(address _borrower) private {\\n        if (troveManager.getTroveUpdateBlock(_borrower) == block.number) {\\n            revert TroveAdjustedThisBlock();\\n        }\\n        troveManager.setTroveLastUpdatedBlock(_borrower);\\n    }\\n\\n    // HEDGHEHOG UPDATES:\\n    // No longer passing token address param as it's not needed anymore\\n    function _triggerBorrowingFee(\\n        ITroveManager _troveManager,\\n        uint _BaseFeeLMAAmount,\\n        uint _maxFeePercentage\\n    ) internal returns (uint) {\\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\\n        (uint BaseFeeLMAFee, uint baseRate) = _troveManager.getBorrowingFee(\\n            _BaseFeeLMAAmount\\n        );\\n\\n        troveManager.updateBaseRateFromBorrowing(baseRate);\\n\\n        _requireUserAcceptsFee(\\n            BaseFeeLMAFee,\\n            _BaseFeeLMAAmount,\\n            _maxFeePercentage\\n        );\\n\\n        // HEDGHEHOG UPDATES:\\n        // Fees are now distributed among different addresses based on how big they are\\n        feesRouter.distributeDebtFee(_BaseFeeLMAAmount, BaseFeeLMAFee);\\n\\n        return BaseFeeLMAFee;\\n    }\\n\\n    function _getCollChange(\\n        uint _collReceived,\\n        uint _requestedCollWithdrawal\\n    ) internal pure returns (uint collChange, bool isCollIncrease) {\\n        if (_collReceived != 0) {\\n            collChange = _collReceived;\\n            isCollIncrease = true;\\n        } else {\\n            collChange = _requestedCollWithdrawal;\\n        }\\n    }\\n\\n    // Update trove's coll and debt based on whether they increase or decrease\\n    function _updateTroveFromAdjustment(\\n        ITroveManager _troveManager,\\n        address _borrower,\\n        uint _collChange,\\n        bool _isCollIncrease,\\n        uint _debtChange,\\n        bool _isDebtIncrease\\n    ) internal returns (uint, uint) {\\n        uint newColl = (_isCollIncrease)\\n            ? _troveManager.increaseTroveColl(_borrower, _collChange)\\n            : _troveManager.decreaseTroveColl(_borrower, _collChange);\\n        uint newDebt = (_isDebtIncrease)\\n            ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\\n            : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\\n\\n        return (newColl, newDebt);\\n    }\\n\\n    function _moveTokensAndWStETHfromAdjustment(\\n        IActivePool _activePool,\\n        IBaseFeeLMAToken _baseFeeLMAToken,\\n        address _borrower,\\n        uint _collChange,\\n        bool _isCollIncrease,\\n        uint _BaseFeeLMAChange,\\n        bool _isDebtIncrease,\\n        uint _netDebtChange\\n    ) internal {\\n        if (_isDebtIncrease) {\\n            _withdrawBaseFeeLMA(\\n                _activePool,\\n                _baseFeeLMAToken,\\n                _borrower,\\n                _BaseFeeLMAChange,\\n                _netDebtChange\\n            );\\n        } else {\\n            _repayBaseFeeLMA(\\n                _activePool,\\n                _baseFeeLMAToken,\\n                _borrower,\\n                _BaseFeeLMAChange\\n            );\\n        }\\n\\n        if (_isCollIncrease) {\\n            _activePoolAddColl(_activePool, _collChange);\\n        } else {\\n            _activePool.sendWStETH(_borrower, _collChange);\\n        }\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES: use SafeERC20 safe transfer instead of native token transfer\\n     * Send funds from User's account instead of relaying native token through address(this)\\n     * Manualy increase balance in Active Pool, since it used to be done in the native token fallback\\n     */\\n    // Send WStETH to Active Pool and increase its recorded WStETH balance\\n    function _activePoolAddColl(\\n        IActivePool _activePool,\\n        uint _amount\\n    ) internal {\\n        WStETHToken.safeTransferFrom(msg.sender, address(_activePool), _amount);\\n        activePool.increaseBalance(_amount);\\n    }\\n\\n    // Issue the specified amount of BaseFeeLMA to _account and increases the total active debt (_netDebtIncrease potentially includes a BaseFeeLMAFee)\\n    function _withdrawBaseFeeLMA(\\n        IActivePool _activePool,\\n        IBaseFeeLMAToken _baseFeeLMAToken,\\n        address _account,\\n        uint _BaseFeeLMAAmount,\\n        uint _netDebtIncrease\\n    ) internal {\\n        _activePool.increaseBaseFeeLMADebt(_netDebtIncrease);\\n        _baseFeeLMAToken.mint(_account, _BaseFeeLMAAmount);\\n    }\\n\\n    // Burn the specified amount of BaseFeeLMA from _account and decreases the total active debt\\n    function _repayBaseFeeLMA(\\n        IActivePool _activePool,\\n        IBaseFeeLMAToken _baseFeeLMAToken,\\n        address _account,\\n        uint BaseFeeLMA\\n    ) internal {\\n        _activePool.decreaseBaseFeeLMADebt(BaseFeeLMA);\\n        _baseFeeLMAToken.burn(_account, BaseFeeLMA);\\n    }\\n\\n    // --- 'Require' wrapper functions ---\\n\\n    /**\\n     * HEDGEHOG UPDATES: checking passed param instead of msg.value\\n     */\\n    function _requireSingularCollChange(\\n        uint _collWithdrawal,\\n        uint _collIncrease\\n    ) internal pure {\\n        require(\\n            _collIncrease == 0 || _collWithdrawal == 0,\\n            \\\"BorrowerOperations: Cannot withdraw and add coll\\\"\\n        );\\n    }\\n\\n    function _requireCallerIsBorrower(address _borrower) internal view {\\n        require(\\n            msg.sender == _borrower,\\n            \\\"BorrowerOps: Caller must be the borrower for a withdrawal\\\"\\n        );\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES: checking passed param instead of msg.value\\n     */\\n    function _requireNonZeroAdjustment(\\n        uint _collWithdrawal,\\n        uint _collIncrease,\\n        uint _BaseFeeLMAChange\\n    ) internal pure {\\n        require(\\n            _collIncrease != 0 ||\\n                _collWithdrawal != 0 ||\\n                _BaseFeeLMAChange != 0,\\n            \\\"BorrowerOps: There must be either a collateral change or a debt change\\\"\\n        );\\n    }\\n\\n    function _requireTroveisActive(\\n        ITroveManager _troveManager,\\n        address _borrower\\n    ) internal view {\\n        uint status = _troveManager.getTroveStatus(_borrower);\\n        require(status == 1, \\\"BorrowerOps: Trove does not exist or is closed\\\");\\n    }\\n\\n    function _requireTroveisNotActive(\\n        ITroveManager _troveManager,\\n        address _borrower\\n    ) internal view {\\n        uint status = _troveManager.getTroveStatus(_borrower);\\n        require(status != 1, \\\"BorrowerOps: Trove is active\\\");\\n    }\\n\\n    function _requireNonZeroDebtChange(uint _BaseFeeLMAChange) internal pure {\\n        require(\\n            _BaseFeeLMAChange > 0,\\n            \\\"BorrowerOps: Debt increase requires non-zero debtChange\\\"\\n        );\\n    }\\n\\n    function _requireNotInRecoveryMode(uint _price) internal view {\\n        require(\\n            !_checkRecoveryMode(_price),\\n            \\\"BorrowerOps: Operation not permitted during Recovery Mode\\\"\\n        );\\n    }\\n\\n    function _requireNoCollWithdrawal(uint _collWithdrawal) internal pure {\\n        require(\\n            _collWithdrawal == 0,\\n            \\\"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\\\"\\n        );\\n    }\\n\\n    function _requireValidAdjustmentInCurrentMode(\\n        bool _isRecoveryMode,\\n        uint _collWithdrawal,\\n        bool _isDebtIncrease,\\n        LocalVariables_adjustTrove memory _vars\\n    ) internal view {\\n        /*\\n         *In Recovery Mode, only allow:\\n         *\\n         * - Pure collateral top-up\\n         * - Pure debt repayment\\n         * - Collateral top-up with debt repayment\\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\\n         *\\n         * In Normal Mode, ensure:\\n         *\\n         * - The new ICR is above MCR\\n         * - The adjustment won't pull the TCR below CCR\\n         */\\n        if (_isRecoveryMode) {\\n            _requireNoCollWithdrawal(_collWithdrawal);\\n            if (_isDebtIncrease) {\\n                _requireICRisAboveCCR(_vars.newICR);\\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\\n            }\\n        } else {\\n            // if Normal Mode\\n            _requireICRisAboveMCR(_vars.newICR);\\n            _vars.newTCR = _getNewTCRFromTroveChange(\\n                _vars.collChange,\\n                _vars.isCollIncrease,\\n                _vars.netDebtChange,\\n                _isDebtIncrease,\\n                _vars.price\\n            );\\n            _requireNewTCRisAboveCCR(_vars.newTCR);\\n        }\\n    }\\n\\n    function _requireICRisAboveMCR(uint _newICR) internal pure {\\n        require(\\n            _newICR >= MCR,\\n            \\\"BorrowerOps: An operation that would result in ICR < MCR is not permitted\\\"\\n        );\\n    }\\n\\n    function _requireICRisAboveCCR(uint _newICR) internal view {\\n        require(\\n            _newICR >= CCR,\\n            \\\"BorrowerOps: Operation must leave trove with ICR >= CCR\\\"\\n        );\\n    }\\n\\n    function _requireNewICRisAboveOldICR(\\n        uint _newICR,\\n        uint _oldICR\\n    ) internal pure {\\n        require(\\n            _newICR >= _oldICR,\\n            \\\"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\\\"\\n        );\\n    }\\n\\n    function _requireNewTCRisAboveCCR(uint _newTCR) internal pure {\\n        require(\\n            _newTCR >= CCR,\\n            \\\"BorrowerOps: An operation that would result in TCR < CCR is not permitted\\\"\\n        );\\n    }\\n\\n    function _requireAtLeastMinNetDebt(uint _netDebt) internal pure {\\n        require(\\n            _netDebt >= MIN_NET_DEBT,\\n            \\\"BorrowerOps: Trove's net debt must be greater than minimum\\\"\\n        );\\n    }\\n\\n    function _requireValidBaseFeeLMARepayment(\\n        uint _currentDebt,\\n        uint _debtRepayment\\n    ) internal pure {\\n        require(\\n            _debtRepayment <= _currentDebt.sub(BaseFeeLMA_GAS_COMPENSATION),\\n            \\\"BorrowerOps: Amount repaid must not be larger than the Trove's debt\\\"\\n        );\\n    }\\n\\n    function _requireCallerIsStabilityPool() internal view {\\n        require(\\n            msg.sender == stabilityPoolAddress,\\n            \\\"BorrowerOps: Caller is not Stability Pool\\\"\\n        );\\n    }\\n\\n    function _requireSufficientBaseFeeLMABalance(\\n        IBaseFeeLMAToken _baseFeeLMAToken,\\n        address _borrower,\\n        uint _debtRepayment\\n    ) internal view {\\n        require(\\n            _baseFeeLMAToken.balanceOf(_borrower) >= _debtRepayment,\\n            \\\"BorrowerOps: Caller doesnt have enough BaseFeeLMA to make repayment\\\"\\n        );\\n    }\\n\\n    function _requireValidMaxFeePercentage(\\n        uint _maxFeePercentage,\\n        bool _isRecoveryMode\\n    ) internal pure {\\n        if (_isRecoveryMode) {\\n            require(\\n                _maxFeePercentage <= DECIMAL_PRECISION,\\n                \\\"Max fee percentage must less than or equal to 100%\\\"\\n            );\\n        } else {\\n            require(\\n                _maxFeePercentage >= BORROWING_FEE_FLOOR &&\\n                    _maxFeePercentage <= DECIMAL_PRECISION,\\n                \\\"Max fee percentage must be between 0.5% and 100%\\\"\\n            );\\n        }\\n    }\\n\\n    // --- ICR and TCR getters ---\\n\\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\\n    function _getNewNominalICRFromTroveChange(\\n        uint _coll,\\n        uint _debt,\\n        uint _collChange,\\n        bool _isCollIncrease,\\n        uint _debtChange,\\n        bool _isDebtIncrease\\n    ) internal pure returns (uint) {\\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(\\n            _coll,\\n            _debt,\\n            _collChange,\\n            _isCollIncrease,\\n            _debtChange,\\n            _isDebtIncrease\\n        );\\n\\n        uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\\n        return newNICR;\\n    }\\n\\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\\n    function _getNewICRFromTroveChange(\\n        uint _coll,\\n        uint _debt,\\n        uint _collChange,\\n        bool _isCollIncrease,\\n        uint _debtChange,\\n        bool _isDebtIncrease,\\n        uint _price\\n    ) internal pure returns (uint) {\\n        (uint newColl, uint newDebt) = _getNewTroveAmounts(\\n            _coll,\\n            _debt,\\n            _collChange,\\n            _isCollIncrease,\\n            _debtChange,\\n            _isDebtIncrease\\n        );\\n\\n        uint newICR = LiquityMath._computeCR(newColl, newDebt, _price);\\n        return newICR;\\n    }\\n\\n    function _getNewTroveAmounts(\\n        uint _coll,\\n        uint _debt,\\n        uint _collChange,\\n        bool _isCollIncrease,\\n        uint _debtChange,\\n        bool _isDebtIncrease\\n    ) internal pure returns (uint, uint) {\\n        uint newColl = _coll;\\n        uint newDebt = _debt;\\n\\n        newColl = _isCollIncrease\\n            ? _coll.add(_collChange)\\n            : _coll.sub(_collChange);\\n        newDebt = _isDebtIncrease\\n            ? _debt.add(_debtChange)\\n            : _debt.sub(_debtChange);\\n\\n        return (newColl, newDebt);\\n    }\\n\\n    function _getNewTCRFromTroveChange(\\n        uint _collChange,\\n        bool _isCollIncrease,\\n        uint _debtChange,\\n        bool _isDebtIncrease,\\n        uint _price\\n    ) internal view returns (uint) {\\n        uint totalColl = getEntireSystemColl();\\n        uint totalDebt = getEntireSystemDebt();\\n\\n        totalColl = _isCollIncrease\\n            ? totalColl.add(_collChange)\\n            : totalColl.sub(_collChange);\\n        totalDebt = _isDebtIncrease\\n            ? totalDebt.add(_debtChange)\\n            : totalDebt.sub(_debtChange);\\n\\n        uint newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\\n        return newTCR;\\n    }\\n\\n    function getCompositeDebt(uint _debt) external pure returns (uint) {\\n        return _getCompositeDebt(_debt);\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * New view method to help with getting the data on frontends\\n     */\\n    function computeUnreliableCR(\\n        uint _coll,\\n        uint _debt\\n    ) external view returns (uint) {\\n        uint price = priceFeed.lastGoodPrice();\\n\\n        return LiquityMath._computeCR(_coll, _debt, price);\\n    }\\n}\\n\"\n    },\n    \"contracts/dependencies/BaseMath.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ncontract BaseMath {\\n    uint public constant DECIMAL_PRECISION = 1e18;\\n}\\n\"\n    },\n    \"contracts/dependencies/CheckContract.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ncontract CheckContract {\\n    /**\\n     * Check that the account is an already deployed non-destroyed contract.\\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\\n     */\\n    function checkContract(address _account) internal view {\\n        require(_account != address(0), \\\"Account cannot be zero address\\\");\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(_account)\\n        }\\n        require(size > 0, \\\"Account code size cannot be zero\\\");\\n    }\\n}\\n\"\n    },\n    \"contracts/dependencies/HedgehogBase.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./BaseMath.sol\\\";\\nimport \\\"./LiquityMath.sol\\\";\\nimport \\\"../interfaces/IActivePool.sol\\\";\\nimport \\\"../interfaces/IDefaultPool.sol\\\";\\nimport \\\"../interfaces/IPriceFeed.sol\\\";\\nimport \\\"../interfaces/IHedgehogBase.sol\\\";\\n\\n/**\\n * @notice Fork of LiquityMath with an upgraded pragma and:\\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\\n * common functions.\\n *\\n * Hedgehog updates:\\n * Rename variables,\\n * Increase MCR and CCR,\\n * Update Min Net Debt\\n */\\ncontract HedgehogBase is BaseMath, IHedgehogBase {\\n    using SafeMath for uint;\\n\\n    uint public constant _100pct = 1000000000000000000; // 1e18 == 100%\\n\\n    // HEDGEHOG UPDATES: Increased to 150%\\n    // Minimum collateral ratio for individual troves\\n    uint public constant MCR = 1500000000000000000; // 150%\\n\\n    // HEDGEHOG UPDATES: Increased to 200%\\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\\n    uint public constant CCR = 2000000000000000000; // 200%\\n\\n    // HEDGEHOG UPDATES: Decreased to 100k wei\\n    // Amount of BaseFeeLMA to be locked in gas pool on opening troves\\n    uint public constant BaseFeeLMA_GAS_COMPENSATION = 100000;\\n\\n    // HEDGEHOG UPDATES: Decreased to 350000000 BFE\\n    // Minimum amount of net BaseFeeLMA debt a trove must have\\n    uint public constant MIN_NET_DEBT = 350000000;\\n\\n    uint public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\\n\\n    uint public constant BORROWING_FEE_FLOOR = (DECIMAL_PRECISION / 1000) * 5; // 0.5%\\n\\n    IActivePool public activePool;\\n\\n    IDefaultPool public defaultPool;\\n\\n    IPriceFeed public override priceFeed;\\n\\n    // --- Gas compensation functions ---\\n\\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\\n        return _debt.add(BaseFeeLMA_GAS_COMPENSATION);\\n    }\\n\\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\\n        return _debt.sub(BaseFeeLMA_GAS_COMPENSATION);\\n    }\\n\\n    // Return the amount of WStETH to be drawn from a trove's collateral and sent as gas compensation.\\n    function _getCollGasCompensation(\\n        uint _entireColl\\n    ) internal pure returns (uint) {\\n        return _entireColl / PERCENT_DIVISOR;\\n    }\\n\\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\\n        uint activeColl = activePool.getWStETH();\\n        uint liquidatedColl = defaultPool.getWStETH();\\n        return activeColl.add(liquidatedColl);\\n    }\\n\\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\\n        uint activeDebt = activePool.getBaseFeeLMADebt();\\n        uint closedDebt = defaultPool.getBaseFeeLMADebt();\\n\\n        return activeDebt.add(closedDebt);\\n    }\\n\\n    function _getTCR(uint _price) internal view returns (uint TCR) {\\n        uint entireSystemColl = getEntireSystemColl();\\n        uint entireSystemDebt = getEntireSystemDebt();\\n        TCR = LiquityMath._computeCR(\\n            entireSystemColl,\\n            entireSystemDebt,\\n            _price\\n        );\\n\\n        return TCR;\\n    }\\n\\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\\n        uint TCR = _getTCR(_price);\\n\\n        return TCR < CCR;\\n    }\\n\\n    function _requireUserAcceptsFee(\\n        uint _fee,\\n        uint _amount,\\n        uint _maxFeePercentage\\n    ) internal pure {\\n        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\\n        require(\\n            feePercentage <= _maxFeePercentage,\\n            \\\"Fee exceeded provided maximum\\\"\\n        );\\n    }\\n}\\n\"\n    },\n    \"contracts/dependencies/IERC2612.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold WStETH.\\n *\\n * See https://eips.wStETHeum.org/EIPS/eip-2612.\\n *\\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.wStETHeum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     *\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to\\n     * a value in the near future. The deadline argument can be set to uint(-1) to\\n     * create Permits that effectively never expire.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function permitTypeHash() external view returns (bytes32);\\n\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\"\n    },\n    \"contracts/dependencies/LiquityMath.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @notice A fork of Liquity Math library with an upgraded pragma\\n *\\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\\n */\\n\\nlibrary LiquityMath {\\n    using SafeMath for uint;\\n\\n    uint internal constant DECIMAL_PRECISION = 1e18;\\n\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n     *\\n     * - Making it too high could lead to overflows.\\n     * - Making it too low could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\n     *\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 WStETH,\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n     *\\n     */\\n    uint internal constant NICR_PRECISION = 1e20;\\n\\n    function _min(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a < _b) ? _a : _b;\\n    }\\n\\n    function _max(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a >= _b) ? _a : _b;\\n    }\\n\\n    /*\\n     * Multiply two decimal numbers and use normal rounding rules:\\n     * -round product up if 19'th mantissa digit >= 5\\n     * -round product down if 19'th mantissa digit < 5\\n     *\\n     * Used only inside the exponentiation, _decPow().\\n     */\\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\\n        uint prod_xy = x.mul(y);\\n\\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\\n    }\\n\\n    /*\\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n     *\\n     * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\n     *\\n     * Called by two functions that represent time in units of minutes:\\n     * 1) TroveManager._calcDecayedBaseRate\\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\\n     *\\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n     * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n     *\\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n     * negligibly different from just passing the cap, since:\\n     *\\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n     */\\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\\n        if (_minutes > 525600000) {\\n            _minutes = 525600000;\\n        } // cap to avoid overflow\\n\\n        if (_minutes == 0) {\\n            return DECIMAL_PRECISION;\\n        }\\n\\n        uint y = DECIMAL_PRECISION;\\n        uint x = _base;\\n        uint n = _minutes;\\n\\n        // Exponentiation-by-squaring\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x = decMul(x, x);\\n                n = n.div(2);\\n            } else {\\n                // if (n % 2 != 0)\\n                y = decMul(x, y);\\n                x = decMul(x, x);\\n                n = (n.sub(1)).div(2);\\n            }\\n        }\\n\\n        return decMul(x, y);\\n    }\\n\\n    function _getAbsoluteDifference(\\n        uint _a,\\n        uint _b\\n    ) internal pure returns (uint) {\\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\\n    }\\n\\n    function _computeNominalCR(\\n        uint _coll,\\n        uint _debt\\n    ) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            return _coll.mul(NICR_PRECISION).div(_debt);\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return 2 ** 256 - 1;\\n        }\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * Change coll ration calculation from [coll] * [price] / [debt] to\\n     * [coll] / [debt] / [gasPrice]\\n     */\\n    function _computeCR(\\n        uint _coll,\\n        uint _debt,\\n        uint _price\\n    ) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            uint newCollRatio = _coll\\n                .mul(DECIMAL_PRECISION)\\n                .div(_debt)\\n                .mul(DECIMAL_PRECISION)\\n                .div(_price);\\n\\n            return newCollRatio;\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return 2 ** 256 - 1;\\n        }\\n    }\\n\\n    function _findPriceBelowMCR(\\n        uint256 _coll,\\n        uint256 _debt,\\n        uint _mcr\\n    ) internal pure returns (uint256 price) {\\n        // Finds an exact price at which CR becomes MCR. Liqudation does not happen in the event of them being equal, hence we add 1 to it to find closest liqudation price\\n        price = ((_coll * DECIMAL_PRECISION) / _debt / _mcr) + 1;\\n    }\\n}\\n\"\n    },\n    \"contracts/dependencies/LiquitySafeMath128.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n// uint128 addition and subtraction, with overflow protection.\\n\\nlibrary LiquitySafeMath128 {\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"LiquitySafeMath128: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        require(b <= a, \\\"LiquitySafeMath128: subtraction overflow\\\");\\n        uint128 c = a - b;\\n\\n        return c;\\n    }\\n}\\n\"\n    },\n    \"contracts/HintHelpers.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/ITroveManager.sol\\\";\\nimport \\\"./interfaces/ISortedTroves.sol\\\";\\nimport \\\"./dependencies/HedgehogBase.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./dependencies/CheckContract.sol\\\";\\n\\ncontract HintHelpers is HedgehogBase, Ownable, CheckContract {\\n    using SafeMath for uint256;\\n    string public constant NAME = \\\"HintHelpers\\\";\\n\\n    ISortedTroves public sortedTroves;\\n    ITroveManager public troveManager;\\n\\n    // --- Events ---\\n\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n\\n    // --- Dependency setters ---\\n\\n    function setAddresses(\\n        address _sortedTrovesAddress,\\n        address _troveManagerAddress\\n    ) external onlyOwner {\\n        checkContract(_sortedTrovesAddress);\\n        checkContract(_troveManagerAddress);\\n\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\n        troveManager = ITroveManager(_troveManagerAddress);\\n\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Functions ---\\n\\n    /* getRedemptionHints() - Helper function for finding the right hints to pass to redeemCollateral().\\n     *\\n     * It simulates a redemption of `_BaseFeeLMAamount` to figure out where the redemption sequence will start and what state the final Trove\\n     * of the sequence will end up in.\\n     *\\n     * Returns three hints:\\n     *  - `firstRedemptionHint` is the address of the first Trove with ICR >= MCR (i.e. the first Trove that will be redeemed).\\n     *  - `partialRedemptionHintNICR` is the final nominal ICR of the last Trove of the sequence after being hit by partial redemption,\\n     *     or zero in case of no partial redemption.\\n     *  - `truncatedBaseFeeLMAamount` is the maximum amount that can be redeemed out of the the provided `_BaseFeeLMAamount`. This can be lower than\\n     *    `_BaseFeeLMAamount` when redeeming the full amount would leave the last Trove of the redemption sequence with less net debt than the\\n     *    minimum allowed value (i.e. MIN_NET_DEBT).\\n     *\\n     * The number of Troves to consider for redemption can be capped by passing a non-zero value as `_maxIterations`, while passing zero\\n     * will leave it uncapped.\\n     */\\n\\n    function getRedemptionHints(\\n        uint _BaseFeeLMAamount,\\n        uint _price,\\n        uint _maxIterations\\n    )\\n        external\\n        view\\n        returns (\\n            address firstRedemptionHint,\\n            uint partialRedemptionHintNICR,\\n            uint truncatedBaseFeeLMAamount\\n        )\\n    {\\n        ISortedTroves sortedTrovesCached = sortedTroves;\\n\\n        uint remainingBaseFeeLMA = _BaseFeeLMAamount;\\n        address currentTroveuser = sortedTrovesCached.getLast();\\n\\n        while (\\n            currentTroveuser != address(0) &&\\n            troveManager.getCurrentICR(currentTroveuser, _price) < MCR\\n        ) {\\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\\n        }\\n\\n        firstRedemptionHint = currentTroveuser;\\n\\n        if (_maxIterations == 0) {\\n            // Previous implementation: _maxIterations = uint(-1);\\n            // Updated since 8th pragma does not allow anymore\\n            _maxIterations = type(uint).max;\\n        }\\n\\n        while (\\n            currentTroveuser != address(0) &&\\n            remainingBaseFeeLMA > 0 &&\\n            _maxIterations-- > 0\\n        ) {\\n            uint netBaseFeeLMADebt = _getNetDebt(\\n                troveManager.getTroveDebt(currentTroveuser)\\n            ).add(\\n                    troveManager.getPendingBaseFeeLMADebtReward(\\n                        currentTroveuser\\n                    )\\n                );\\n\\n            if (netBaseFeeLMADebt > remainingBaseFeeLMA) {\\n                if (netBaseFeeLMADebt > MIN_NET_DEBT) {\\n                    uint maxRedeemableBaseFeeLMA = LiquityMath._min(\\n                        remainingBaseFeeLMA,\\n                        netBaseFeeLMADebt.sub(MIN_NET_DEBT)\\n                    );\\n\\n                    uint WStETH = troveManager\\n                        .getTroveColl(currentTroveuser)\\n                        .add(\\n                            troveManager.getPendingWStETHReward(\\n                                currentTroveuser\\n                            )\\n                        );\\n\\n                    // HEDGEHOG UPDATES: Change WStETHLOT calculations formula from [debtToBeRedeemed * price * 10e9] to [debtToBeRedeemed / price]\\n                    uint newColl = WStETH.sub(\\n                        maxRedeemableBaseFeeLMA.mul(_price).div(\\n                            DECIMAL_PRECISION\\n                        )\\n                    );\\n                    uint newDebt = netBaseFeeLMADebt.sub(\\n                        maxRedeemableBaseFeeLMA\\n                    );\\n\\n                    uint compositeDebt = _getCompositeDebt(newDebt);\\n                    partialRedemptionHintNICR = LiquityMath._computeNominalCR(\\n                        newColl,\\n                        compositeDebt\\n                    );\\n\\n                    remainingBaseFeeLMA = remainingBaseFeeLMA.sub(\\n                        maxRedeemableBaseFeeLMA\\n                    );\\n                }\\n                break;\\n            } else {\\n                remainingBaseFeeLMA = remainingBaseFeeLMA.sub(\\n                    netBaseFeeLMADebt\\n                );\\n            }\\n\\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\\n        }\\n\\n        truncatedBaseFeeLMAamount = _BaseFeeLMAamount.sub(remainingBaseFeeLMA);\\n    }\\n\\n    /* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the \\n    sortedTroves list from the correct insert position of the Trove to be inserted. \\n    \\n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function \\n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\\n\\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will \\n    be <= sqrt(length) positions away from the correct insert position.\\n    */\\n    function getApproxHint(\\n        uint _CR,\\n        uint _numTrials,\\n        uint _inputRandomSeed\\n    )\\n        external\\n        view\\n        returns (address hintAddress, uint diff, uint latestRandomSeed)\\n    {\\n        uint arrayLength = troveManager.getTroveOwnersCount();\\n\\n        if (arrayLength == 0) {\\n            return (address(0), 0, _inputRandomSeed);\\n        }\\n\\n        hintAddress = sortedTroves.getLast();\\n        diff = LiquityMath._getAbsoluteDifference(\\n            _CR,\\n            troveManager.getNominalICR(hintAddress)\\n        );\\n        latestRandomSeed = _inputRandomSeed;\\n\\n        uint i = 1;\\n\\n        while (i < _numTrials) {\\n            latestRandomSeed = uint(\\n                keccak256(abi.encodePacked(latestRandomSeed))\\n            );\\n\\n            uint arrayIndex = latestRandomSeed % arrayLength;\\n            address currentAddress = troveManager.getTroveFromTroveOwnersArray(\\n                arrayIndex\\n            );\\n            uint currentNICR = troveManager.getNominalICR(currentAddress);\\n\\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\\n            uint currentDiff = LiquityMath._getAbsoluteDifference(\\n                currentNICR,\\n                _CR\\n            );\\n\\n            if (currentDiff < diff) {\\n                diff = currentDiff;\\n                hintAddress = currentAddress;\\n            }\\n            i++;\\n        }\\n    }\\n\\n    function computeNominalCR(\\n        uint _coll,\\n        uint _debt\\n    ) external pure returns (uint) {\\n        return LiquityMath._computeNominalCR(_coll, _debt);\\n    }\\n\\n    function computeCR(\\n        uint _coll,\\n        uint _debt,\\n        uint _price\\n    ) external pure returns (uint) {\\n        return LiquityMath._computeCR(_coll, _debt, _price);\\n    }\\n}\\n\"\n    },\n    \"contracts/HOG/CommunityIssuance.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../interfaces/IHOGToken.sol\\\";\\nimport \\\"../interfaces/ICommunityIssuance.sol\\\";\\nimport \\\"../dependencies/BaseMath.sol\\\";\\nimport \\\"../dependencies/LiquityMath.sol\\\";\\nimport \\\"../dependencies/CheckContract.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract CommunityIssuance is AccessControl, Ownable, CheckContract, BaseMath {\\n    using SafeMath for uint;\\n\\n    // HEDGEHOG UPDATES: Add Access control to the contract for the setting of dynamic variables\\n    bytes32 internal constant DISTRIBUTION_SETTER =\\n        keccak256(\\\"DISTRIBUTION_SETTER\\\");\\n    bytes32 internal constant DISTRIBUTION_SETTER_ADMIN =\\n        keccak256(\\\"DISTRIBUTION_SETTER_ADMIN\\\");\\n\\n    // --- Data ---\\n    string public constant NAME = \\\"CommunityIssuance\\\";\\n\\n    uint public constant SECONDS_IN_ONE_MINUTE = 60;\\n\\n    /*\\n     * HEDGEHOG UPDATES: Not a constant variable anymore.\\n     * May now be updated by a DISTRIBUTION_SETTER\\n     * The issuance factor F determines the curvature of the issuance curve.\\n     *\\n     * Minutes in one year: 60*24*365 = 525600\\n     *\\n     * For 50% of remaining tokens issued each year, with minutes as time units, we have:\\n     *\\n     * F ** 525600 = 0.5\\n     *\\n     * Re-arranging:\\n     *\\n     * 525600 * ln(F) = ln(0.5)\\n     * F = 0.5 ** (1/525600)\\n     * F = 0.999998681227695000\\n     */\\n    uint256 public ISSUANCE_FACTOR = 999998681227695000;\\n\\n    /*\\n     * HEDGEHOG UPDATES: Not a constant variable anymore.\\n     * May now be updated by a DISTRIBUTION_SETTER\\n     *\\n     * The community HOG supply cap is the starting balance of the Community Issuance contract.\\n     * It should be minted to this contract by HOGToken, when the token is deployed.\\n     */\\n    uint256 public HOGSupplyCap;\\n\\n    event HOGSupplyCapUpdated(uint256 _newCap);\\n    event ISSUANCE_FACTORUpdated(uint256 _newFactor);\\n\\n    IHOGToken public hogToken;\\n\\n    address public stabilityPoolAddress;\\n\\n    uint public totalHOGIssued;\\n    uint public immutable deploymentTime;\\n\\n    // --- Events ---\\n\\n    event HOGTokenAddressSet(address _hogTokenAddress);\\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\\n    event TotalHOGIssuedUpdated(uint _totalHOGIssued);\\n\\n    // --- Functions ---\\n\\n    constructor() {\\n        deploymentTime = block.timestamp;\\n    }\\n\\n    function setAddresses(\\n        address _hogTokenAddress,\\n        address _stabilityPoolAddress,\\n        address _setter,\\n        address _setterAdmin\\n    ) external onlyOwner {\\n        checkContract(_hogTokenAddress);\\n        checkContract(_stabilityPoolAddress);\\n\\n        /* HEDGEHOG UPDATES: Setting two variables that used to be constant in constructor now.\\n         * May now be updated by a DISTRIBUTION_SETTER and DISTRIBUTION_SETTER address is admined by DISTRIBUTION_SETTER_ADMIN\\n         * At deployment both admin roles set to the deployer. May be updated later\\n         *\\n         * At the deployment moment hog supply cap is set to 0\\n         */\\n        _grantRole(DISTRIBUTION_SETTER, _setter);\\n        _setRoleAdmin(DISTRIBUTION_SETTER, DISTRIBUTION_SETTER_ADMIN);\\n        _grantRole(DISTRIBUTION_SETTER_ADMIN, _setterAdmin);\\n\\n        hogToken = IHOGToken(_hogTokenAddress);\\n        stabilityPoolAddress = _stabilityPoolAddress;\\n\\n        ISSUANCE_FACTOR = 999998681227695000; // default issuance factor value;\\n        HOGSupplyCap = 0; // default supply cap value\\n\\n        emit HOGTokenAddressSet(_hogTokenAddress);\\n        emit StabilityPoolAddressSet(_stabilityPoolAddress);\\n\\n        renounceOwnership();\\n    }\\n\\n    function issueHOG() external returns (uint) {\\n        _requireCallerIsStabilityPool();\\n\\n        uint latestTotalHOGIssued = HOGSupplyCap\\n            .mul(_getCumulativeIssuanceFraction())\\n            .div(DECIMAL_PRECISION);\\n        uint issuance = latestTotalHOGIssued.sub(totalHOGIssued);\\n\\n        totalHOGIssued = latestTotalHOGIssued;\\n        emit TotalHOGIssuedUpdated(latestTotalHOGIssued);\\n\\n        return issuance;\\n    }\\n\\n    /* Gets 1-f^t    where: f < 1\\n\\n    f: issuance factor that determines the shape of the curve\\n    t:  time passed since last HOG issuance event  */\\n    function _getCumulativeIssuanceFraction() internal view returns (uint) {\\n        // Get the time passed since deployment\\n        uint timePassedInMinutes = block.timestamp.sub(deploymentTime).div(\\n            SECONDS_IN_ONE_MINUTE\\n        );\\n\\n        // f^t\\n        uint power = LiquityMath._decPow(ISSUANCE_FACTOR, timePassedInMinutes);\\n\\n        //  (1 - f^t)\\n        uint cumulativeIssuanceFraction = (uint(DECIMAL_PRECISION).sub(power));\\n        assert(cumulativeIssuanceFraction <= DECIMAL_PRECISION); // must be in range [0,1]\\n\\n        return cumulativeIssuanceFraction;\\n    }\\n\\n    function sendHOG(address _account, uint _HOGamount) external {\\n        _requireCallerIsStabilityPool();\\n\\n        hogToken.transfer(_account, _HOGamount);\\n    }\\n\\n    // --- 'admin' function ---\\n    /*\\n     * HEDGEHOG UPDATES: HOGSupplyCap is not a constant variable anymore.\\n     * May now be updated by a DISTRIBUTION_SETTER\\n     * */\\n    function setHOGSupplyCap(\\n        uint _newCap\\n    ) external onlyRole(DISTRIBUTION_SETTER) {\\n        HOGSupplyCap = _newCap;\\n        emit HOGSupplyCapUpdated(_newCap);\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES: ISSUANCE_FACTOR is not a constant variable anymore.\\n     * May now be updated by a DISTRIBUTION_SETTER\\n     * */\\n    function setISSUANCE_FACTOR(\\n        uint _newIssFactor\\n    ) external onlyRole(DISTRIBUTION_SETTER) {\\n        ISSUANCE_FACTOR = _newIssFactor;\\n        emit ISSUANCE_FACTORUpdated(_newIssFactor);\\n    }\\n\\n    // --- 'require' functions ---\\n\\n    function _requireCallerIsStabilityPool() internal view {\\n        require(\\n            msg.sender == stabilityPoolAddress,\\n            \\\"CommunityIssuance: caller is not SP\\\"\\n        );\\n    }\\n}\\n\"\n    },\n    \"contracts/interfaces/IActivePool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IPool.sol\\\";\\n\\ninterface IActivePool is IPool {\\n    // --- Events ---\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolBaseFeeLMADebtUpdated(uint _BaseFeeLMADebt);\\n    event ActivePoolWStETHBalanceUpdated(uint _WStETH);\\n\\n    // --- Functions ---\\n    function sendWStETH(address _account, uint _amount) external;\\n\\n    function getWStETH() external view returns (uint256);\\n\\n    function increaseBalance(uint256 _amount) external;\\n}\\n\"\n    },\n    \"contracts/interfaces/IBaseFeeLMAToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../dependencies/IERC2612.sol\\\";\\n\\ninterface IBaseFeeLMAToken is IERC20, IERC2612 {\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n\\n    event BaseFeeLMATokenBalanceUpdated(address _user, uint _amount);\\n\\n    // --- Functions ---\\n\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n\\n    function sendToPool(\\n        address _sender,\\n        address poolAddress,\\n        uint256 _amount\\n    ) external;\\n\\n    function returnFromPool(\\n        address poolAddress,\\n        address user,\\n        uint256 _amount\\n    ) external;\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\n    },\n    \"contracts/interfaces/IBaseFeeOracle.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IBaseFeeOracle {\\n    function decimals() external view returns (uint8);\\n\\n    function version() external view returns (uint256);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(\\n        uint80 _roundId\\n    )\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        );\\n}\\n\"\n    },\n    \"contracts/interfaces/IBorrowerOperations.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n// Common interface for the Trove Manager.\\ninterface IBorrowerOperations {\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event BaseFeeLMATokenAddressChanged(address _baseFeeLMATokenAddress);\\n\\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint stake,\\n        uint8 operation\\n    );\\n    event BaseFeeLMABorrowingFeePaid(\\n        address indexed _borrower,\\n        uint _BaseFeeLMAFee\\n    );\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _sortedTrovesAddress,\\n        address _baseFeeLMATokenAddress\\n    ) external;\\n\\n    function openTrove(\\n        uint _maxFee,\\n        uint _BaseFeeLMAAmount,\\n        uint _collAmount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function addColl(\\n        address _upperHint,\\n        address _lowerHint,\\n        uint _amount\\n    ) external;\\n\\n    function moveWStETHGainToTrove(\\n        address _user,\\n        address _upperHint,\\n        address _lowerHint,\\n        uint _amount\\n    ) external;\\n\\n    function withdrawColl(\\n        uint _amount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function withdrawBaseFeeLMA(\\n        uint _maxFee,\\n        uint _amount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function repayBaseFeeLMA(\\n        uint _amount,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function closeTrove() external;\\n\\n    function adjustTrove(\\n        uint _maxFee,\\n        uint _collWithdrawal,\\n        uint _collIncrease,\\n        uint _debtChange,\\n        bool isDebtIncrease,\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    function claimCollateral() external;\\n\\n    function getCompositeDebt(uint _debt) external pure returns (uint);\\n}\\n\"\n    },\n    \"contracts/interfaces/ICollSurplusPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface ICollSurplusPool {\\n    // --- Events ---\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n\\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\\n    event WStETHSent(address _to, uint _amount);\\n\\n    // --- Contract setters ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress\\n    ) external;\\n\\n    function getWStETH() external view returns (uint);\\n\\n    function getCollateral(address _account) external view returns (uint);\\n\\n    function accountSurplus(address _account, uint _amount) external;\\n\\n    function claimColl(address _account) external;\\n\\n    function increaseBalance(uint256 _amount) external;\\n}\\n\"\n    },\n    \"contracts/interfaces/ICommunityIssuance.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface ICommunityIssuance {\\n    // --- Events ---\\n\\n    event HOGTokenAddressSet(address _hogTokenAddress);\\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\\n    event TotalHOGIssuedUpdated(uint _totalHOGIssued);\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _hogTokenAddress,\\n        address _stabilityPoolAddress\\n    ) external;\\n\\n    function issueHOG() external returns (uint);\\n\\n    function sendHOG(address _account, uint _HOGamount) external;\\n}\\n\"\n    },\n    \"contracts/interfaces/IDefaultPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IPool.sol\\\";\\n\\ninterface IDefaultPool is IPool {\\n    // --- Events ---\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event DefaultPoolBaseFeeLMADebtUpdated(uint _BaseFeeLMADebt);\\n    event DefaultPoolWStETHBalanceUpdated(uint _WStETH);\\n\\n    // --- Functions ---\\n    function sendWStETHToActivePool(uint _amount) external;\\n\\n    function increaseBalance(uint256 _amount) external;\\n}\\n\"\n    },\n    \"contracts/interfaces/IFeesRouter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IFeesRouter {\\n    function distributeDebtFee(uint256 _debt, uint256 _fee) external;\\n\\n    function distributeCollFee(uint256 _debt, uint256 _fee) external;\\n}\\n\"\n    },\n    \"contracts/interfaces/IHedgehogBase.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IPriceFeed.sol\\\";\\n\\ninterface IHedgehogBase {\\n    function priceFeed() external view returns (IPriceFeed);\\n}\\n\"\n    },\n    \"contracts/interfaces/IHOGToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../dependencies/IERC2612.sol\\\";\\n\\ninterface IHOGToken is IERC20, IERC2612 {\\n    // --- Events ---\\n\\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\\n\\n    // --- Functions ---\\n\\n    function getDeploymentStartTime() external view returns (uint256);\\n\\n    function getLpRewardsEntitlement() external view returns (uint256);\\n\\n    function increaseAllowance(\\n        address _spender,\\n        uint256 _addedValues\\n    ) external returns (bool);\\n\\n    function decreaseAllowance(\\n        address _spender,\\n        uint256 _decreasedValue\\n    ) external returns (bool);\\n}\\n\"\n    },\n    \"contracts/interfaces/IPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n// Common interface for the Pools.\\ninterface IPool {\\n    // --- Events ---\\n\\n    event WStETHBalanceUpdated(uint _newBalance);\\n    event BaseFeeLMABalanceUpdated(uint _newBalance);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event WStETHSent(address _to, uint _amount);\\n\\n    // --- Functions ---\\n\\n    function getWStETH() external view returns (uint);\\n\\n    function getBaseFeeLMADebt() external view returns (uint);\\n\\n    function increaseBaseFeeLMADebt(uint _amount) external;\\n\\n    function decreaseBaseFeeLMADebt(uint _amount) external;\\n\\n    // function increaseCollCountInPool(uint256 _amount) external;\\n}\\n\"\n    },\n    \"contracts/interfaces/IPriceFeed.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IPriceFeed {\\n    // --- Events ---\\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\\n\\n    // --- Function ---\\n    function fetchPrice() external returns (uint);\\n\\n    function lastGoodPrice() external view returns (uint);\\n}\\n\"\n    },\n    \"contracts/interfaces/ISortedTroves.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n// Common interface for the SortedTroves Doubly Linked List.\\ninterface ISortedTroves {\\n    // --- Events ---\\n\\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\\n    event NodeAdded(address _id, uint _NICR);\\n    event NodeRemoved(address _id);\\n\\n    // --- Functions ---\\n\\n    function setParams(\\n        uint256 _size,\\n        address _TroveManagerAddress,\\n        address _borrowerOperationsAddress\\n    ) external;\\n\\n    function insert(\\n        address _id,\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external;\\n\\n    function remove(address _id) external;\\n\\n    function reInsert(\\n        address _id,\\n        uint256 _newICR,\\n        address _prevId,\\n        address _nextId\\n    ) external;\\n\\n    function contains(address _id) external view returns (bool);\\n\\n    function isFull() external view returns (bool);\\n\\n    function isEmpty() external view returns (bool);\\n\\n    function getSize() external view returns (uint256);\\n\\n    function getMaxSize() external view returns (uint256);\\n\\n    function getFirst() external view returns (address);\\n\\n    function getLast() external view returns (address);\\n\\n    function getNext(address _id) external view returns (address);\\n\\n    function getPrev(address _id) external view returns (address);\\n\\n    function validInsertPosition(\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external view returns (bool);\\n\\n    function findInsertPosition(\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external view returns (address, address);\\n}\\n\"\n    },\n    \"contracts/interfaces/IStabilityPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n/*\\n * The Stability Pool holds BaseFeeLMA tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its BaseFeeLMA debt gets offset with\\n * BaseFeeLMA in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of BaseFeeLMA tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a BaseFeeLMA loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an WStETH gain, as the WStETH collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total BaseFeeLMA in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / WStETH gain derivations:\\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\n *\\n * --- HOG ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * A HOG issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued HOG in proportion to the deposit as a share of total deposits. The HOG earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n * Please see the system Readme for an overview:\\n * https://github.com/liquity/dev/blob/main/README.md#hog-issuance-to-stability-providers\\n */\\ninterface IStabilityPool {\\n    // --- Events ---\\n\\n    event StabilityPoolWStETHBalanceUpdated(uint _newBalance);\\n    event StabilityPoolBaseFeeLMABalanceUpdated(uint _newBalance);\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\\n\\n    event P_Updated(uint _P);\\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\\n    event EpochUpdated(uint128 _currentEpoch);\\n    event ScaleUpdated(uint128 _currentScale);\\n\\n    event DepositSnapshotUpdated(\\n        address indexed _depositor,\\n        uint _P,\\n        uint _S,\\n        uint _G\\n    );\\n\\n    event WStETHGainWithdrawn(\\n        address indexed _depositor,\\n        uint _WStETH,\\n        uint _BaseFeeLMALoss\\n    );\\n    event HOGPaidToDepositor(address indexed _depositor, uint _HOG);\\n    event WStETHSent(address _to, uint _amount);\\n\\n    // --- Functions ---\\n\\n    /*\\n     * Called only once on init, to set addresses of other Hedgehog contracts\\n     * Callable only by owner, renounces ownership at the end\\n     */\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _baseFeeLMATokenAddress,\\n        address _sortedTrovesAddress,\\n        address _priceFeedAddress,\\n        address _communityIssuanceAddress\\n    ) external;\\n\\n    /*\\n     * Initial checks:\\n     * - _amount is not zero\\n     * ---\\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (HOG, WStETH) to depositor\\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint _amount) external;\\n\\n    /*\\n     * Initial checks:\\n     * - _amount is zero or there are no under collateralized troves left in the system\\n     * - User has a non zero deposit\\n     * ---\\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\\n     * - Removes the deposit's front end tag if it is a full withdrawal\\n     * - Sends all depositor's accumulated gains (HOG, WStETH) to depositor\\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint _amount) external;\\n\\n    /*\\n     * Initial checks:\\n     * - User has a non zero deposit\\n     * - User has an open trove\\n     * - User has some WStETH gain\\n     * ---\\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's HOG gain to  depositor\\n     * - Sends all tagged front end's HOG gain to the tagged front end\\n     * - Transfers the depositor's entire WStETH gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged front end stake\\n     */\\n    function withdrawWStETHGainToTrove(\\n        address _upperHint,\\n        address _lowerHint\\n    ) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Caller is TroveManager\\n     * ---\\n     * Cancels out the specified debt against the BaseFeeLMA contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's WStETH collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(uint _debt, uint _coll) external;\\n\\n    /*\\n     * Returns the total amount of WStETH held by the pool, accounted in an internal variable instead of `balance`,\\n     * to exclude edge cases like WStETH received from a self-destruct.\\n     */\\n    function getWStETH() external view returns (uint);\\n\\n    /*\\n     * Returns BaseFeeLMA held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n     */\\n    function getTotalBaseFeeLMADeposits() external view returns (uint);\\n\\n    /*\\n     * Calculates the WStETH gain earned by the deposit since its last snapshots were taken.\\n     */\\n    function getDepositorWStETHGain(\\n        address _depositor\\n    ) external view returns (uint);\\n\\n    /*\\n     * Calculate the HOG gain earned by a deposit since its last snapshots were taken.\\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\\n     * which they made their deposit.\\n     */\\n    function getDepositorHOGGain(\\n        address _depositor\\n    ) external view returns (uint);\\n\\n    /*\\n     * Return the user's compounded deposit.\\n     */\\n    function getCompoundedBaseFeeLMADeposit(\\n        address _depositor\\n    ) external view returns (uint);\\n}\\n\"\n    },\n    \"contracts/interfaces/ITroveManager.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./IHedgehogBase.sol\\\";\\nimport \\\"./IStabilityPool.sol\\\";\\nimport \\\"./IBaseFeeLMAToken.sol\\\";\\nimport \\\"./IHOGToken.sol\\\";\\n\\n// Common interface for the Trove Manager.\\ninterface ITroveManager is IHedgehogBase {\\n    // --- Events ---\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event HOGTokenAddressChanged(address _hogTokenAddress);\\n\\n    event Liquidation(\\n        uint _liquidatedDebt,\\n        uint _liquidatedColl,\\n        uint _collGasCompensation,\\n        uint _BaseFeeLMAGasCompensation\\n    );\\n    event Redemption(\\n        uint _attemptedBaseFeeLMAAmount,\\n        uint _actualBaseFeeLMAAmount,\\n        uint _WStETHSent,\\n        uint _WStETHFee\\n    );\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint stake,\\n        uint8 operation\\n    );\\n    event TroveLiquidated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint8 operation\\n    );\\n    event BaseRateUpdated(uint _baseRate);\\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\\n    event TotalStakesUpdated(uint _newTotalStakes);\\n    event SystemSnapshotsUpdated(\\n        uint _totalStakesSnapshot,\\n        uint _totalCollateralSnapshot\\n    );\\n    event LTermsUpdated(uint _L_WStETH, uint _L_BaseFeeLMADebt);\\n    event TroveSnapshotsUpdated(uint _L_WStETH, uint _L_BaseFeeLMADebt);\\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\\n\\n    // --- Functions ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _baseFeeLMATokenAddress,\\n        address _sortedTrovesAddress,\\n        address _hogTokenAddress\\n    ) external;\\n\\n    function stabilityPool() external view returns (IStabilityPool);\\n\\n    function baseFeeLMAToken() external view returns (IBaseFeeLMAToken);\\n\\n    function hogToken() external view returns (IHOGToken);\\n\\n    function getTroveOwnersCount() external view returns (uint);\\n\\n    function getTroveFromTroveOwnersArray(\\n        uint _index\\n    ) external view returns (address);\\n\\n    function getNominalICR(address _borrower) external view returns (uint);\\n\\n    function getCurrentICR(\\n        address _borrower,\\n        uint _price\\n    ) external view returns (uint);\\n\\n    function liquidate(address _borrower) external;\\n\\n    function liquidateTroves(uint _n) external;\\n\\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\\n\\n    function redeemCollateral(\\n        uint _BaseFeeLMAAmount,\\n        address _firstRedemptionHint,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR,\\n        uint _maxIterations,\\n        uint _maxFee\\n    ) external;\\n\\n    function updateStakeAndTotalStakes(\\n        address _borrower\\n    ) external returns (uint);\\n\\n    function updateTroveRewardSnapshots(address _borrower) external;\\n\\n    function addTroveOwnerToArray(\\n        address _borrower\\n    ) external returns (uint index);\\n\\n    function applyPendingRewards(address _borrower) external;\\n\\n    function getPendingWStETHReward(\\n        address _borrower\\n    ) external view returns (uint);\\n\\n    function getPendingBaseFeeLMADebtReward(\\n        address _borrower\\n    ) external view returns (uint);\\n\\n    function hasPendingRewards(address _borrower) external view returns (bool);\\n\\n    function getEntireDebtAndColl(\\n        address _borrower\\n    )\\n        external\\n        view\\n        returns (\\n            uint debt,\\n            uint coll,\\n            uint pendingBaseFeeLMADebtReward,\\n            uint pendingWStETHReward\\n        );\\n\\n    function closeTrove(address _borrower) external;\\n\\n    function removeStake(address _borrower) external;\\n\\n    function getRedemptionRate(\\n        uint _redemptionColl\\n    ) external view returns (uint);\\n\\n    function getRedemptionRateWithDecay(\\n        uint _redemptionColl\\n    ) external view returns (uint);\\n\\n    function getRedemptionFeeWithDecay(\\n        uint _WStETHDrawn\\n    ) external view returns (uint);\\n\\n    function getBorrowingRate(\\n        uint _issuedBaseFeeLMA\\n    ) external view returns (uint);\\n\\n    function getBorrowingRateWithDecay(\\n        uint _issuedBaseFeeLMA\\n    ) external view returns (uint);\\n\\n    function getBorrowingFee(\\n        uint BaseFeeLMADebt\\n    ) external view returns (uint, uint);\\n\\n    function getBorrowingFeeWithDecay(\\n        uint _BaseFeeLMADebt\\n    ) external view returns (uint);\\n\\n    function updateBaseRateFromBorrowing(uint _baseRate) external;\\n\\n    function decayBaseRateFromBorrowing() external;\\n\\n    function getTroveStatus(address _borrower) external view returns (uint);\\n\\n    function getTroveStake(address _borrower) external view returns (uint);\\n\\n    function getTroveDebt(address _borrower) external view returns (uint);\\n\\n    function getTroveColl(address _borrower) external view returns (uint);\\n\\n    function getTroveUpdateBlock(\\n        address _borrower\\n    ) external view returns (uint256);\\n\\n    function setTroveStatus(address _borrower, uint num) external;\\n\\n    function increaseTroveColl(\\n        address _borrower,\\n        uint _collIncrease\\n    ) external returns (uint);\\n\\n    function decreaseTroveColl(\\n        address _borrower,\\n        uint _collDecrease\\n    ) external returns (uint);\\n\\n    function increaseTroveDebt(\\n        address _borrower,\\n        uint _debtIncrease\\n    ) external returns (uint);\\n\\n    function decreaseTroveDebt(\\n        address _borrower,\\n        uint _collDecrease\\n    ) external returns (uint);\\n\\n    function setTroveLastUpdatedBlock(address _borrower) external;\\n\\n    function getTCR(uint _price) external view returns (uint);\\n\\n    function checkRecoveryMode(uint _price) external view returns (bool);\\n}\\n\"\n    },\n    \"contracts/LPRewards/TestContracts/TestPriceFeed.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"../../PriceFeed.sol\\\";\\n\\ncontract TestPriceFeed is PriceFeed {\\n    function setLastGoodPrice(uint _lastGoodPrice) external {\\n        lastGoodPrice = _lastGoodPrice;\\n    }\\n\\n    function setStatus(Status _status) external {\\n        status = _status;\\n    }\\n}\\n\"\n    },\n    \"contracts/PriceFeed.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/IBaseFeeOracle.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./dependencies/BaseMath.sol\\\";\\nimport \\\"./dependencies/LiquityMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nerror MainOracleDisabled();\\n\\n/*\\n * PriceFeed for production deployment, to be connected to Main Oracle's live BaseFee:WstETH aggregator reference\\n * contract, and a Backup oracle contract.\\n *\\n * The PriceFeed uses \\\"Main Oracle\\\" as primary oracle, and \\\"Back Up\\\" as fallback. It contains logic for\\n * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary\\n * \\\"Main Oracle\\\" oracle.\\n *\\n * Based on Liquity Protocol.\\n */\\ncontract PriceFeed is Ownable, BaseMath {\\n    string public constant NAME = \\\"PriceFeed\\\";\\n\\n    IBaseFeeOracle public mainOracle; // Main Oracle aggregator\\n    IBaseFeeOracle public backupOracle; // Backup Oracle\\n\\n    uint public constant TARGET_DIGITS = 18;\\n\\n    // Maximum time period allowed since Main Oracle's latest round data blockNumber, beyond which Main Oracle is considered frozen.\\n    uint public constant TIMEOUT = 69;\\n\\n    // HEDGEHOG UPDATES: decrease to 176\\n    // Maximum deviation allowed between two consecutive Main oracle prices. Hedgehog oracles are getting updated in case there is a 5% diviation price\\n    // Meaning that there might be max 17.5% price diviation between rounds\\n    uint public constant MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND =\\n        176;\\n\\n    /*\\n     * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed\\n     * to return to using the Main oracle. 18-digit precision.\\n     */\\n    uint public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%\\n\\n    // The last good price seen from an oracle by Hedgehog\\n    uint256 public lastGoodPrice;\\n\\n    struct Response {\\n        int256 answer;\\n        uint64 blockNumber;\\n        uint80 roundId;\\n    }\\n\\n    enum Status {\\n        mainOracleWorking,\\n        usingBackupMainUntrusted,\\n        bothOraclesUntrusted,\\n        usingBackupMainFrozen,\\n        usingMainBackupUntrusted\\n    }\\n\\n    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt\\n    Status public status;\\n\\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\\n    event PriceFeedStatusChanged(Status newStatus);\\n\\n    // --- Dependency setters ---\\n\\n    function setAddresses(\\n        address _mainOracleAddress,\\n        address _backupOracleAddress\\n    ) external onlyOwner {\\n        Address.isContract(_mainOracleAddress);\\n        Address.isContract(_backupOracleAddress);\\n\\n        mainOracle = IBaseFeeOracle(_mainOracleAddress);\\n        backupOracle = IBaseFeeOracle(_backupOracleAddress);\\n\\n        // Explicitly set initial system status\\n        status = Status.mainOracleWorking;\\n\\n        // Get an initial price from Main Oracle to serve as first reference for lastGoodPrice\\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\\n            mainOracleResponse.roundId\\n        );\\n\\n        if (\\n            _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse) ||\\n            _mainOracleIsFrozen(mainOracleResponse)\\n        ) {\\n            revert MainOracleDisabled();\\n        }\\n\\n        _storeGoodPrice(mainOracleResponse, mainOracle.decimals());\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Functions ---\\n\\n    /*\\n     * fetchPrice():\\n     * Returns the latest price obtained from the Oracle. Called by Hedgehog functions that require a current price.\\n     *\\n     * Also callable by anyone externally.\\n     *\\n     * Non-view function - it stores the last good price seen by Hedgehog.\\n     *\\n     * Uses a main oracle and a fallback oracle in case main one fails. If both fail,\\n     * it uses the last good price seen by Hedgehog.\\n     *\\n     * Hedgehog updates: now both oracles are not allowed to have a price diviation of more then 12.5% between consecutive block\\n     */\\n    function fetchPrice() external returns (uint256) {\\n        // Get current and previous price data from Main oracle, and current price data from Backup\\n        uint8 decimals = mainOracle.decimals();\\n\\n        Response memory mainOracleResponse = _getCurrentMainOracleResponse();\\n        Response memory prevMainOracleResponse = _getPrevOracleResponse(\\n            mainOracleResponse.roundId\\n        );\\n        Response memory backupOracleResponse = _getCurrentBackupResponse();\\n        Response memory prevBackupOracleResponse = _getPrevBackupOracleResponse(\\n            backupOracleResponse.roundId\\n        );\\n        uint8 backupDecimals = backupOracle.decimals();\\n\\n        // --- CASE 1: System fetched last price from Main Oracle  ---\\n        if (status == Status.mainOracleWorking) {\\n            // If Main Oracle is broken, try backup\\n\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                // If backup is broken then both oracles are untrusted, so return the last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n                /*\\n                 * If Backup is only frozen but otherwise returning valid data, return the last good price.\\n                 */\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    _changeStatus(Status.usingBackupMainUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Main Oracle is broken and Backup is working, switch to Backup and return current Backup price\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If Main oracle is frozen, try Backup\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                // If Backup is broken too, remember Backup broke, and return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.usingMainBackupUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is frozen or working, remember Main Oracle froze, and switch to backup\\n                _changeStatus(Status.usingBackupMainFrozen);\\n\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is working, use it\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If MainOracle price has changed by > 12,5% between two consecutive rounds, compare it to Backup's price\\n            if (\\n                _priceChangeAboveMax(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    decimals\\n                )\\n            ) {\\n                // If Backup is broken, both oracles are untrusted, and return last good price\\n                if (\\n                    _backupOracleIsBroken(backupOracleResponse) ||\\n                    _priceChangeAboveMax(\\n                        backupOracleResponse,\\n                        prevBackupOracleResponse,\\n                        backupDecimals\\n                    )\\n                ) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If backup is frozen, switch to backup and return last good price\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    _changeStatus(Status.usingBackupMainUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // If Main oracle is working and Backup is broken, remember Backup is broken\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.usingMainBackupUntrusted);\\n            }\\n\\n            // If MainOracle is working, return MainOracle current price (no status change)\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n\\n        // --- CASE 2: The system fetched last price from Backup ---\\n        if (status == Status.usingBackupMainUntrusted) {\\n            // If both Backup and Main oracle are live, unbroken, and reporting similar prices, switch back to Main\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            /*\\n             * If Backup is only frozen but otherwise returning valid data, just return the last good price.\\n             * Backup may need to be tipped to return current data.\\n             */\\n            if (_backupIsFrozen(backupOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            if (\\n                _priceChangeAboveMax(\\n                    backupOracleResponse,\\n                    prevBackupOracleResponse,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // Otherwise, use Backup price\\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n        }\\n\\n        // --- CASE 3: Both oracles were untrusted at the last price fetch ---\\n        if (status == Status.bothOraclesUntrusted) {\\n            /*\\n             * If both oracles are now live, unbroken and similar price, we assume that they are reporting\\n             * accurately, and so we switch back to Main Oracle.\\n             */\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // Otherwise, return the last good price - both oracles are still untrusted (no status change)\\n            return lastGoodPrice;\\n        }\\n\\n        // --- CASE 4: Using Backup, and Main Oracle is frozen ---\\n        if (status == Status.usingBackupMainFrozen) {\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                // If both Oracles are broken, return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.bothOraclesUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Main Oracle is broken, remember it and switch to using Backup\\n                _changeStatus(Status.usingBackupMainUntrusted);\\n\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // If Backup is working, return Backup current price\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                // if Main Oracle is frozen and Backup is broken, remember Backup broke, and return last good price\\n                if (_backupOracleIsBroken(backupOracleResponse)) {\\n                    _changeStatus(Status.usingMainBackupUntrusted);\\n                    return lastGoodPrice;\\n                }\\n\\n                // If both are frozen, just use lastGoodPrice\\n                if (_backupIsFrozen(backupOracleResponse)) {\\n                    return lastGoodPrice;\\n                }\\n\\n                // if Main Oracle is frozen and Backup is working, keep using Backup (no status change)\\n                return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n            }\\n\\n            // if Main Oracle is live and Backup is broken, remember Backup broke, and return Main Oracle price\\n            if (_backupOracleIsBroken(backupOracleResponse)) {\\n                _changeStatus(Status.usingMainBackupUntrusted);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // If Main Oracle is live and Backup is frozen, just use last good price (no status change) since we have no basis for comparison\\n            if (_backupIsFrozen(backupOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle is live and Backup is working, compare prices. Switch to Main Oracle\\n            // if prices are within 5%, and return Main Oracle price.\\n            if (\\n                _bothOraclesSimilarPrice(\\n                    mainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // Otherwise if Main Oracle is live but price not within 5% of Backup, distrust Main Oracle, and return Backup price\\n            _changeStatus(Status.usingBackupMainUntrusted);\\n            return _storeGoodPrice(backupOracleResponse, backupDecimals);\\n        }\\n\\n        // --- CASE 5: Using Main Oracle, Back up is untrusted ---\\n        if (status == Status.usingMainBackupUntrusted) {\\n            // If Main Oracle breaks, now both oracles are untrusted\\n            if (\\n                _mainOracleIsBroken(mainOracleResponse, prevMainOracleResponse)\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle is frozen, return last good price (no status change)\\n            if (_mainOracleIsFrozen(mainOracleResponse)) {\\n                return lastGoodPrice;\\n            }\\n\\n            // If Main Oracle and Backup are both live, unbroken and similar price, switch back to Main Oracle working and return MainOracle price\\n            if (\\n                _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    backupOracleResponse,\\n                    decimals,\\n                    backupDecimals\\n                )\\n            ) {\\n                _changeStatus(Status.mainOracleWorking);\\n                return _storeGoodPrice(mainOracleResponse, decimals);\\n            }\\n\\n            // If Main Oracle is live but deviated >17.5% from it's previous price and Backup is still untrusted, switch\\n            // to bothOraclesUntrusted and return last good price\\n            if (\\n                _priceChangeAboveMax(\\n                    mainOracleResponse,\\n                    prevMainOracleResponse,\\n                    decimals\\n                )\\n            ) {\\n                _changeStatus(Status.bothOraclesUntrusted);\\n                return lastGoodPrice;\\n            }\\n\\n            // Otherwise if Main Oracle is live and deviated <17.5% from it's previous price and Backup is still untrusted,\\n            // return Main Oracle price (no status change)\\n            return _storeGoodPrice(mainOracleResponse, decimals);\\n        }\\n    }\\n\\n    // --- Helper functions ---\\n\\n    /* Main Oracle is considered broken if its current or previous round data is in any way bad. We check the previous round\\n     * for two reasons:\\n     *\\n     * 1) It is necessary data for the price deviation check in case 1,\\n     * and\\n     * 2) Main Oracle is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds\\n     * peace of mind when using or returning to Main Oracle.\\n     */\\n    function _mainOracleIsBroken(\\n        Response memory _currentResponse,\\n        Response memory _prevResponse\\n    ) internal view returns (bool) {\\n        return\\n            _badMainOracleResponse(_currentResponse) ||\\n            _badMainOracleResponse(_prevResponse);\\n    }\\n\\n    function _badMainOracleResponse(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        // Check for an invalid roundId that is 0\\n        if (_response.roundId == 0) {\\n            return true;\\n        }\\n        // Check for an invalid timeStamp that is 0, or in the future\\n        if (\\n            _response.blockNumber == 0 || _response.blockNumber > block.number\\n        ) {\\n            return true;\\n        }\\n        // Check for non-positive price\\n        if (_response.answer <= 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _mainOracleIsFrozen(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        return (block.number - _response.blockNumber) > TIMEOUT;\\n    }\\n\\n    function _priceChangeAboveMax(\\n        Response memory _currentResponse,\\n        Response memory _prevResponse,\\n        uint8 _decimals\\n    ) internal pure returns (bool) {\\n        uint currentScaledPrice = _scalePriceByDigits(\\n            uint256(_currentResponse.answer),\\n            _decimals\\n        );\\n        uint prevScaledPrice = _scalePriceByDigits(\\n            uint256(_prevResponse.answer),\\n            _decimals\\n        );\\n\\n        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);\\n        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);\\n\\n        /*\\n         * Use the larger price as the denominator:\\n         * - If price decreased, the percentage deviation is in relation to the the previous price.\\n         * - If price increased, the percentage deviation is in relation to the current price.\\n         */\\n        uint difference = maxPrice - minPrice;\\n        uint threshold = (maxPrice *\\n            MAX_PRICE_DEVIATION_PERCENTAGE_FROM_PREVIOUS_ROUND) / 1000; // 17.5% of max price\\n\\n        // Return true if price has more than doubled, or more than halved.\\n        return difference > threshold;\\n    }\\n\\n    function _backupOracleIsBroken(\\n        Response memory _response\\n    ) internal view returns (bool) {\\n        // Check for an invalid timeStamp that is 0, or in the future\\n        if (\\n            _response.blockNumber == 0 || _response.blockNumber > block.number\\n        ) {\\n            return true;\\n        }\\n        // Check for zero price\\n        if (_response.answer == 0) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _backupIsFrozen(\\n        Response memory _backupResponse\\n    ) internal view returns (bool) {\\n        return block.number - _backupResponse.blockNumber > TIMEOUT;\\n    }\\n\\n    function _bothOraclesLiveAndUnbrokenAndSimilarPrice(\\n        Response memory _mainOracleResponse,\\n        Response memory _prevMainOracleResponse,\\n        Response memory _backupResponse,\\n        uint8 _mainOracleDecimals,\\n        uint8 _backupOracleDecimals\\n    ) internal view returns (bool) {\\n        // Return false if either oracle is broken or frozen\\n        if (\\n            _backupOracleIsBroken(_backupResponse) ||\\n            _backupIsFrozen(_backupResponse) ||\\n            _mainOracleIsBroken(_mainOracleResponse, _prevMainOracleResponse) ||\\n            _mainOracleIsFrozen(_mainOracleResponse)\\n        ) {\\n            return false;\\n        }\\n\\n        return\\n            _bothOraclesSimilarPrice(\\n                _mainOracleResponse,\\n                _backupResponse,\\n                _mainOracleDecimals,\\n                _backupOracleDecimals\\n            );\\n    }\\n\\n    function _bothOraclesSimilarPrice(\\n        Response memory _mainOracleResponse,\\n        Response memory _backupResponse,\\n        uint8 _mainOracleDecimals,\\n        uint8 _backupOracleDecimals\\n    ) internal pure returns (bool) {\\n        uint scaledMainOraclePrice = _scalePriceByDigits(\\n            uint256(_mainOracleResponse.answer),\\n            _mainOracleDecimals\\n        );\\n        uint scaledBackupPrice = _scalePriceByDigits(\\n            uint256(_backupResponse.answer),\\n            _backupOracleDecimals\\n        );\\n\\n        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.\\n        uint minPrice = LiquityMath._min(\\n            scaledBackupPrice,\\n            scaledMainOraclePrice\\n        );\\n        uint maxPrice = LiquityMath._max(\\n            scaledBackupPrice,\\n            scaledMainOraclePrice\\n        );\\n        uint percentPriceDifference = ((maxPrice - minPrice) *\\n            DECIMAL_PRECISION) / minPrice;\\n\\n        /*\\n         * Return true if the relative price difference is <= 5%: if so, we assume both oracles are probably reporting\\n         * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.\\n         */\\n        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;\\n    }\\n\\n    function _scalePriceByDigits(\\n        uint _price,\\n        uint _answerDigits\\n    ) internal pure returns (uint) {\\n        /*\\n         * Convert the price returned by an oracle to an 18-digit decimal for use by Hedgehog.\\n         * At date of Hedgehog launch, MaainOracle uses an 8-digit price, but we also handle the possibility of\\n         * future changes.\\n         */\\n        uint price;\\n        if (_answerDigits >= TARGET_DIGITS) {\\n            // Scale the returned price value down to Hedgehog's target precision\\n            price = _price / (10 ** (_answerDigits - TARGET_DIGITS));\\n        } else if (_answerDigits < TARGET_DIGITS) {\\n            // Scale the returned price value up to Hedgehog's target precision\\n            price = _price * (10 ** (TARGET_DIGITS - _answerDigits));\\n        }\\n        return price;\\n    }\\n\\n    function _changeStatus(Status _status) internal {\\n        status = _status;\\n        emit PriceFeedStatusChanged(_status);\\n    }\\n\\n    function _storePrice(uint _currentPrice) internal {\\n        lastGoodPrice = _currentPrice;\\n        emit LastGoodPriceUpdated(_currentPrice);\\n    }\\n\\n    function _storeGoodPrice(\\n        Response memory _response,\\n        uint8 _decimals\\n    ) internal returns (uint) {\\n        uint scaledPrice = _scalePriceByDigits(\\n            uint256(_response.answer),\\n            _decimals\\n        );\\n\\n        _storePrice(scaledPrice);\\n\\n        return scaledPrice;\\n    }\\n\\n    function _getCurrentMainOracleResponse()\\n        internal\\n        view\\n        returns (Response memory response)\\n    {\\n        // Try to get latest price data:\\n        try mainOracle.latestRoundData() returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            response.roundId = roundId;\\n            response.answer = answer;\\n            response.blockNumber = uint64(currentChainBN);\\n\\n            return response;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts\\n            return response;\\n        }\\n    }\\n\\n    function _getCurrentBackupResponse()\\n        internal\\n        view\\n        returns (Response memory response)\\n    {\\n        // Try to get latest price data:\\n        try backupOracle.latestRoundData() returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            response.roundId = roundId;\\n            response.answer = answer;\\n            response.blockNumber = uint64(currentChainBN);\\n\\n            return response;\\n        } catch {\\n            // If call to Backup aggregator reverts with empty response\\n            return response;\\n        }\\n    }\\n\\n    function _getPrevOracleResponse(\\n        uint80 _currentRoundId\\n    ) internal view returns (Response memory prevMainOracleResponse) {\\n        /*\\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\\n         */\\n\\n        // Try to get the price data from the previous round:\\n        try mainOracle.getRoundData(_currentRoundId - 1) returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            // If call to Hedgehog succeeds, return the response and success = true\\n            prevMainOracleResponse.roundId = roundId;\\n            prevMainOracleResponse.answer = answer;\\n            prevMainOracleResponse.blockNumber = uint64(currentChainBN);\\n            return prevMainOracleResponse;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts\\n            return prevMainOracleResponse;\\n        }\\n    }\\n\\n    function _getPrevBackupOracleResponse(\\n        uint80 _currentRoundId\\n    ) internal view returns (Response memory prevBackupOracleResponse) {\\n        /*\\n         * NOTE: Oracle only offers a current decimals() value - there is no way to obtain the decimal precision used in a\\n         * previous round.  We assume the decimals used in the previous round are the same as the current round.\\n         */\\n\\n        // Try to get the price data from the previous round:\\n        try backupOracle.getRoundData(_currentRoundId - 1) returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 blockNumber,\\n            uint256 currentChainBN,\\n            uint80 __roundId\\n        ) {\\n            // If call to Hedgehog succeeds, return the response and success = true\\n            prevBackupOracleResponse.roundId = roundId;\\n            prevBackupOracleResponse.answer = answer;\\n            prevBackupOracleResponse.blockNumber = uint64(currentChainBN);\\n            return prevBackupOracleResponse;\\n        } catch {\\n            // If call to Main Oracle aggregator reverts\\n            return prevBackupOracleResponse;\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/StabilityPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/IBorrowerOperations.sol\\\";\\nimport \\\"./interfaces/IStabilityPool.sol\\\";\\nimport \\\"./interfaces/IBorrowerOperations.sol\\\";\\nimport \\\"./interfaces/ITroveManager.sol\\\";\\nimport \\\"./interfaces/IBaseFeeLMAToken.sol\\\";\\nimport \\\"./interfaces/ISortedTroves.sol\\\";\\nimport \\\"./interfaces/ICommunityIssuance.sol\\\";\\nimport \\\"./dependencies/HedgehogBase.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./dependencies/LiquitySafeMath128.sol\\\";\\nimport \\\"./dependencies/CheckContract.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @notice Fork of Liquity's Stability Pool. Logic remains unchanged.\\n * Changes to the contract:\\n * - Raised pragma version\\n * - Removed an import of IStabilityPool Interface\\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\\n *\\n * The Stability Pool holds BaseFeeLMA tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its BaseFeeLMA debt gets offset with\\n * BaseFeeLMA in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of BaseFeeLMA tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a BaseFeeLMA loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an WStETH gain, as the WStETH collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total BaseFeeLMA in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n *\\n * --- IMPLEMENTATION ---\\n *\\n * We use a highly scalable method of tracking deposits and WStETH gains that has O(1) complexity.\\n *\\n * When a liquidation occurs, rather than updating each depositor's deposit and WStETH gain, we simply update two state variables:\\n * a product P, and a sum S.\\n *\\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\\n * and accumulated WStETH gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\\n *\\n * The formula for a depositor's accumulated WStETH gain is derived here:\\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\n *\\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated WStETH gain.\\n *\\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding WStETH gain\\n * can be calculated using the initial deposit, the depositors snapshots of P and S, and the latest values of P and S.\\n *\\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated WStETH gain is paid out, their new deposit is recorded\\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\\n * Essentially, they make a fresh deposit that overwrites the old one.\\n *\\n *\\n * --- SCALE FACTOR ---\\n *\\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\\n *\\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\\n *\\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\\n *\\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\\n * order of 1e-9.\\n *\\n * --- EPOCHS ---\\n *\\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\\n * forever, and break all future reward calculations.\\n *\\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\\n *\\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\\n *\\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\\n *\\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\\n *\\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion BaseFeeLMA has depleted to < 1 BaseFeeLMA).\\n *\\n *\\n *  --- TRACKING DEPOSITOR'S WStETH GAIN OVER SCALE CHANGES AND EPOCHS ---\\n *\\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\\n *\\n * This allows us to calculate a deposit's accumulated WStETH gain, during the epoch in which the deposit was non-zero and earned WStETH.\\n *\\n * We calculate the depositor's accumulated WStETH gain for the scale at which they made the deposit, using the WStETH gain formula:\\n * e_1 = d_t * (S - S_t) / P_t\\n *\\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\\n * e_2 = d_t * S / (P_t * 1e9)\\n *\\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\\n * The deposit therefore was present for reward events from the beginning of that second scale.\\n *\\n *        S_i-S_t + S_{i+1}\\n *      .<--------.------------>\\n *      .         .\\n *      . S_i     .   S_{i+1}\\n *   <--.-------->.<----------->\\n *   S_t.         .\\n *   <->.         .\\n *      t         .\\n *  |---+---------|-------------|-----...\\n *         i            i+1\\n *\\n * The sum of (e_1 + e_2) captures the depositor's total accumulated WStETH gain, handling the case where their\\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\\n * deposit is defined as being 0 once it has spanned more than one scale change.\\n *\\n *\\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\\n *\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / WStETH gain derivations:\\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\n *\\n *\\n * --- HOG ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * A HOG issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued HOG in proportion to the deposit as a share of total deposits. The HOG earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n * Please see the system Readme for an overview:\\n * https://github.com/liquity/dev/blob/main/README.md#hog-issuance-to-stability-providers\\n *\\n * We use the same mathematical product-sum approach to track HOG gains for depositors, where 'G' is the sum corresponding to HOG gains.\\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\\n *\\n */\\ncontract StabilityPool is HedgehogBase, Ownable, CheckContract {\\n    using LiquitySafeMath128 for uint128;\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    string public constant NAME = \\\"StabilityPool\\\";\\n\\n    IBorrowerOperations public borrowerOperations;\\n\\n    ITroveManager public troveManager;\\n\\n    IBaseFeeLMAToken public baseFeeLMAToken;\\n\\n    // Needed to check if there are pending liquidations\\n    ISortedTroves public sortedTroves;\\n\\n    ICommunityIssuance public communityIssuance;\\n\\n    uint256 internal WStETH; // deposited wStETH tracker\\n    IERC20 public WStETHToken;\\n\\n    // Tracker for BaseFeeLMA held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n    uint256 internal totalBaseFeeLMADeposits;\\n\\n    // --- Data structures ---\\n\\n    struct Deposit {\\n        uint initialValue;\\n    }\\n\\n    struct Snapshots {\\n        uint S;\\n        uint P;\\n        uint G;\\n        uint128 scale;\\n        uint128 epoch;\\n    }\\n\\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\\n\\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\\n     * after a series of liquidations have occurred, each of which cancel some BaseFeeLMA debt with the deposit.\\n     *\\n     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\\n     */\\n    uint public P = DECIMAL_PRECISION;\\n\\n    uint public constant SCALE_FACTOR = 1e9;\\n\\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\\n    uint128 public currentScale;\\n\\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\\n    uint128 public currentEpoch;\\n\\n    /* WStETH Gain sum 'S': During its lifetime, each deposit d_t earns an WStETH gain of ( d_t * [S - S_t] )/P_t, where S_t\\n     * is the depositor's snapshot of S taken at the time t when the deposit was made.\\n     *\\n     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\\n     *\\n     * - The inner mapping records the sum S at different scales\\n     * - The outer mapping records the (scale => sum) mappings, for different epochs.\\n     */\\n    mapping(uint128 => mapping(uint128 => uint)) public epochToScaleToSum;\\n\\n    /*\\n     * Similarly, the sum 'G' is used to calculate HOG gains. During it's lifetime, each deposit d_t earns a HOG gain of\\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\\n     *\\n     *  HOG reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\\n     *  In each case, the HOG reward is issued (i.e. G is updated), before other state changes are made.\\n     */\\n    mapping(uint128 => mapping(uint128 => uint)) public epochToScaleToG;\\n\\n    // Error tracker for the error correction in the HOG issuance calculation\\n    uint public lastHOGError;\\n    // Error trackers for the error correction in the offset calculation\\n    uint public lastWStETHError_Offset;\\n    uint public lastBaseFeeLMALossError_Offset;\\n\\n    // --- Events ---\\n\\n    event StabilityPoolWStETHBalanceUpdated(uint _newBalance);\\n    event StabilityPoolBaseFeeLMABalanceUpdated(uint _newBalance);\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\\n    event WStETHTokenAddressUpdated(IERC20 _WStEthAddress);\\n\\n    event P_Updated(uint _P);\\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\\n    event EpochUpdated(uint128 _currentEpoch);\\n    event ScaleUpdated(uint128 _currentScale);\\n\\n    event DepositSnapshotUpdated(\\n        address indexed _depositor,\\n        uint _P,\\n        uint _S,\\n        uint _G\\n    );\\n\\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\\n\\n    event WStETHGainWithdrawn(\\n        address indexed _depositor,\\n        uint _WStETH,\\n        uint _BaseFeeLMALoss\\n    );\\n    event HOGPaidToDepositor(address indexed _depositor, uint _HOG);\\n    event WStETHSent(address _to, uint _amount);\\n\\n    // --- Contract setters ---\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * ERC20 is used as a collateral instead of native token.\\n     * Setting erc20 address in the initialisation\\n     */\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _baseFeeLMATokenAddress,\\n        address _sortedTrovesAddress,\\n        address _priceFeedAddress,\\n        address _communityIssuanceAddress,\\n        IERC20 _WStETHTokenAddress\\n    ) external onlyOwner {\\n        checkContract(_borrowerOperationsAddress);\\n        checkContract(_troveManagerAddress);\\n        checkContract(_activePoolAddress);\\n        checkContract(_baseFeeLMATokenAddress);\\n        checkContract(_sortedTrovesAddress);\\n        checkContract(_priceFeedAddress);\\n        checkContract(_communityIssuanceAddress);\\n        checkContract(address(_WStETHTokenAddress));\\n\\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\\n        troveManager = ITroveManager(_troveManagerAddress);\\n        activePool = IActivePool(_activePoolAddress);\\n        baseFeeLMAToken = IBaseFeeLMAToken(_baseFeeLMATokenAddress);\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\\n        WStETHToken = _WStETHTokenAddress;\\n\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\n        emit ActivePoolAddressChanged(_activePoolAddress);\\n        emit BaseFeeLMATokenAddressChanged(_baseFeeLMATokenAddress);\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\n        emit PriceFeedAddressChanged(_priceFeedAddress);\\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\\n        emit WStETHTokenAddressUpdated(_WStETHTokenAddress);\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Getters for public variables. Required by IPool interface ---\\n\\n    function getWStETH() external view returns (uint) {\\n        return WStETH;\\n    }\\n\\n    function getTotalBaseFeeLMADeposits() external view returns (uint) {\\n        return totalBaseFeeLMADeposits;\\n    }\\n\\n    // --- External Depositor Functions ---\\n\\n    /*  provideToSP():\\n     *\\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (HOG, WStETH) to depositor\\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint _amount) external {\\n        _requireNonZeroAmount(_amount);\\n\\n        uint initialDeposit = deposits[msg.sender].initialValue;\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerHOGIssuance(communityIssuanceCached);\\n\\n        uint depositorWStETHGain = getDepositorWStETHGain(msg.sender);\\n        uint compoundedBaseFeeLMADeposit = getCompoundedBaseFeeLMADeposit(\\n            msg.sender\\n        );\\n        uint BaseFeeLMALoss = initialDeposit.sub(compoundedBaseFeeLMADeposit); // Needed only for event log\\n\\n        // HEDGEHOG UPDATES: No longer perform any kind of \\\"frontend\\\" payments\\n        // First pay out any HOG gains\\n        _payOutHOGGains(communityIssuanceCached, msg.sender);\\n\\n        _sendBaseFeeLMAtoStabilityPool(msg.sender, _amount);\\n\\n        uint newDeposit = compoundedBaseFeeLMADeposit.add(_amount);\\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\\n        emit UserDepositChanged(msg.sender, newDeposit);\\n\\n        emit WStETHGainWithdrawn(\\n            msg.sender,\\n            depositorWStETHGain,\\n            BaseFeeLMALoss\\n        ); // BaseFeeLMA Loss required for event log\\n\\n        _sendWStETHGainToDepositor(depositorWStETHGain);\\n    }\\n\\n    /*  withdrawFromSP():\\n     *\\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\\n     * - Removes the deposit's front end tag if it is a full withdrawal\\n     * - Sends all depositor's accumulated gains (HOG, WStETH) to depositor\\n     * - Sends the tagged front end's accumulated HOG gains to the tagged front end\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint _amount) external {\\n        if (_amount != 0) {\\n            _requireNoUnderCollateralizedTroves();\\n        }\\n        uint initialDeposit = deposits[msg.sender].initialValue;\\n        _requireUserHasDeposit(initialDeposit);\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerHOGIssuance(communityIssuanceCached);\\n\\n        uint depositorWStETHGain = getDepositorWStETHGain(msg.sender);\\n\\n        uint compoundedBaseFeeLMADeposit = getCompoundedBaseFeeLMADeposit(\\n            msg.sender\\n        );\\n        uint BaseFeeLMAtoWithdraw = LiquityMath._min(\\n            _amount,\\n            compoundedBaseFeeLMADeposit\\n        );\\n        uint BaseFeeLMALoss = initialDeposit.sub(compoundedBaseFeeLMADeposit); // Needed only for event log\\n\\n        // HEDGEHOG UPDATES: No longer perform any kind of \\\"frontend\\\" payments\\n        // First pay out any HOG gains\\n        _payOutHOGGains(communityIssuanceCached, msg.sender);\\n\\n        _sendBaseFeeLMAToDepositor(msg.sender, BaseFeeLMAtoWithdraw);\\n\\n        // Update deposit\\n        uint newDeposit = compoundedBaseFeeLMADeposit.sub(BaseFeeLMAtoWithdraw);\\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\\n        emit UserDepositChanged(msg.sender, newDeposit);\\n\\n        emit WStETHGainWithdrawn(\\n            msg.sender,\\n            depositorWStETHGain,\\n            BaseFeeLMALoss\\n        ); // BaseFeeLMA Loss required for event log\\n\\n        _sendWStETHGainToDepositor(depositorWStETHGain);\\n    }\\n\\n    /* withdrawWStETHGainToTrove:\\n\\n     * HEDGEHOG UPDATES: use SafeERC20 safe transfer instead of native token transfer. Therefore \\n     * transfer value isn't paste anymore as a {value: }, but as a separate input param\\n\\n     * - Triggers a HOG issuance, based on time passed since the last issuance. The HOG issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's HOG gain to  depositor\\n     * - Sends all tagged front end's HOG gain to the tagged front end\\n     * - Transfers the depositor's entire WStETH gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged front end stake */\\n    function withdrawWStETHGainToTrove(\\n        address _upperHint,\\n        address _lowerHint\\n    ) external {\\n        uint initialDeposit = deposits[msg.sender].initialValue;\\n        _requireUserHasDeposit(initialDeposit);\\n        _requireUserHasTrove(msg.sender);\\n        _requireUserHasWStETHGain(msg.sender);\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerHOGIssuance(communityIssuanceCached);\\n\\n        uint depositorWStETHGain = getDepositorWStETHGain(msg.sender);\\n\\n        uint compoundedBaseFeeLMADeposit = getCompoundedBaseFeeLMADeposit(\\n            msg.sender\\n        );\\n        uint BaseFeeLMALoss = initialDeposit.sub(compoundedBaseFeeLMADeposit); // Needed only for event log\\n\\n        // HEDGEHOG UPDATES: No longer perform any kind of \\\"frontend\\\" payments\\n        // First pay out any HOG gains\\n        _payOutHOGGains(communityIssuanceCached, msg.sender);\\n\\n        _updateDepositAndSnapshots(msg.sender, compoundedBaseFeeLMADeposit);\\n\\n        /* Emit events before transferring WStETH gain to Trove.\\n         This lets the event log make more sense (i.e. so it appears that first the WStETH gain is withdrawn\\n        and then it is deposited into the Trove, not the other way around). */\\n        emit WStETHGainWithdrawn(\\n            msg.sender,\\n            depositorWStETHGain,\\n            BaseFeeLMALoss\\n        );\\n        emit UserDepositChanged(msg.sender, compoundedBaseFeeLMADeposit);\\n\\n        WStETH = WStETH.sub(depositorWStETHGain);\\n        emit StabilityPoolWStETHBalanceUpdated(WStETH);\\n        emit WStETHSent(msg.sender, depositorWStETHGain);\\n\\n        // Hedgehog Updates: now have to cast an approve to allow BO move collToken from the stability pool\\n        WStETHToken.approve(address(borrowerOperations), depositorWStETHGain);\\n        borrowerOperations.moveWStETHGainToTrove(\\n            msg.sender,\\n            _upperHint,\\n            _lowerHint,\\n            depositorWStETHGain\\n        );\\n    }\\n\\n    // --- HOG issuance functions ---\\n\\n    function _triggerHOGIssuance(\\n        ICommunityIssuance _communityIssuance\\n    ) internal {\\n        uint HOGIssuance = _communityIssuance.issueHOG();\\n        _updateG(HOGIssuance);\\n    }\\n\\n    function _updateG(uint _HOGIssuance) internal {\\n        uint totalBaseFeeLMA = totalBaseFeeLMADeposits; // cached to save an SLOAD\\n        /*\\n         * When total deposits is 0, G is not updated. In this case, the HOG issued can not be obtained by later\\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\\n         *\\n         */\\n        if (totalBaseFeeLMA == 0 || _HOGIssuance == 0) {\\n            return;\\n        }\\n\\n        uint HOGPerUnitStaked;\\n        HOGPerUnitStaked = _computeHOGPerUnitStaked(\\n            _HOGIssuance,\\n            totalBaseFeeLMA\\n        );\\n\\n        uint marginalHOGGain = HOGPerUnitStaked.mul(P);\\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[\\n            currentEpoch\\n        ][currentScale].add(marginalHOGGain);\\n\\n        emit G_Updated(\\n            epochToScaleToG[currentEpoch][currentScale],\\n            currentEpoch,\\n            currentScale\\n        );\\n    }\\n\\n    function _computeHOGPerUnitStaked(\\n        uint _HOGIssuance,\\n        uint _totalBaseFeeLMADeposits\\n    ) internal returns (uint) {\\n        /*\\n         * Calculate the HOG-per-unit staked.  Division uses a \\\"feedback\\\" error correction, to keep the\\n         * cumulative error low in the running total G:\\n         *\\n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\\n         * function was called.\\n         * 2) Calculate \\\"per-unit-staked\\\" ratio.\\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\\n         * 4) Store this error for use in the next correction when this function is called.\\n         * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n         */\\n        uint HOGNumerator = _HOGIssuance.mul(DECIMAL_PRECISION).add(\\n            lastHOGError\\n        );\\n\\n        uint HOGPerUnitStaked = HOGNumerator.div(_totalBaseFeeLMADeposits);\\n        lastHOGError = HOGNumerator.sub(\\n            HOGPerUnitStaked.mul(_totalBaseFeeLMADeposits)\\n        );\\n\\n        return HOGPerUnitStaked;\\n    }\\n\\n    // --- Liquidation functions ---\\n\\n    /*\\n     * Cancels out the specified debt against the BaseFeeLMA contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's WStETH collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(uint _debtToOffset, uint _collToAdd) external {\\n        _requireCallerIsTroveManager();\\n        uint totalBaseFeeLMA = totalBaseFeeLMADeposits; // cached to save an SLOAD\\n        if (totalBaseFeeLMA == 0 || _debtToOffset == 0) {\\n            return;\\n        }\\n\\n        _triggerHOGIssuance(communityIssuance);\\n\\n        (\\n            uint WStETHGainPerUnitStaked,\\n            uint BaseFeeLMALossPerUnitStaked\\n        ) = _computeRewardsPerUnitStaked(\\n                _collToAdd,\\n                _debtToOffset,\\n                totalBaseFeeLMA\\n            );\\n\\n        _updateRewardSumAndProduct(\\n            WStETHGainPerUnitStaked,\\n            BaseFeeLMALossPerUnitStaked\\n        ); // updates S and P\\n\\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\\n    }\\n\\n    // --- Offset helper functions ---\\n\\n    function _computeRewardsPerUnitStaked(\\n        uint _collToAdd,\\n        uint _debtToOffset,\\n        uint _totalBaseFeeLMADeposits\\n    )\\n        internal\\n        returns (uint WStETHGainPerUnitStaked, uint BaseFeeLMALossPerUnitStaked)\\n    {\\n        /*\\n         * Compute the BaseFeeLMA and WStETH rewards. Uses a \\\"feedback\\\" error correction, to keep\\n         * the cumulative error in the P and S state variables low:\\n         *\\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\\n         * function was called.\\n         * 2) Calculate \\\"per-unit-staked\\\" ratios.\\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\\n         * 4) Store these errors for use in the next correction when this function is called.\\n         * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n         */\\n        uint WStETHNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(\\n            lastWStETHError_Offset\\n        );\\n\\n        assert(_debtToOffset <= _totalBaseFeeLMADeposits);\\n        if (_debtToOffset == _totalBaseFeeLMADeposits) {\\n            BaseFeeLMALossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\\n            lastBaseFeeLMALossError_Offset = 0;\\n        } else {\\n            uint BaseFeeLMALossNumerator = _debtToOffset\\n                .mul(DECIMAL_PRECISION)\\n                .sub(lastBaseFeeLMALossError_Offset);\\n            /*\\n             * Add 1 to make error in quotient positive. We want \\\"slightly too much\\\" BaseFeeLMA loss,\\n             * which ensures the error in any given compoundedBaseFeeLMADeposit favors the Stability Pool.\\n             */\\n            BaseFeeLMALossPerUnitStaked = (\\n                BaseFeeLMALossNumerator.div(_totalBaseFeeLMADeposits)\\n            ).add(1);\\n            lastBaseFeeLMALossError_Offset = (\\n                BaseFeeLMALossPerUnitStaked.mul(_totalBaseFeeLMADeposits)\\n            ).sub(BaseFeeLMALossNumerator);\\n        }\\n\\n        WStETHGainPerUnitStaked = WStETHNumerator.div(_totalBaseFeeLMADeposits);\\n        lastWStETHError_Offset = WStETHNumerator.sub(\\n            WStETHGainPerUnitStaked.mul(_totalBaseFeeLMADeposits)\\n        );\\n\\n        return (WStETHGainPerUnitStaked, BaseFeeLMALossPerUnitStaked);\\n    }\\n\\n    // Update the Stability Pool reward sum S and product P\\n    function _updateRewardSumAndProduct(\\n        uint _WStETHGainPerUnitStaked,\\n        uint _BaseFeeLMALossPerUnitStaked\\n    ) internal {\\n        uint currentP = P;\\n        uint newP;\\n\\n        assert(_BaseFeeLMALossPerUnitStaked <= DECIMAL_PRECISION);\\n        /*\\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool BaseFeeLMA in the liquidation.\\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - BaseFeeLMALossPerUnitStaked)\\n         */\\n        uint newProductFactor = uint(DECIMAL_PRECISION).sub(\\n            _BaseFeeLMALossPerUnitStaked\\n        );\\n\\n        uint128 currentScaleCached = currentScale;\\n        uint128 currentEpochCached = currentEpoch;\\n        uint currentS = epochToScaleToSum[currentEpochCached][\\n            currentScaleCached\\n        ];\\n\\n        /*\\n         * Calculate the new S first, before we update P.\\n         * The WStETH gain for any given depositor from a liquidation depends on the value of their deposit\\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\\n         *\\n         * Since S corresponds to WStETH gain, and P to deposit loss, we update S first.\\n         */\\n        uint marginalWStETHGain = _WStETHGainPerUnitStaked.mul(currentP);\\n        uint newS = currentS.add(marginalWStETHGain);\\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\\n\\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\\n        if (newProductFactor == 0) {\\n            currentEpoch = currentEpochCached.add(1);\\n            emit EpochUpdated(currentEpoch);\\n            currentScale = 0;\\n            emit ScaleUpdated(currentScale);\\n            newP = DECIMAL_PRECISION;\\n\\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\\n        } else if (\\n            currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR\\n        ) {\\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(\\n                DECIMAL_PRECISION\\n            );\\n            currentScale = currentScaleCached.add(1);\\n            emit ScaleUpdated(currentScale);\\n        } else {\\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\\n        }\\n\\n        assert(newP > 0);\\n        P = newP;\\n\\n        emit P_Updated(newP);\\n    }\\n\\n    function _moveOffsetCollAndDebt(\\n        uint _collToAdd,\\n        uint _debtToOffset\\n    ) internal {\\n        IActivePool activePoolCached = activePool;\\n\\n        // Cancel the liquidated BaseFeeLMA debt with the BaseFeeLMA in the stability pool\\n        activePoolCached.decreaseBaseFeeLMADebt(_debtToOffset);\\n        _decreaseBaseFeeLMA(_debtToOffset);\\n\\n        // Burn the debt that was successfully offset\\n        baseFeeLMAToken.burn(address(this), _debtToOffset);\\n\\n        _increaseBalance(_collToAdd);\\n        activePoolCached.sendWStETH(address(this), _collToAdd);\\n    }\\n\\n    function _decreaseBaseFeeLMA(uint _amount) internal {\\n        uint newTotalBaseFeeLMADeposits = totalBaseFeeLMADeposits.sub(_amount);\\n        totalBaseFeeLMADeposits = newTotalBaseFeeLMADeposits;\\n        emit StabilityPoolBaseFeeLMABalanceUpdated(newTotalBaseFeeLMADeposits);\\n    }\\n\\n    // --- Reward calculator functions for depositor and front end ---\\n\\n    /* Calculates the WStETH gain earned by the deposit since its last snapshots were taken.\\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\\n     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\\n     * d0 is the last recorded deposit value.\\n     */\\n    function getDepositorWStETHGain(\\n        address _depositor\\n    ) public view returns (uint) {\\n        uint initialDeposit = deposits[_depositor].initialValue;\\n\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint WStETHGain = _getWStETHGainFromSnapshots(\\n            initialDeposit,\\n            snapshots\\n        );\\n        return WStETHGain;\\n    }\\n\\n    function _getWStETHGainFromSnapshots(\\n        uint initialDeposit,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint) {\\n        /*\\n         * Grab the sum 'S' from the epoch at which the stake was made. The WStETH gain may span up to one scale change.\\n         * If it does, the second portion of the WStETH gain is scaled by 1e9.\\n         * If the gain spans no scale change, the second portion will be 0.\\n         */\\n        uint128 epochSnapshot = snapshots.epoch;\\n        uint128 scaleSnapshot = snapshots.scale;\\n        uint S_Snapshot = snapshots.S;\\n        uint P_Snapshot = snapshots.P;\\n\\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(\\n            S_Snapshot\\n        );\\n        uint secondPortion = epochToScaleToSum[epochSnapshot][\\n            scaleSnapshot.add(1)\\n        ].div(SCALE_FACTOR);\\n\\n        uint WStETHGain = initialDeposit\\n            .mul(firstPortion.add(secondPortion))\\n            .div(P_Snapshot)\\n            .div(DECIMAL_PRECISION);\\n\\n        return WStETHGain;\\n    }\\n\\n    /*\\n     * Calculate the HOG gain earned by a deposit since its last snapshots were taken.\\n     * Given by the formula:  HOG = d0 * (G - G(0))/P(0)\\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\\n     * d0 is the last recorded deposit value.\\n     */\\n    function getDepositorHOGGain(\\n        address _depositor\\n    ) public view returns (uint) {\\n        uint initialDeposit = deposits[_depositor].initialValue;\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint HOGGain = _getHOGGainFromSnapshots(initialDeposit, snapshots);\\n\\n        return HOGGain;\\n    }\\n\\n    function _getHOGGainFromSnapshots(\\n        uint initialStake,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint) {\\n        /*\\n         * Grab the sum 'G' from the epoch at which the stake was made. The HOG gain may span up to one scale change.\\n         * If it does, the second portion of the HOG gain is scaled by 1e9.\\n         * If the gain spans no scale change, the second portion will be 0.\\n         */\\n        uint128 epochSnapshot = snapshots.epoch;\\n        uint128 scaleSnapshot = snapshots.scale;\\n        uint G_Snapshot = snapshots.G;\\n        uint P_Snapshot = snapshots.P;\\n\\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(\\n            G_Snapshot\\n        );\\n        uint secondPortion = epochToScaleToG[epochSnapshot][\\n            scaleSnapshot.add(1)\\n        ].div(SCALE_FACTOR);\\n\\n        uint HOGGain = initialStake\\n            .mul(firstPortion.add(secondPortion))\\n            .div(P_Snapshot)\\n            .div(DECIMAL_PRECISION);\\n\\n        return HOGGain;\\n    }\\n\\n    // --- Compounded deposit ---\\n\\n    /*\\n     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\\n     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\\n     */\\n    function getCompoundedBaseFeeLMADeposit(\\n        address _depositor\\n    ) public view returns (uint) {\\n        uint initialDeposit = deposits[_depositor].initialValue;\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(\\n            initialDeposit,\\n            snapshots\\n        );\\n        return compoundedDeposit;\\n    }\\n\\n    // Internal function, used to calculcate compounded deposits\\n    function _getCompoundedStakeFromSnapshots(\\n        uint initialStake,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint) {\\n        uint snapshot_P = snapshots.P;\\n        uint128 scaleSnapshot = snapshots.scale;\\n        uint128 epochSnapshot = snapshots.epoch;\\n\\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\\n        if (epochSnapshot < currentEpoch) {\\n            return 0;\\n        }\\n\\n        uint compoundedStake;\\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\\n\\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\\n         * at least 1e-9 -- so return 0.\\n         */\\n        if (scaleDiff == 0) {\\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\\n        } else if (scaleDiff == 1) {\\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(\\n                SCALE_FACTOR\\n            );\\n        } else {\\n            // if scaleDiff >= 2\\n            compoundedStake = 0;\\n        }\\n\\n        /*\\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\\n         *\\n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\\n         * corrections should ensure the error in P \\\"favors the Pool\\\", i.e. any given compounded deposit should slightly less\\n         * than it's theoretical value.\\n         *\\n         * Thus it's unclear whether this line is still really needed.\\n         */\\n        if (compoundedStake < initialStake.div(1e9)) {\\n            return 0;\\n        }\\n\\n        return compoundedStake;\\n    }\\n\\n    // --- Sender functions for BaseFeeLMA deposit, WStETH gains and HOG gains ---\\n\\n    // Transfer the BaseFeeLMA tokens from the user to the Stability Pool's address, and update its recorded BaseFeeLMA\\n    function _sendBaseFeeLMAtoStabilityPool(\\n        address _address,\\n        uint _amount\\n    ) internal {\\n        baseFeeLMAToken.sendToPool(_address, address(this), _amount);\\n        uint newTotalBaseFeeLMADeposits = totalBaseFeeLMADeposits.add(_amount);\\n        totalBaseFeeLMADeposits = newTotalBaseFeeLMADeposits;\\n        emit StabilityPoolBaseFeeLMABalanceUpdated(newTotalBaseFeeLMADeposits);\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES: use SafeERC20 safe transfer instead of native token transfer\\n     */\\n    function _sendWStETHGainToDepositor(uint _amount) internal {\\n        if (_amount == 0) {\\n            return;\\n        }\\n        uint newWStETH = WStETH.sub(_amount);\\n        WStETH = newWStETH;\\n        emit StabilityPoolWStETHBalanceUpdated(newWStETH);\\n        emit WStETHSent(msg.sender, _amount);\\n\\n        WStETHToken.safeTransfer(msg.sender, _amount);\\n    }\\n\\n    // Send BaseFeeLMA to user and decrease BaseFeeLMA in Pool\\n    function _sendBaseFeeLMAToDepositor(\\n        address _depositor,\\n        uint BaseFeeLMAWithdrawal\\n    ) internal {\\n        if (BaseFeeLMAWithdrawal == 0) {\\n            return;\\n        }\\n\\n        baseFeeLMAToken.returnFromPool(\\n            address(this),\\n            _depositor,\\n            BaseFeeLMAWithdrawal\\n        );\\n        _decreaseBaseFeeLMA(BaseFeeLMAWithdrawal);\\n    }\\n\\n    // --- Stability Pool Deposit Functionality ---\\n    function _updateDepositAndSnapshots(\\n        address _depositor,\\n        uint _newValue\\n    ) internal {\\n        deposits[_depositor].initialValue = _newValue;\\n\\n        if (_newValue == 0) {\\n            delete depositSnapshots[_depositor];\\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\\n            return;\\n        }\\n        uint128 currentScaleCached = currentScale;\\n        uint128 currentEpochCached = currentEpoch;\\n        uint currentP = P;\\n\\n        // Get S and G for the current epoch and current scale\\n        uint currentS = epochToScaleToSum[currentEpochCached][\\n            currentScaleCached\\n        ];\\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\\n\\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\\n        depositSnapshots[_depositor].P = currentP;\\n        depositSnapshots[_depositor].S = currentS;\\n        depositSnapshots[_depositor].G = currentG;\\n        depositSnapshots[_depositor].scale = currentScaleCached;\\n        depositSnapshots[_depositor].epoch = currentEpochCached;\\n\\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\\n    }\\n\\n    function _payOutHOGGains(\\n        ICommunityIssuance _communityIssuance,\\n        address _depositor\\n    ) internal {\\n        // Pay out depositor's HOG gain\\n        uint depositorHOGGain = getDepositorHOGGain(_depositor);\\n        _communityIssuance.sendHOG(_depositor, depositorHOGGain);\\n        emit HOGPaidToDepositor(_depositor, depositorHOGGain);\\n    }\\n\\n    // --- 'require' functions ---\\n\\n    function _requireCallerIsActivePool() internal view {\\n        require(\\n            msg.sender == address(activePool),\\n            \\\"StabilityPool: Caller is not ActivePool\\\"\\n        );\\n    }\\n\\n    function _requireCallerIsTroveManager() internal view {\\n        require(\\n            msg.sender == address(troveManager),\\n            \\\"StabilityPool: Caller is not TroveManager\\\"\\n        );\\n    }\\n\\n    function _requireNoUnderCollateralizedTroves() internal {\\n        uint price = priceFeed.fetchPrice();\\n        address lowestTrove = sortedTroves.getLast();\\n        uint ICR = troveManager.getCurrentICR(lowestTrove, price);\\n        require(\\n            ICR >= MCR,\\n            \\\"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\\\"\\n        );\\n    }\\n\\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\\n        require(\\n            _initialDeposit > 0,\\n            \\\"StabilityPool: User must have a non-zero deposit\\\"\\n        );\\n    }\\n\\n    function _requireUserHasNoDeposit(address _address) internal view {\\n        uint initialDeposit = deposits[_address].initialValue;\\n        require(\\n            initialDeposit == 0,\\n            \\\"StabilityPool: User must have no deposit\\\"\\n        );\\n    }\\n\\n    function _requireNonZeroAmount(uint _amount) internal pure {\\n        require(_amount > 0, \\\"StabilityPool: Amount must be non-zero\\\");\\n    }\\n\\n    function _requireUserHasTrove(address _depositor) internal view {\\n        require(\\n            troveManager.getTroveStatus(_depositor) == 1,\\n            \\\"StabilityPool: caller must have an active trove to withdraw WStETHGain to\\\"\\n        );\\n    }\\n\\n    function _requireUserHasWStETHGain(address _depositor) internal view {\\n        uint WStETHGain = getDepositorWStETHGain(_depositor);\\n        require(\\n            WStETHGain > 0,\\n            \\\"StabilityPool: caller must have non-zero WStETH Gain\\\"\\n        );\\n    }\\n\\n    function _requireValidKickbackRate(uint _kickbackRate) internal pure {\\n        require(\\n            _kickbackRate <= DECIMAL_PRECISION,\\n            \\\"StabilityPool: Kickback rate must be in range [0,1]\\\"\\n        );\\n    }\\n\\n    /**\\n     * Hedgehog Updates:\\n     * Remove native token fallback function and replace with internal balance increaser as it is used only in the offset function\\n     */\\n    function _increaseBalance(uint256 _amount) internal {\\n        WStETH = WStETH.add(_amount);\\n        emit StabilityPoolWStETHBalanceUpdated(WStETH);\\n    }\\n\\n    // --- Fallback function ---\\n}\\n\"\n    },\n    \"contracts/TroveManager.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/ITroveManager.sol\\\";\\nimport \\\"./interfaces/IStabilityPool.sol\\\";\\nimport \\\"./interfaces/ICollSurplusPool.sol\\\";\\nimport \\\"./interfaces/IBaseFeeLMAToken.sol\\\";\\nimport \\\"./interfaces/ISortedTroves.sol\\\";\\nimport \\\"./interfaces/IHOGToken.sol\\\";\\nimport \\\"./interfaces/IFeesRouter.sol\\\";\\nimport \\\"./dependencies/HedgehogBase.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./dependencies/CheckContract.sol\\\";\\n\\n/**\\n * @notice Fork of Liquity's TroveManager. Most of the Logic remains unchanged.\\n * Changes to the contract:\\n * - Raised pragma version\\n * - Removed an import of ActivePool Interface\\n * - Logic updates with redemption & borrowing fees calculation and their distribution\\n * Even though SafeMath is no longer required, the decision was made to keep it to avoid human factor errors\\n */\\n\\ncontract TroveManager is HedgehogBase, Ownable, CheckContract {\\n    using SafeMath for uint256;\\n    string public constant NAME = \\\"TroveManager\\\";\\n\\n    // --- Connected contract declarations ---\\n\\n    address public borrowerOperationsAddress;\\n\\n    IStabilityPool public stabilityPool;\\n\\n    address gasPoolAddress;\\n\\n    ICollSurplusPool collSurplusPool;\\n\\n    IBaseFeeLMAToken public baseFeeLMAToken;\\n\\n    IHOGToken public hogToken;\\n\\n    IFeesRouter public feesRouter;\\n\\n    // A doubly linked list of Troves, sorted by their sorted by their collateral ratios\\n    ISortedTroves public sortedTroves;\\n\\n    // --- Data structures ---\\n\\n    uint public constant SECONDS_IN_ONE_MINUTE = 60;\\n    /*\\n     * Half-life of 12h. 12h = 720 min\\n     * (1/2) = d^720 => d = (1/2)^(1/720)\\n     */\\n    // HEDGEHOG UPDATES: Redemption and Borrowing Decay factors are now different variables\\n    uint public constant MINUTE_DECAY_REDEMPTION_FACTOR = 999037758833783000;\\n    uint public constant MINUTE_DECAY_BORROWING_FACTOR = 991152865945140000;\\n    uint public constant REDEMPTION_FEE_FLOOR = (DECIMAL_PRECISION / 1000) * 5; // 0.5%\\n    // HEDGEHOG UPDATES: Can reach 100% now\\n    uint public constant MAX_BORROWING_FEE = DECIMAL_PRECISION; // 100%\\n\\n    // During bootsrap period redemptions are not allowed\\n    uint public immutable BOOTSTRAP_PERIOD; // 14 days for mainnet\\n    uint public immutable SYSTEM_DEPLOYMENT_TIME;\\n\\n    /*\\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\\n     * Corresponds to (1 / ALPHA) in the white paper.\\n     */\\n    uint public constant BETA = 2;\\n\\n    // HEDGEHOG UPDATES: BaseRate is different for redemption and minting tokens\\n    // 1) Remove baseRate variable\\n    // 2) Create redemptionBaseRate public state variable\\n    // 3) Create borrowBaseRate public state variable\\n    uint public redemptionBaseRate;\\n    uint public borrowBaseRate;\\n\\n    // HEDGEHOG UPDATES: lastFeeOperationTime is different for redemption and minting tokens\\n    // 1) Remove lastFeeOperationTime variable\\n    // 2) Create lastRedemptionTime public state variable\\n    // 3) Create lastBorrowTime public state variable\\n    uint public lastRedemptionTime;\\n    uint public lastBorrowTime;\\n\\n    enum Status {\\n        nonExistent,\\n        active,\\n        closedByOwner,\\n        closedByLiquidation,\\n        closedByRedemption\\n    }\\n\\n    // Store the necessary data for a trove\\n    struct Trove {\\n        uint debt;\\n        uint coll;\\n        uint stake;\\n        Status status;\\n        uint128 arrayIndex;\\n        uint256 lastBlockUpdated; // Hedgehog Updates: New Field in the Trove structure that holds last block update of a trove. Keeps in place even if trove get's closed\\n    }\\n\\n    mapping(address => Trove) public Troves;\\n\\n    uint public totalStakes;\\n\\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\\n    uint public totalStakesSnapshot;\\n\\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\\n    uint public totalCollateralSnapshot;\\n\\n    /*\\n     * L_WStETH and L_BaseFeeLMADebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\\n     *\\n     * An WStETH gain of ( stake * [L_WStETH - L_WStETH(0)] )\\n     * A BaseFeeLMADebt increase  of ( stake * [L_BaseFeeLMADebt - L_BaseFeeLMADebt(0)] )\\n     *\\n     * Where L_WStETH(0) and L_BaseFeeLMADebt(0) are snapshots of L_WStETH and L_BaseFeeLMADebt for the active Trove taken at the instant the stake was made\\n     */\\n    uint public L_WStETH;\\n    uint public L_BaseFeeLMADebt;\\n\\n    // Map addresses with active troves to their RewardSnapshot\\n    mapping(address => RewardSnapshot) public rewardSnapshots;\\n\\n    // Object containing the WStETH and BaseFeeLMA snapshots for a given active trove\\n    struct RewardSnapshot {\\n        uint WStETH;\\n        uint BaseFeeLMADebt;\\n    }\\n\\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\\n    address[] public TroveOwners;\\n\\n    // Error trackers for the trove redistribution calculation\\n    uint public lastWStETHError_Redistribution;\\n    uint public lastBaseFeeLMADebtError_Redistribution;\\n\\n    /*\\n     * --- Variable container structs for liquidations ---\\n     *\\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\\n     * in order to avoid the error: \\\"CompilerError: Stack too deep\\\".\\n     **/\\n\\n    struct LocalVariables_OuterLiquidationFunction {\\n        uint price;\\n        uint BaseFeeLMAInStabPool;\\n        bool recoveryModeAtStart;\\n        uint liquidatedDebt;\\n        uint liquidatedColl;\\n    }\\n\\n    struct LocalVariables_InnerSingleLiquidateFunction {\\n        uint collToLiquidate;\\n        uint pendingDebtReward;\\n        uint pendingCollReward;\\n    }\\n\\n    struct LocalVariables_LiquidationSequence {\\n        uint remainingBaseFeeLMAInStabPool;\\n        uint i;\\n        uint ICR;\\n        address user;\\n        bool backToNormalMode;\\n        uint entireSystemDebt;\\n        uint entireSystemColl;\\n    }\\n\\n    struct LiquidationValues {\\n        uint entireTroveDebt;\\n        uint entireTroveColl;\\n        uint collGasCompensation;\\n        uint BaseFeeLMAGasCompensation;\\n        uint debtToOffset;\\n        uint collToSendToSP;\\n        uint debtToRedistribute;\\n        uint collToRedistribute;\\n        uint collSurplus;\\n    }\\n\\n    struct LiquidationTotals {\\n        uint totalCollInSequence;\\n        uint totalDebtInSequence;\\n        uint totalCollGasCompensation;\\n        uint totalBaseFeeLMAGasCompensation;\\n        uint totalDebtToOffset;\\n        uint totalCollToSendToSP;\\n        uint totalDebtToRedistribute;\\n        uint totalCollToRedistribute;\\n        uint totalCollSurplus;\\n    }\\n\\n    struct ContractsCache {\\n        IActivePool activePool;\\n        IDefaultPool defaultPool;\\n        IBaseFeeLMAToken baseFeeLMAToken;\\n        ISortedTroves sortedTroves;\\n        ICollSurplusPool collSurplusPool;\\n        address gasPoolAddress;\\n    }\\n    // --- Variable container structs for redemptions ---\\n\\n    struct RedemptionTotals {\\n        uint remainingBaseFeeLMA;\\n        uint totalBaseFeeLMAToRedeem;\\n        uint totalWStETHDrawn;\\n        uint WStETHFee;\\n        uint WStETHToSendToRedeemer;\\n        // HEDGEHOG UPDATES: BaseRate is different for redemption and minting tokens\\n        // Rename decayedBaseRate into decayedRedemptionBaseRate\\n        uint decayedRedemptionBaseRate;\\n        uint price;\\n        uint totalBaseFeeLMASupplyAtStart;\\n    }\\n\\n    struct SingleRedemptionValues {\\n        uint BaseFeeLMALot;\\n        uint WStETHLot;\\n        bool cancelledPartial;\\n    }\\n\\n    // --- Events ---\\n\\n    event BorrowerOperationsAddressChanged(\\n        address _newBorrowerOperationsAddress\\n    );\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event BaseFeeLMATokenAddressChanged(address _newBaseFeeLMATokenAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event HOGTokenAddressChanged(address _hogTokenAddress);\\n    event FeesRouterAddressUpdated(IFeesRouter _feesRouter);\\n\\n    event Liquidation(\\n        uint _liquidatedDebt,\\n        uint _liquidatedColl,\\n        uint _collGasCompensation,\\n        uint _BaseFeeLMAGasCompensation\\n    );\\n    event Redemption(\\n        uint _attemptedBaseFeeLMAAmount,\\n        uint _actualBaseFeeLMAAmount,\\n        uint _WStETHSent,\\n        uint _WStETHFee\\n    );\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint _stake,\\n        TroveManagerOperation _operation\\n    );\\n    event TroveLiquidated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        TroveManagerOperation _operation\\n    );\\n\\n    // HEDGEHOG UPDATES: BaseRate is different for redemption and minting tokens\\n    // 1) Remove BaseRateUpdated event\\n    // 2) Create RedemptionBaseRateUpdated event that accepts _redemptionBaseRate\\n    // 3) Create BorrowBaseRateUpdated event that accepts _borrowBaseRate\\n    event RedemptionBaseRateUpdated(uint _redemptionBaseRate);\\n    event BorrowBaseRateUpdated(uint _borrowBaseRate);\\n\\n    // HEDGEHOG UPDATES: BaseRate is different for redemption and minting tokens\\n    // 1) Remove LastFeeOpTimeUpdated event\\n    // 2) Create LastRedemptionTimeUpdated event that accepts _lastRedemptionTime\\n    // 3) Create LastBorrowTimeUpdated event that accepts _lastBorrowTime\\n    event LastRedemptionTimeUpdated(uint _lastRedemptionTime);\\n    event LastBorrowTimeUpdated(uint _lastBorrowTime);\\n    event TotalStakesUpdated(uint _newTotalStakes);\\n    event SystemSnapshotsUpdated(\\n        uint _totalStakesSnapshot,\\n        uint _totalCollateralSnapshot\\n    );\\n    event LTermsUpdated(uint _L_WStETH, uint _L_BaseFeeLMADebt);\\n    event TroveSnapshotsUpdated(uint _L_WStETH, uint _L_BaseFeeLMADebt);\\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\\n\\n    enum TroveManagerOperation {\\n        applyPendingRewards,\\n        liquidateInNormalMode,\\n        liquidateInRecoveryMode,\\n        redeemCollateral\\n    }\\n\\n    constructor(uint256 _bootsrapDaysAmount) {\\n        BOOTSTRAP_PERIOD = _bootsrapDaysAmount * 60 * 60 * 24;\\n        SYSTEM_DEPLOYMENT_TIME = block.timestamp;\\n    }\\n\\n    // --- Dependency setter ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress,\\n        address _stabilityPoolAddress,\\n        address _gasPoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _baseFeeLMATokenAddress,\\n        address _sortedTrovesAddress,\\n        address _hogTokenAddress,\\n        IFeesRouter _feesRouterAddress\\n    ) external onlyOwner {\\n        checkContract(_borrowerOperationsAddress);\\n        checkContract(_activePoolAddress);\\n        checkContract(_defaultPoolAddress);\\n        checkContract(_stabilityPoolAddress);\\n        checkContract(_gasPoolAddress);\\n        checkContract(_collSurplusPoolAddress);\\n        checkContract(_priceFeedAddress);\\n        checkContract(_baseFeeLMATokenAddress);\\n        checkContract(_sortedTrovesAddress);\\n        checkContract(_hogTokenAddress);\\n        checkContract(address(_feesRouterAddress));\\n\\n        borrowerOperationsAddress = _borrowerOperationsAddress;\\n        activePool = IActivePool(_activePoolAddress);\\n        defaultPool = IDefaultPool(_defaultPoolAddress);\\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\\n        gasPoolAddress = _gasPoolAddress;\\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\n        baseFeeLMAToken = IBaseFeeLMAToken(_baseFeeLMATokenAddress);\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\n        hogToken = IHOGToken(_hogTokenAddress);\\n        feesRouter = IFeesRouter(_feesRouterAddress);\\n\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\n        emit ActivePoolAddressChanged(_activePoolAddress);\\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\\n        emit GasPoolAddressChanged(_gasPoolAddress);\\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\\n        emit PriceFeedAddressChanged(_priceFeedAddress);\\n        emit BaseFeeLMATokenAddressChanged(_baseFeeLMATokenAddress);\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\n        emit HOGTokenAddressChanged(_hogTokenAddress);\\n        emit FeesRouterAddressUpdated(_feesRouterAddress);\\n\\n        renounceOwnership();\\n    }\\n\\n    // --- Getters ---\\n\\n    function getTroveOwnersCount() external view returns (uint) {\\n        return TroveOwners.length;\\n    }\\n\\n    function getTroveFromTroveOwnersArray(\\n        uint _index\\n    ) external view returns (address) {\\n        return TroveOwners[_index];\\n    }\\n\\n    // --- Trove Liquidation functions ---\\n\\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\\n    function liquidate(address _borrower) external {\\n        _requireTroveIsActive(_borrower);\\n\\n        address[] memory borrowers = new address[](1);\\n        borrowers[0] = _borrower;\\n        batchLiquidateTroves(borrowers);\\n    }\\n\\n    // --- Inner single liquidation functions ---\\n\\n    // Liquidate one trove, in Normal Mode.\\n    function _liquidateNormalMode(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        address _borrower,\\n        uint _BaseFeeLMAInStabPool\\n    ) internal returns (LiquidationValues memory singleLiquidation) {\\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\\n        (\\n            singleLiquidation.entireTroveDebt,\\n            singleLiquidation.entireTroveColl,\\n            vars.pendingDebtReward,\\n            vars.pendingCollReward\\n        ) = getEntireDebtAndColl(_borrower);\\n\\n        _movePendingTroveRewardsToActivePool(\\n            _activePool,\\n            _defaultPool,\\n            vars.pendingDebtReward,\\n            vars.pendingCollReward\\n        );\\n        _removeStake(_borrower);\\n\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\\n            singleLiquidation.entireTroveColl\\n        );\\n        singleLiquidation\\n            .BaseFeeLMAGasCompensation = BaseFeeLMA_GAS_COMPENSATION;\\n        uint collToLiquidate = singleLiquidation.entireTroveColl.sub(\\n            singleLiquidation.collGasCompensation\\n        );\\n\\n        (\\n            singleLiquidation.debtToOffset,\\n            singleLiquidation.collToSendToSP,\\n            singleLiquidation.debtToRedistribute,\\n            singleLiquidation.collToRedistribute\\n        ) = _getOffsetAndRedistributionVals(\\n            singleLiquidation.entireTroveDebt,\\n            collToLiquidate,\\n            _BaseFeeLMAInStabPool\\n        );\\n\\n        _closeTrove(_borrower, Status.closedByLiquidation);\\n        emit TroveLiquidated(\\n            _borrower,\\n            singleLiquidation.entireTroveDebt,\\n            singleLiquidation.entireTroveColl,\\n            TroveManagerOperation.liquidateInNormalMode\\n        );\\n        emit TroveUpdated(\\n            _borrower,\\n            0,\\n            0,\\n            0,\\n            TroveManagerOperation.liquidateInNormalMode\\n        );\\n        return singleLiquidation;\\n    }\\n\\n    // Liquidate one trove, in Recovery Mode.\\n    function _liquidateRecoveryMode(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        address _borrower,\\n        uint _ICR,\\n        uint _BaseFeeLMAInStabPool,\\n        uint _TCR,\\n        uint _price\\n    ) internal returns (LiquidationValues memory singleLiquidation) {\\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\\n        if (TroveOwners.length <= 1) {\\n            return singleLiquidation;\\n        } // don't liquidate if last trove\\n        (\\n            singleLiquidation.entireTroveDebt,\\n            singleLiquidation.entireTroveColl,\\n            vars.pendingDebtReward,\\n            vars.pendingCollReward\\n        ) = getEntireDebtAndColl(_borrower);\\n\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\\n            singleLiquidation.entireTroveColl\\n        );\\n        singleLiquidation\\n            .BaseFeeLMAGasCompensation = BaseFeeLMA_GAS_COMPENSATION;\\n        vars.collToLiquidate = singleLiquidation.entireTroveColl.sub(\\n            singleLiquidation.collGasCompensation\\n        );\\n\\n        // If ICR <= 100%, purely redistribute the Trove across all active Troves\\n        if (_ICR <= _100pct) {\\n            _movePendingTroveRewardsToActivePool(\\n                _activePool,\\n                _defaultPool,\\n                vars.pendingDebtReward,\\n                vars.pendingCollReward\\n            );\\n            _removeStake(_borrower);\\n\\n            singleLiquidation.debtToOffset = 0;\\n            singleLiquidation.collToSendToSP = 0;\\n            singleLiquidation.debtToRedistribute = singleLiquidation\\n                .entireTroveDebt;\\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\\n\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\n            emit TroveLiquidated(\\n                _borrower,\\n                singleLiquidation.entireTroveDebt,\\n                singleLiquidation.entireTroveColl,\\n                TroveManagerOperation.liquidateInRecoveryMode\\n            );\\n            emit TroveUpdated(\\n                _borrower,\\n                0,\\n                0,\\n                0,\\n                TroveManagerOperation.liquidateInRecoveryMode\\n            );\\n\\n            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\\n        } else if ((_ICR > _100pct) && (_ICR < MCR)) {\\n            _movePendingTroveRewardsToActivePool(\\n                _activePool,\\n                _defaultPool,\\n                vars.pendingDebtReward,\\n                vars.pendingCollReward\\n            );\\n            _removeStake(_borrower);\\n\\n            (\\n                singleLiquidation.debtToOffset,\\n                singleLiquidation.collToSendToSP,\\n                singleLiquidation.debtToRedistribute,\\n                singleLiquidation.collToRedistribute\\n            ) = _getOffsetAndRedistributionVals(\\n                singleLiquidation.entireTroveDebt,\\n                vars.collToLiquidate,\\n                _BaseFeeLMAInStabPool\\n            );\\n\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\n            emit TroveLiquidated(\\n                _borrower,\\n                singleLiquidation.entireTroveDebt,\\n                singleLiquidation.entireTroveColl,\\n                TroveManagerOperation.liquidateInRecoveryMode\\n            );\\n            emit TroveUpdated(\\n                _borrower,\\n                0,\\n                0,\\n                0,\\n                TroveManagerOperation.liquidateInRecoveryMode\\n            );\\n            /*\\n             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)\\n             * and there is BaseFeeLMA in the Stability Pool, only offset, with no redistribution,\\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\\n             * The remainder due to the capped rate will be claimable as collateral surplus.\\n             */\\n        } else if (\\n            (_ICR >= MCR) &&\\n            (_ICR < _TCR) &&\\n            (singleLiquidation.entireTroveDebt <= _BaseFeeLMAInStabPool)\\n        ) {\\n            _movePendingTroveRewardsToActivePool(\\n                _activePool,\\n                _defaultPool,\\n                vars.pendingDebtReward,\\n                vars.pendingCollReward\\n            );\\n            assert(_BaseFeeLMAInStabPool != 0);\\n\\n            _removeStake(_borrower);\\n            singleLiquidation = _getCappedOffsetVals(\\n                singleLiquidation.entireTroveDebt,\\n                singleLiquidation.entireTroveColl,\\n                _price\\n            );\\n\\n            _closeTrove(_borrower, Status.closedByLiquidation);\\n            if (singleLiquidation.collSurplus > 0) {\\n                collSurplusPool.accountSurplus(\\n                    _borrower,\\n                    singleLiquidation.collSurplus\\n                );\\n            }\\n\\n            emit TroveLiquidated(\\n                _borrower,\\n                singleLiquidation.entireTroveDebt,\\n                singleLiquidation.collToSendToSP,\\n                TroveManagerOperation.liquidateInRecoveryMode\\n            );\\n            emit TroveUpdated(\\n                _borrower,\\n                0,\\n                0,\\n                0,\\n                TroveManagerOperation.liquidateInRecoveryMode\\n            );\\n        } else {\\n            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _BaseFeeLMAInStabPool))\\n            LiquidationValues memory zeroVals;\\n            return zeroVals;\\n        }\\n\\n        return singleLiquidation;\\n    }\\n\\n    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be\\n     * redistributed to active troves.\\n     */\\n    function _getOffsetAndRedistributionVals(\\n        uint _debt,\\n        uint _coll,\\n        uint _BaseFeeLMAInStabPool\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint debtToOffset,\\n            uint collToSendToSP,\\n            uint debtToRedistribute,\\n            uint collToRedistribute\\n        )\\n    {\\n        if (_BaseFeeLMAInStabPool > 0) {\\n            /*\\n             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder\\n             * between all active troves.\\n             *\\n             *  If the trove's debt is larger than the deposited BaseFeeLMA in the Stability Pool:\\n             *\\n             *  - Offset an amount of the trove's debt equal to the BaseFeeLMA in the Stability Pool\\n             *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt\\n             *\\n             */\\n            debtToOffset = LiquityMath._min(_debt, _BaseFeeLMAInStabPool);\\n            collToSendToSP = _coll.mul(debtToOffset).div(_debt);\\n            debtToRedistribute = _debt.sub(debtToOffset);\\n            collToRedistribute = _coll.sub(collToSendToSP);\\n        } else {\\n            debtToOffset = 0;\\n            collToSendToSP = 0;\\n            debtToRedistribute = _debt;\\n            collToRedistribute = _coll;\\n        }\\n    }\\n\\n    /*\\n     *  Get its offset coll/debt and WStETH gas comp, and close the trove.\\n     */\\n    function _getCappedOffsetVals(\\n        uint _entireTroveDebt,\\n        uint _entireTroveColl,\\n        uint _price\\n    ) internal view returns (LiquidationValues memory singleLiquidation) {\\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\\n        singleLiquidation.entireTroveColl = _entireTroveColl;\\n\\n        // HEDGEHOG UPDATES:\\n        // Changed the cappedCollPortion formula from [entireTroveDebt] * [MCR] / [price]  to => [entireTroveDebt] * [MCR] / [DECIMAL_PRECISION] * [price] / [DECIMAL_PRECISION]\\n        uint cappedCollPortion = _entireTroveDebt\\n            .div(DECIMAL_PRECISION)\\n            .mul(MCR)\\n            .mul(_price)\\n            .div(DECIMAL_PRECISION);\\n\\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\\n            cappedCollPortion\\n        );\\n        singleLiquidation\\n            .BaseFeeLMAGasCompensation = BaseFeeLMA_GAS_COMPENSATION;\\n\\n        singleLiquidation.debtToOffset = _entireTroveDebt;\\n        singleLiquidation.collToSendToSP = cappedCollPortion.sub(\\n            singleLiquidation.collGasCompensation\\n        );\\n        singleLiquidation.collSurplus = _entireTroveColl.sub(cappedCollPortion);\\n        singleLiquidation.debtToRedistribute = 0;\\n        singleLiquidation.collToRedistribute = 0;\\n    }\\n\\n    /*\\n     * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,\\n     * starting from the one with the lowest collateral ratio in the system, and moving upwards\\n     */\\n    function liquidateTroves(uint _n) external {\\n        ContractsCache memory contractsCache = ContractsCache(\\n            activePool,\\n            defaultPool,\\n            IBaseFeeLMAToken(address(0)),\\n            sortedTroves,\\n            ICollSurplusPool(address(0)),\\n            address(0)\\n        );\\n        IStabilityPool stabilityPoolCached = stabilityPool;\\n\\n        LocalVariables_OuterLiquidationFunction memory vars;\\n\\n        LiquidationTotals memory totals;\\n\\n        vars.price = priceFeed.fetchPrice();\\n        vars.BaseFeeLMAInStabPool = stabilityPoolCached\\n            .getTotalBaseFeeLMADeposits();\\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\\n\\n        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals\\n        if (vars.recoveryModeAtStart) {\\n            totals = _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\\n                contractsCache,\\n                vars.price,\\n                vars.BaseFeeLMAInStabPool,\\n                _n\\n            );\\n        } else {\\n            // if !vars.recoveryModeAtStart\\n            totals = _getTotalsFromLiquidateTrovesSequence_NormalMode(\\n                contractsCache.activePool,\\n                contractsCache.defaultPool,\\n                vars.price,\\n                vars.BaseFeeLMAInStabPool,\\n                _n\\n            );\\n        }\\n\\n        require(\\n            totals.totalDebtInSequence > 0,\\n            \\\"TroveManager: nothing to liquidate\\\"\\n        );\\n\\n        // Move liquidated WStETH and BaseFeeLMA to the appropriate pools\\n        stabilityPoolCached.offset(\\n            totals.totalDebtToOffset,\\n            totals.totalCollToSendToSP\\n        );\\n        _redistributeDebtAndColl(\\n            contractsCache.activePool,\\n            contractsCache.defaultPool,\\n            totals.totalDebtToRedistribute,\\n            totals.totalCollToRedistribute\\n        );\\n        if (totals.totalCollSurplus > 0) {\\n            collSurplusPool.increaseBalance(totals.totalCollSurplus);\\n            contractsCache.activePool.sendWStETH(\\n                address(collSurplusPool),\\n                totals.totalCollSurplus\\n            );\\n        }\\n\\n        // Update system snapshots\\n        _updateSystemSnapshots_excludeCollRemainder(\\n            contractsCache.activePool,\\n            totals.totalCollGasCompensation\\n        );\\n\\n        vars.liquidatedDebt = totals.totalDebtInSequence;\\n        vars.liquidatedColl = totals\\n            .totalCollInSequence\\n            .sub(totals.totalCollGasCompensation)\\n            .sub(totals.totalCollSurplus);\\n        emit Liquidation(\\n            vars.liquidatedDebt,\\n            vars.liquidatedColl,\\n            totals.totalCollGasCompensation,\\n            totals.totalBaseFeeLMAGasCompensation\\n        );\\n\\n        // Send gas compensation to caller\\n        _sendGasCompensation(\\n            contractsCache.activePool,\\n            msg.sender,\\n            totals.totalBaseFeeLMAGasCompensation,\\n            totals.totalCollGasCompensation\\n        );\\n    }\\n\\n    /*\\n     * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it\\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\\n     */\\n    function _getTotalsFromLiquidateTrovesSequence_RecoveryMode(\\n        ContractsCache memory _contractsCache,\\n        uint _price,\\n        uint _BaseFeeLMAInStabPool,\\n        uint _n\\n    ) internal returns (LiquidationTotals memory totals) {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n\\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\\n        vars.backToNormalMode = false;\\n        vars.entireSystemDebt = getEntireSystemDebt();\\n        vars.entireSystemColl = getEntireSystemColl();\\n\\n        vars.user = _contractsCache.sortedTroves.getLast();\\n        address firstUser = _contractsCache.sortedTroves.getFirst();\\n        for (vars.i = 0; vars.i < _n && vars.user != firstUser; vars.i++) {\\n            // we need to cache it, because current user is likely going to be deleted\\n            address nextUser = _contractsCache.sortedTroves.getPrev(vars.user);\\n\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (!vars.backToNormalMode) {\\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\\n                if (\\n                    vars.ICR >= MCR && vars.remainingBaseFeeLMAInStabPool == 0\\n                ) {\\n                    break;\\n                }\\n\\n                uint TCR = LiquityMath._computeCR(\\n                    vars.entireSystemColl,\\n                    vars.entireSystemDebt,\\n                    _price\\n                );\\n\\n                singleLiquidation = _liquidateRecoveryMode(\\n                    _contractsCache.activePool,\\n                    _contractsCache.defaultPool,\\n                    vars.user,\\n                    vars.ICR,\\n                    vars.remainingBaseFeeLMAInStabPool,\\n                    TCR,\\n                    _price\\n                );\\n\\n                // Update aggregate trackers\\n                vars.remainingBaseFeeLMAInStabPool = vars\\n                    .remainingBaseFeeLMAInStabPool\\n                    .sub(singleLiquidation.debtToOffset);\\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\\n                    singleLiquidation.debtToOffset\\n                );\\n                vars.entireSystemColl = vars\\n                    .entireSystemColl\\n                    .sub(singleLiquidation.collToSendToSP)\\n                    .sub(singleLiquidation.collGasCompensation)\\n                    .sub(singleLiquidation.collSurplus);\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(\\n                    totals,\\n                    singleLiquidation\\n                );\\n\\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\\n                    vars.entireSystemColl,\\n                    vars.entireSystemDebt,\\n                    _price\\n                );\\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(\\n                    _contractsCache.activePool,\\n                    _contractsCache.defaultPool,\\n                    vars.user,\\n                    vars.remainingBaseFeeLMAInStabPool\\n                );\\n\\n                vars.remainingBaseFeeLMAInStabPool = vars\\n                    .remainingBaseFeeLMAInStabPool\\n                    .sub(singleLiquidation.debtToOffset);\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(\\n                    totals,\\n                    singleLiquidation\\n                );\\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\\n\\n            vars.user = nextUser;\\n        }\\n    }\\n\\n    function _getTotalsFromLiquidateTrovesSequence_NormalMode(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _price,\\n        uint _BaseFeeLMAInStabPool,\\n        uint _n\\n    ) internal returns (LiquidationTotals memory totals) {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n        ISortedTroves sortedTrovesCached = sortedTroves;\\n\\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\\n\\n        for (vars.i = 0; vars.i < _n; vars.i++) {\\n            vars.user = sortedTrovesCached.getLast();\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(\\n                    _activePool,\\n                    _defaultPool,\\n                    vars.user,\\n                    vars.remainingBaseFeeLMAInStabPool\\n                );\\n\\n                vars.remainingBaseFeeLMAInStabPool = vars\\n                    .remainingBaseFeeLMAInStabPool\\n                    .sub(singleLiquidation.debtToOffset);\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(\\n                    totals,\\n                    singleLiquidation\\n                );\\n            } else break; // break if the loop reaches a Trove with ICR >= MCR\\n        }\\n    }\\n\\n    /*\\n     * Attempt to liquidate a custom list of troves provided by the caller.\\n     */\\n    function batchLiquidateTroves(address[] memory _troveArray) public {\\n        require(\\n            _troveArray.length != 0,\\n            \\\"TroveManager: Calldata address array must not be empty\\\"\\n        );\\n\\n        IActivePool activePoolCached = activePool;\\n        IDefaultPool defaultPoolCached = defaultPool;\\n        IStabilityPool stabilityPoolCached = stabilityPool;\\n\\n        LocalVariables_OuterLiquidationFunction memory vars;\\n        LiquidationTotals memory totals;\\n\\n        vars.price = priceFeed.fetchPrice();\\n        vars.BaseFeeLMAInStabPool = stabilityPoolCached\\n            .getTotalBaseFeeLMADeposits();\\n        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);\\n\\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\\n        if (vars.recoveryModeAtStart) {\\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\\n                activePoolCached,\\n                defaultPoolCached,\\n                vars.price,\\n                vars.BaseFeeLMAInStabPool,\\n                _troveArray\\n            );\\n        } else {\\n            //  if !vars.recoveryModeAtStart\\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\\n                activePoolCached,\\n                defaultPoolCached,\\n                vars.price,\\n                vars.BaseFeeLMAInStabPool,\\n                _troveArray\\n            );\\n        }\\n\\n        require(\\n            totals.totalDebtInSequence > 0,\\n            \\\"TroveManager: nothing to liquidate\\\"\\n        );\\n\\n        // Move liquidated WStETH and BaseFeeLMA to the appropriate pools\\n        stabilityPoolCached.offset(\\n            totals.totalDebtToOffset,\\n            totals.totalCollToSendToSP\\n        );\\n        _redistributeDebtAndColl(\\n            activePoolCached,\\n            defaultPoolCached,\\n            totals.totalDebtToRedistribute,\\n            totals.totalCollToRedistribute\\n        );\\n\\n        if (totals.totalCollSurplus > 0) {\\n            collSurplusPool.increaseBalance(totals.totalCollSurplus);\\n            activePoolCached.sendWStETH(\\n                address(collSurplusPool),\\n                totals.totalCollSurplus\\n            );\\n        }\\n        // Update system snapshots\\n        _updateSystemSnapshots_excludeCollRemainder(\\n            activePoolCached,\\n            totals.totalCollGasCompensation\\n        );\\n\\n        vars.liquidatedDebt = totals.totalDebtInSequence;\\n\\n        vars.liquidatedColl = totals\\n            .totalCollInSequence\\n            .sub(totals.totalCollGasCompensation)\\n            .sub(totals.totalCollSurplus);\\n\\n        emit Liquidation(\\n            vars.liquidatedDebt,\\n            vars.liquidatedColl,\\n            totals.totalCollGasCompensation,\\n            totals.totalBaseFeeLMAGasCompensation\\n        );\\n        // Send gas compensation to caller\\n        _sendGasCompensation(\\n            activePoolCached,\\n            msg.sender,\\n            totals.totalBaseFeeLMAGasCompensation,\\n            totals.totalCollGasCompensation\\n        );\\n    }\\n\\n    /*\\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence\\n     */\\n    function _getTotalFromBatchLiquidate_RecoveryMode(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _price,\\n        uint _BaseFeeLMAInStabPool,\\n        address[] memory _troveArray\\n    ) internal returns (LiquidationTotals memory totals) {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n\\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\\n        vars.backToNormalMode = false;\\n        vars.entireSystemDebt = getEntireSystemDebt();\\n        vars.entireSystemColl = getEntireSystemColl();\\n\\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\\n            vars.user = _troveArray[vars.i];\\n            // Skip non-active troves\\n            if (Troves[vars.user].status != Status.active) {\\n                continue;\\n            }\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (!vars.backToNormalMode) {\\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\\n                if (\\n                    vars.ICR >= MCR && vars.remainingBaseFeeLMAInStabPool == 0\\n                ) {\\n                    continue;\\n                }\\n\\n                uint TCR = LiquityMath._computeCR(\\n                    vars.entireSystemColl,\\n                    vars.entireSystemDebt,\\n                    _price\\n                );\\n\\n                singleLiquidation = _liquidateRecoveryMode(\\n                    _activePool,\\n                    _defaultPool,\\n                    vars.user,\\n                    vars.ICR,\\n                    vars.remainingBaseFeeLMAInStabPool,\\n                    TCR,\\n                    _price\\n                );\\n\\n                // Update aggregate trackers\\n                vars.remainingBaseFeeLMAInStabPool = vars\\n                    .remainingBaseFeeLMAInStabPool\\n                    .sub(singleLiquidation.debtToOffset);\\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(\\n                    singleLiquidation.debtToOffset\\n                );\\n                vars.entireSystemColl = vars\\n                    .entireSystemColl\\n                    .sub(singleLiquidation.collToSendToSP)\\n                    .sub(singleLiquidation.collGasCompensation)\\n                    .sub(singleLiquidation.collSurplus);\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(\\n                    totals,\\n                    singleLiquidation\\n                );\\n\\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\\n                    vars.entireSystemColl,\\n                    vars.entireSystemDebt,\\n                    _price\\n                );\\n            } else if (vars.backToNormalMode && vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(\\n                    _activePool,\\n                    _defaultPool,\\n                    vars.user,\\n                    vars.remainingBaseFeeLMAInStabPool\\n                );\\n                vars.remainingBaseFeeLMAInStabPool = vars\\n                    .remainingBaseFeeLMAInStabPool\\n                    .sub(singleLiquidation.debtToOffset);\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(\\n                    totals,\\n                    singleLiquidation\\n                );\\n            } else continue; // In Normal Mode skip troves with ICR >= MCR\\n        }\\n    }\\n\\n    function _getTotalsFromBatchLiquidate_NormalMode(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _price,\\n        uint _BaseFeeLMAInStabPool,\\n        address[] memory _troveArray\\n    ) internal returns (LiquidationTotals memory totals) {\\n        LocalVariables_LiquidationSequence memory vars;\\n        LiquidationValues memory singleLiquidation;\\n\\n        vars.remainingBaseFeeLMAInStabPool = _BaseFeeLMAInStabPool;\\n\\n        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {\\n            vars.user = _troveArray[vars.i];\\n            vars.ICR = getCurrentICR(vars.user, _price);\\n\\n            if (vars.ICR < MCR) {\\n                singleLiquidation = _liquidateNormalMode(\\n                    _activePool,\\n                    _defaultPool,\\n                    vars.user,\\n                    vars.remainingBaseFeeLMAInStabPool\\n                );\\n\\n                vars.remainingBaseFeeLMAInStabPool = vars\\n                    .remainingBaseFeeLMAInStabPool\\n                    .sub(singleLiquidation.debtToOffset);\\n\\n                // Add liquidation values to their respective running totals\\n                totals = _addLiquidationValuesToTotals(\\n                    totals,\\n                    singleLiquidation\\n                );\\n            }\\n        }\\n    }\\n\\n    // --- Liquidation helper functions ---\\n\\n    function _addLiquidationValuesToTotals(\\n        LiquidationTotals memory oldTotals,\\n        LiquidationValues memory singleLiquidation\\n    ) internal pure returns (LiquidationTotals memory newTotals) {\\n        // Tally all the values with their respective running totals\\n        newTotals.totalCollGasCompensation = oldTotals\\n            .totalCollGasCompensation\\n            .add(singleLiquidation.collGasCompensation);\\n        newTotals.totalBaseFeeLMAGasCompensation = oldTotals\\n            .totalBaseFeeLMAGasCompensation\\n            .add(singleLiquidation.BaseFeeLMAGasCompensation);\\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\\n            singleLiquidation.entireTroveDebt\\n        );\\n        newTotals.totalCollInSequence = oldTotals.totalCollInSequence.add(\\n            singleLiquidation.entireTroveColl\\n        );\\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\\n            singleLiquidation.debtToOffset\\n        );\\n        newTotals.totalCollToSendToSP = oldTotals.totalCollToSendToSP.add(\\n            singleLiquidation.collToSendToSP\\n        );\\n        newTotals.totalDebtToRedistribute = oldTotals\\n            .totalDebtToRedistribute\\n            .add(singleLiquidation.debtToRedistribute);\\n        newTotals.totalCollToRedistribute = oldTotals\\n            .totalCollToRedistribute\\n            .add(singleLiquidation.collToRedistribute);\\n        newTotals.totalCollSurplus = oldTotals.totalCollSurplus.add(\\n            singleLiquidation.collSurplus\\n        );\\n\\n        return newTotals;\\n    }\\n\\n    function _sendGasCompensation(\\n        IActivePool _activePool,\\n        address _liquidator,\\n        uint _BaseFeeLMA,\\n        uint _WStETH\\n    ) internal {\\n        if (_BaseFeeLMA > 0) {\\n            baseFeeLMAToken.returnFromPool(\\n                gasPoolAddress,\\n                _liquidator,\\n                _BaseFeeLMA\\n            );\\n        }\\n\\n        if (_WStETH > 0) {\\n            _activePool.sendWStETH(_liquidator, _WStETH);\\n        }\\n    }\\n\\n    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\\n    function _movePendingTroveRewardsToActivePool(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _BaseFeeLMA,\\n        uint _WStETH\\n    ) internal {\\n        _defaultPool.decreaseBaseFeeLMADebt(_BaseFeeLMA);\\n        _activePool.increaseBaseFeeLMADebt(_BaseFeeLMA);\\n\\n        _defaultPool.sendWStETHToActivePool(_WStETH);\\n    }\\n\\n    // --- Redemption functions ---\\n\\n    // Redeem as much collateral as possible from _borrower's Trove in exchange for BaseFeeLMA up to _maxBaseFeeLMAamount\\n    function _redeemCollateralFromTrove(\\n        ContractsCache memory _contractsCache,\\n        address _borrower,\\n        uint _maxBaseFeeLMAamount,\\n        uint _price,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR\\n    ) internal returns (SingleRedemptionValues memory singleRedemption) {\\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve\\n        singleRedemption.BaseFeeLMALot = LiquityMath._min(\\n            _maxBaseFeeLMAamount,\\n            Troves[_borrower].debt.sub(BaseFeeLMA_GAS_COMPENSATION)\\n        );\\n\\n        // Get the WStETHLot of equivalent value in BaseFeeLMA\\n        // HEDGEHOG UPDATES: Change WStETHLOT calculations formula from [debtToBeRedeemed * price * 10e9] to [debtToBeRedeemed * price / 10e18]\\n        singleRedemption.WStETHLot = singleRedemption\\n            .BaseFeeLMALot\\n            .mul(_price)\\n            .div(DECIMAL_PRECISION);\\n\\n        // Decrease the debt and collateral of the current Trove according to the BaseFeeLMA lot and corresponding WStETH to send\\n        uint newDebt = (Troves[_borrower].debt).sub(\\n            singleRedemption.BaseFeeLMALot\\n        );\\n        uint newColl = (Troves[_borrower].coll).sub(singleRedemption.WStETHLot);\\n\\n        if (newDebt == BaseFeeLMA_GAS_COMPENSATION) {\\n            // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed\\n            _removeStake(_borrower);\\n            _closeTrove(_borrower, Status.closedByRedemption);\\n            _redeemCloseTrove(\\n                _contractsCache,\\n                _borrower,\\n                BaseFeeLMA_GAS_COMPENSATION,\\n                newColl\\n            );\\n            emit TroveUpdated(\\n                _borrower,\\n                0,\\n                0,\\n                0,\\n                TroveManagerOperation.redeemCollateral\\n            );\\n        } else {\\n            uint newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\\n\\n            /*\\n             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost\\n             * certainly result in running out of gas.\\n             *\\n             * If the resultant net debt of the partial is less than the minimum, net debt we bail.\\n             */\\n            if (\\n                newNICR != _partialRedemptionHintNICR ||\\n                _getNetDebt(newDebt) < MIN_NET_DEBT\\n            ) {\\n                singleRedemption.cancelledPartial = true;\\n                return singleRedemption;\\n            }\\n\\n            _contractsCache.sortedTroves.reInsert(\\n                _borrower,\\n                newNICR,\\n                _upperPartialRedemptionHint,\\n                _lowerPartialRedemptionHint\\n            );\\n\\n            Troves[_borrower].debt = newDebt;\\n            Troves[_borrower].coll = newColl;\\n            _updateStakeAndTotalStakes(_borrower);\\n\\n            emit TroveUpdated(\\n                _borrower,\\n                newDebt,\\n                newColl,\\n                Troves[_borrower].stake,\\n                TroveManagerOperation.redeemCollateral\\n            );\\n        }\\n\\n        return singleRedemption;\\n    }\\n\\n    /*\\n     * Called when a full redemption occurs, and closes the trove.\\n     * The redeemer swaps (debt - liquidation reserve) BaseFeeLMA for (debt - liquidation reserve) worth of WStETH, so the BaseFeeLMA liquidation reserve left corresponds to the remaining debt.\\n     * In order to close the trove, the BaseFeeLMA liquidation reserve is burned, and the corresponding debt is removed from the active pool.\\n     * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.\\n     * Any surplus WStETH left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.\\n     */\\n    function _redeemCloseTrove(\\n        ContractsCache memory _contractsCache,\\n        address _borrower,\\n        uint _BaseFeeLMA,\\n        uint _WStETH\\n    ) internal {\\n        _contractsCache.baseFeeLMAToken.burn(gasPoolAddress, _BaseFeeLMA);\\n        // Update Active Pool BaseFeeLMA, and send WStETH to account\\n        _contractsCache.activePool.decreaseBaseFeeLMADebt(_BaseFeeLMA);\\n\\n        // send WStETH from Active Pool to CollSurplus Pool\\n        collSurplusPool.increaseBalance(_WStETH);\\n        _contractsCache.collSurplusPool.accountSurplus(_borrower, _WStETH);\\n        _contractsCache.activePool.sendWStETH(\\n            address(_contractsCache.collSurplusPool),\\n            _WStETH\\n        );\\n    }\\n\\n    function _isValidFirstRedemptionHint(\\n        ISortedTroves _sortedTroves,\\n        address _firstRedemptionHint,\\n        uint _price\\n    ) internal view returns (bool) {\\n        if (\\n            _firstRedemptionHint == address(0) ||\\n            !_sortedTroves.contains(_firstRedemptionHint) ||\\n            getCurrentICR(_firstRedemptionHint, _price) < MCR\\n        ) {\\n            return false;\\n        }\\n\\n        address nextTrove = _sortedTroves.getNext(_firstRedemptionHint);\\n        return\\n            nextTrove == address(0) || getCurrentICR(nextTrove, _price) < MCR;\\n    }\\n\\n    /* Send _BaseFeeLMAamount BaseFeeLMA to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\\n     * request.  Applies pending rewards to a Trove before reducing its debt and coll.\\n     *\\n     * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\\n     * splitting the total _amount in appropriate chunks and calling the function multiple times.\\n     *\\n     * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if its zero, it will be ignored).This makes it easier to\\n     * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the topology\\n     * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\\n     * costs can vary.\\n     *\\n     * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\\n     * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\\n     * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\\n     * in the sortedTroves list along with the ICR value that the hint was found for.\\n     *\\n     * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\\n     * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\\n     * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining BaseFeeLMA amount, which they can attempt\\n     * to redeem later.\\n     */\\n    function redeemCollateral(\\n        uint _BaseFeeLMAamount,\\n        address _firstRedemptionHint,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR,\\n        uint _maxIterations,\\n        uint _maxFeePercentage\\n    ) external {\\n        ContractsCache memory contractsCache = ContractsCache(\\n            activePool,\\n            defaultPool,\\n            baseFeeLMAToken,\\n            sortedTroves,\\n            collSurplusPool,\\n            gasPoolAddress\\n        );\\n        RedemptionTotals memory totals;\\n\\n        _requireValidMaxFeePercentage(_maxFeePercentage);\\n        _requireAfterBootstrapPeriod();\\n        totals.price = priceFeed.fetchPrice();\\n\\n        _requireTCRoverMCR(totals.price);\\n        _requireAmountGreaterThanZero(_BaseFeeLMAamount);\\n        _requireBaseFeeLMABalanceCoversRedemption(\\n            contractsCache.baseFeeLMAToken,\\n            msg.sender,\\n            _BaseFeeLMAamount\\n        );\\n\\n        totals.totalBaseFeeLMASupplyAtStart = getEntireSystemDebt();\\n        // Confirm redeemer's balance is less than total BaseFeeLMA supply\\n        assert(\\n            contractsCache.baseFeeLMAToken.balanceOf(msg.sender) <=\\n                totals.totalBaseFeeLMASupplyAtStart\\n        );\\n\\n        totals.remainingBaseFeeLMA = _BaseFeeLMAamount;\\n        address currentBorrower;\\n\\n        if (\\n            _isValidFirstRedemptionHint(\\n                contractsCache.sortedTroves,\\n                _firstRedemptionHint,\\n                totals.price\\n            )\\n        ) {\\n            currentBorrower = _firstRedemptionHint;\\n        } else {\\n            currentBorrower = contractsCache.sortedTroves.getLast();\\n            // Find the first trove with ICR >= MCR\\n            while (\\n                currentBorrower != address(0) &&\\n                getCurrentICR(currentBorrower, totals.price) < MCR\\n            ) {\\n                currentBorrower = contractsCache.sortedTroves.getPrev(\\n                    currentBorrower\\n                );\\n            }\\n        }\\n        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of BaseFeeLMA is exchanged for collateral\\n        if (_maxIterations == 0) {\\n            // Previous implementation: _maxIterations = uint(-1);\\n            // Updated since 8th pragma does not allow anymore\\n            _maxIterations = type(uint).max;\\n        }\\n        while (\\n            currentBorrower != address(0) &&\\n            totals.remainingBaseFeeLMA > 0 &&\\n            _maxIterations > 0\\n        ) {\\n            _maxIterations--;\\n            // Save the address of the Trove preceding the current one, before potentially modifying the list\\n            address nextUserToCheck = contractsCache.sortedTroves.getPrev(\\n                currentBorrower\\n            );\\n\\n            _applyPendingRewards(\\n                contractsCache.activePool,\\n                contractsCache.defaultPool,\\n                currentBorrower\\n            );\\n\\n            SingleRedemptionValues\\n                memory singleRedemption = _redeemCollateralFromTrove(\\n                    contractsCache,\\n                    currentBorrower,\\n                    totals.remainingBaseFeeLMA,\\n                    totals.price,\\n                    _upperPartialRedemptionHint,\\n                    _lowerPartialRedemptionHint,\\n                    _partialRedemptionHintNICR\\n                );\\n\\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove\\n            totals.totalBaseFeeLMAToRedeem = totals.totalBaseFeeLMAToRedeem.add(\\n                singleRedemption.BaseFeeLMALot\\n            );\\n            totals.totalWStETHDrawn = totals.totalWStETHDrawn.add(\\n                singleRedemption.WStETHLot\\n            );\\n\\n            totals.remainingBaseFeeLMA = totals.remainingBaseFeeLMA.sub(\\n                singleRedemption.BaseFeeLMALot\\n            );\\n            currentBorrower = nextUserToCheck;\\n        }\\n\\n        require(\\n            totals.totalWStETHDrawn > 0,\\n            \\\"TroveManager: Unable to redeem any amount\\\"\\n        );\\n        // HEDGEHOG LOGIC UPDATE:\\n        // 1) rename _updateBaseRateFromRedemption into _updateRedemptionBaseRateFromRedemption\\n        // 2) update commented explanation (baseRate => redemptionBaseRate)\\n        // Decay the redemptionBaseRate due to time passed, and then increase it according to the size of this redemption.\\n        // Use the saved total BaseFeeLMA supply value, from before it was reduced by the redemption.\\n        _updateRedemptionBaseRateFromRedemption(totals.totalWStETHDrawn);\\n        // Calculate the WStETH fee\\n        totals.WStETHFee = _getRedemptionFee(totals.totalWStETHDrawn);\\n\\n        _requireUserAcceptsFee(\\n            totals.WStETHFee,\\n            totals.totalWStETHDrawn,\\n            _maxFeePercentage\\n        );\\n\\n        // HEDGHEHOG UPDATES:\\n        // Fees are now distributed among different addresses based on how big they are\\n        feesRouter.distributeCollFee(totals.totalWStETHDrawn, totals.WStETHFee);\\n\\n        totals.WStETHToSendToRedeemer = totals.totalWStETHDrawn.sub(\\n            totals.WStETHFee\\n        );\\n\\n        emit Redemption(\\n            _BaseFeeLMAamount,\\n            totals.totalBaseFeeLMAToRedeem,\\n            totals.totalWStETHDrawn,\\n            totals.WStETHFee\\n        );\\n        // Burn the total BaseFeeLMA that is cancelled with debt, and send the redeemed WStETH to msg.sender\\n        contractsCache.baseFeeLMAToken.burn(\\n            msg.sender,\\n            totals.totalBaseFeeLMAToRedeem\\n        );\\n        // Update Active Pool BaseFeeLMA, and send WStETH to account\\n        contractsCache.activePool.decreaseBaseFeeLMADebt(\\n            totals.totalBaseFeeLMAToRedeem\\n        );\\n\\n        contractsCache.activePool.sendWStETH(\\n            msg.sender,\\n            totals.WStETHToSendToRedeemer\\n        );\\n    }\\n\\n    // --- Helper functions ---\\n\\n    // Return the nominal collateral ratio (ICR) of a given Trove, without the price. Takes a trove's pending coll and debt rewards from redistributions into account.\\n    function getNominalICR(address _borrower) public view returns (uint) {\\n        (\\n            uint currentWStETH,\\n            uint currentBaseFeeLMADebt\\n        ) = _getCurrentTroveAmounts(_borrower);\\n\\n        uint NICR = LiquityMath._computeNominalCR(\\n            currentWStETH,\\n            currentBaseFeeLMADebt\\n        );\\n        return NICR;\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * Get Price directly from the price feed instead of param passing\\n     */\\n    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.\\n    function getCurrentICR(\\n        address _borrower,\\n        uint _price\\n    ) public view returns (uint) {\\n        (\\n            uint currentWStETH,\\n            uint currentBaseFeeLMADebt\\n        ) = _getCurrentTroveAmounts(_borrower);\\n\\n        uint ICR = LiquityMath._computeCR(\\n            currentWStETH,\\n            currentBaseFeeLMADebt,\\n            _price\\n        );\\n        return ICR;\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * New view method to help with getting the data on frontends\\n     */\\n    function getUnreliableTroveICR(\\n        address _borrower\\n    ) public view returns (uint) {\\n        uint256 price = priceFeed.lastGoodPrice();\\n        (\\n            uint currentWStETH,\\n            uint currentBaseFeeLMADebt\\n        ) = _getCurrentTroveAmounts(_borrower);\\n\\n        uint ICR = LiquityMath._computeCR(\\n            currentWStETH,\\n            currentBaseFeeLMADebt,\\n            price\\n        );\\n        return ICR;\\n    }\\n\\n    function _getCurrentTroveAmounts(\\n        address _borrower\\n    ) internal view returns (uint, uint) {\\n        uint pendingWStETHReward = getPendingWStETHReward(_borrower);\\n        uint pendingBaseFeeLMADebtReward = getPendingBaseFeeLMADebtReward(\\n            _borrower\\n        );\\n\\n        uint currentWStETH = Troves[_borrower].coll.add(pendingWStETHReward);\\n        uint currentBaseFeeLMADebt = Troves[_borrower].debt.add(\\n            pendingBaseFeeLMADebtReward\\n        );\\n\\n        return (currentWStETH, currentBaseFeeLMADebt);\\n    }\\n\\n    function applyPendingRewards(address _borrower) external {\\n        _requireCallerIsBorrowerOperations();\\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\\n    }\\n\\n    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove\\n    function _applyPendingRewards(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        address _borrower\\n    ) internal {\\n        if (hasPendingRewards(_borrower)) {\\n            _requireTroveIsActive(_borrower);\\n\\n            // Compute pending rewards\\n            uint pendingWStETHReward = getPendingWStETHReward(_borrower);\\n\\n            uint pendingBaseFeeLMADebtReward = getPendingBaseFeeLMADebtReward(\\n                _borrower\\n            );\\n\\n            // Apply pending rewards to trove's state\\n            Troves[_borrower].coll = Troves[_borrower].coll.add(\\n                pendingWStETHReward\\n            );\\n\\n            Troves[_borrower].debt = Troves[_borrower].debt.add(\\n                pendingBaseFeeLMADebtReward\\n            );\\n\\n            _updateTroveRewardSnapshots(_borrower);\\n\\n            // Transfer from DefaultPool to ActivePool\\n            _movePendingTroveRewardsToActivePool(\\n                _activePool,\\n                _defaultPool,\\n                pendingBaseFeeLMADebtReward,\\n                pendingWStETHReward\\n            );\\n\\n            emit TroveUpdated(\\n                _borrower,\\n                Troves[_borrower].debt,\\n                Troves[_borrower].coll,\\n                Troves[_borrower].stake,\\n                TroveManagerOperation.applyPendingRewards\\n            );\\n        }\\n    }\\n\\n    // Update borrower's snapshots of L_WStETH and L_BaseFeeLMADebt to reflect the current values\\n    function updateTroveRewardSnapshots(address _borrower) external {\\n        _requireCallerIsBorrowerOperations();\\n        return _updateTroveRewardSnapshots(_borrower);\\n    }\\n\\n    function _updateTroveRewardSnapshots(address _borrower) internal {\\n        rewardSnapshots[_borrower].WStETH = L_WStETH;\\n        rewardSnapshots[_borrower].BaseFeeLMADebt = L_BaseFeeLMADebt;\\n        emit TroveSnapshotsUpdated(L_WStETH, L_BaseFeeLMADebt);\\n    }\\n\\n    // Get the borrower's pending accumulated WStETH reward, earned by their stake\\n    function getPendingWStETHReward(\\n        address _borrower\\n    ) public view returns (uint) {\\n        uint snapshotWStETH = rewardSnapshots[_borrower].WStETH;\\n        uint rewardPerUnitStaked = L_WStETH.sub(snapshotWStETH);\\n\\n        if (\\n            rewardPerUnitStaked == 0 ||\\n            Troves[_borrower].status != Status.active\\n        ) {\\n            return 0;\\n        }\\n\\n        uint stake = Troves[_borrower].stake;\\n\\n        uint pendingWStETHReward = stake.mul(rewardPerUnitStaked).div(\\n            DECIMAL_PRECISION\\n        );\\n\\n        return pendingWStETHReward;\\n    }\\n\\n    // Get the borrower's pending accumulated BaseFeeLMA reward, earned by their stake\\n    function getPendingBaseFeeLMADebtReward(\\n        address _borrower\\n    ) public view returns (uint) {\\n        uint snapshotBaseFeeLMADebt = rewardSnapshots[_borrower].BaseFeeLMADebt;\\n        uint rewardPerUnitStaked = L_BaseFeeLMADebt.sub(snapshotBaseFeeLMADebt);\\n\\n        if (\\n            rewardPerUnitStaked == 0 ||\\n            Troves[_borrower].status != Status.active\\n        ) {\\n            return 0;\\n        }\\n\\n        uint stake = Troves[_borrower].stake;\\n\\n        uint pendingBaseFeeLMADebtReward = stake.mul(rewardPerUnitStaked).div(\\n            DECIMAL_PRECISION\\n        );\\n\\n        return pendingBaseFeeLMADebtReward;\\n    }\\n\\n    function hasPendingRewards(address _borrower) public view returns (bool) {\\n        /*\\n         * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\\n         * this indicates that rewards have occured since the snapshot was made, and the user therefore has\\n         * pending rewards\\n         */\\n        if (Troves[_borrower].status != Status.active) {\\n            return false;\\n        }\\n\\n        return (rewardSnapshots[_borrower].WStETH < L_WStETH);\\n    }\\n\\n    // Return the Troves entire debt and coll, including pending rewards from redistributions.\\n    function getEntireDebtAndColl(\\n        address _borrower\\n    )\\n        public\\n        view\\n        returns (\\n            uint debt,\\n            uint coll,\\n            uint pendingBaseFeeLMADebtReward,\\n            uint pendingWStETHReward\\n        )\\n    {\\n        debt = Troves[_borrower].debt;\\n        coll = Troves[_borrower].coll;\\n\\n        pendingBaseFeeLMADebtReward = getPendingBaseFeeLMADebtReward(_borrower);\\n        pendingWStETHReward = getPendingWStETHReward(_borrower);\\n\\n        debt = debt.add(pendingBaseFeeLMADebtReward);\\n        coll = coll.add(pendingWStETHReward);\\n    }\\n\\n    function removeStake(address _borrower) external {\\n        _requireCallerIsBorrowerOperations();\\n        return _removeStake(_borrower);\\n    }\\n\\n    // Remove borrower's stake from the totalStakes sum, and set their stake to 0\\n    function _removeStake(address _borrower) internal {\\n        uint stake = Troves[_borrower].stake;\\n        totalStakes = totalStakes.sub(stake);\\n        Troves[_borrower].stake = 0;\\n    }\\n\\n    function updateStakeAndTotalStakes(\\n        address _borrower\\n    ) external returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        return _updateStakeAndTotalStakes(_borrower);\\n    }\\n\\n    // Update borrower's stake based on their latest collateral value\\n    function _updateStakeAndTotalStakes(\\n        address _borrower\\n    ) internal returns (uint) {\\n        uint newStake = _computeNewStake(Troves[_borrower].coll);\\n        uint oldStake = Troves[_borrower].stake;\\n        Troves[_borrower].stake = newStake;\\n\\n        totalStakes = totalStakes.sub(oldStake).add(newStake);\\n        emit TotalStakesUpdated(totalStakes);\\n\\n        return newStake;\\n    }\\n\\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\\n    function _computeNewStake(uint _coll) internal view returns (uint) {\\n        uint stake;\\n        if (totalCollateralSnapshot == 0) {\\n            stake = _coll;\\n        } else {\\n            /*\\n             * The following assert() holds true because:\\n             * - The system always contains >= 1 trove\\n             * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\\n             * rewards wouldve been emptied and totalCollateralSnapshot would be zero too.\\n             */\\n            assert(totalStakesSnapshot > 0);\\n            stake = _coll.mul(totalStakesSnapshot).div(totalCollateralSnapshot);\\n        }\\n        return stake;\\n    }\\n\\n    function _redistributeDebtAndColl(\\n        IActivePool _activePool,\\n        IDefaultPool _defaultPool,\\n        uint _debt,\\n        uint _coll\\n    ) internal {\\n        if (_debt == 0) {\\n            return;\\n        }\\n\\n        /*\\n         * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \\\"feedback\\\"\\n         * error correction, to keep the cumulative error low in the running totals L_WStETH and L_BaseFeeLMADebt:\\n         *\\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\\n         * function was called.\\n         * 2) Calculate \\\"per-unit-staked\\\" ratios.\\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\\n         * 4) Store these errors for use in the next correction when this function is called.\\n         * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n         */\\n        uint WStETHNumerator = _coll.mul(DECIMAL_PRECISION).add(\\n            lastWStETHError_Redistribution\\n        );\\n        uint BaseFeeLMADebtNumerator = _debt.mul(DECIMAL_PRECISION).add(\\n            lastBaseFeeLMADebtError_Redistribution\\n        );\\n\\n        // Get the per-unit-staked terms\\n        uint WStETHRewardPerUnitStaked = WStETHNumerator.div(totalStakes);\\n        uint BaseFeeLMADebtRewardPerUnitStaked = BaseFeeLMADebtNumerator.div(\\n            totalStakes\\n        );\\n\\n        lastWStETHError_Redistribution = WStETHNumerator.sub(\\n            WStETHRewardPerUnitStaked.mul(totalStakes)\\n        );\\n        lastBaseFeeLMADebtError_Redistribution = BaseFeeLMADebtNumerator.sub(\\n            BaseFeeLMADebtRewardPerUnitStaked.mul(totalStakes)\\n        );\\n\\n        // Add per-unit-staked terms to the running totals\\n        L_WStETH = L_WStETH.add(WStETHRewardPerUnitStaked);\\n        L_BaseFeeLMADebt = L_BaseFeeLMADebt.add(\\n            BaseFeeLMADebtRewardPerUnitStaked\\n        );\\n\\n        emit LTermsUpdated(L_WStETH, L_BaseFeeLMADebt);\\n\\n        // Transfer coll and debt from ActivePool to DefaultPool\\n        _activePool.decreaseBaseFeeLMADebt(_debt);\\n        _defaultPool.increaseBaseFeeLMADebt(_debt);\\n        _defaultPool.increaseBalance(_coll);\\n        _activePool.sendWStETH(address(_defaultPool), _coll);\\n    }\\n\\n    function closeTrove(address _borrower) external {\\n        _requireCallerIsBorrowerOperations();\\n        return _closeTrove(_borrower, Status.closedByOwner);\\n    }\\n\\n    function _closeTrove(address _borrower, Status closedStatus) internal {\\n        assert(\\n            closedStatus != Status.nonExistent && closedStatus != Status.active\\n        );\\n\\n        uint TroveOwnersArrayLength = TroveOwners.length;\\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\\n\\n        Troves[_borrower].status = closedStatus;\\n        Troves[_borrower].coll = 0;\\n        Troves[_borrower].debt = 0;\\n        rewardSnapshots[_borrower].WStETH = 0;\\n        rewardSnapshots[_borrower].BaseFeeLMADebt = 0;\\n\\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\\n        sortedTroves.remove(_borrower);\\n    }\\n\\n    /*\\n     * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\\n     * Used in a liquidation sequence.\\n     *\\n     * The calculation excludes a portion of collateral that is in the ActivePool:\\n     *\\n     * the total WStETH gas compensation from the liquidation sequence\\n     *\\n     * The WStETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\\n     */\\n    function _updateSystemSnapshots_excludeCollRemainder(\\n        IActivePool _activePool,\\n        uint _collRemainder\\n    ) internal {\\n        totalStakesSnapshot = totalStakes;\\n\\n        uint activeColl = _activePool.getWStETH();\\n        uint liquidatedColl = defaultPool.getWStETH();\\n        totalCollateralSnapshot = activeColl.sub(_collRemainder).add(\\n            liquidatedColl\\n        );\\n\\n        emit SystemSnapshotsUpdated(\\n            totalStakesSnapshot,\\n            totalCollateralSnapshot\\n        );\\n    }\\n\\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\\n    function addTroveOwnerToArray(\\n        address _borrower\\n    ) external returns (uint index) {\\n        _requireCallerIsBorrowerOperations();\\n        return _addTroveOwnerToArray(_borrower);\\n    }\\n\\n    function _addTroveOwnerToArray(\\n        address _borrower\\n    ) internal returns (uint128 index) {\\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum BaseFeeLMA\\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 BaseFeeLMA dwarfs the value of all wealth in the world ( which is < 1e15 BaseFeeLMA). */\\n\\n        // Push the Troveowner to the array\\n        TroveOwners.push(_borrower);\\n\\n        // Record the index of the new Troveowner on their Trove struct\\n        index = uint128(TroveOwners.length.sub(1));\\n        Troves[_borrower].arrayIndex = index;\\n\\n        return index;\\n    }\\n\\n    /*\\n     * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\\n     * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\\n     */\\n    function _removeTroveOwner(\\n        address _borrower,\\n        uint TroveOwnersArrayLength\\n    ) internal {\\n        Status troveStatus = Troves[_borrower].status;\\n        // Its set in caller function `_closeTrove`\\n        assert(\\n            troveStatus != Status.nonExistent && troveStatus != Status.active\\n        );\\n\\n        uint128 index = Troves[_borrower].arrayIndex;\\n        uint length = TroveOwnersArrayLength;\\n        uint idxLast = length.sub(1);\\n\\n        assert(index <= idxLast);\\n\\n        address addressToMove = TroveOwners[idxLast];\\n\\n        TroveOwners[index] = addressToMove;\\n        Troves[addressToMove].arrayIndex = index;\\n        emit TroveIndexUpdated(addressToMove, index);\\n\\n        TroveOwners.pop();\\n    }\\n\\n    // --- Recovery Mode and TCR functions ---\\n\\n    function getTCR(uint _price) external view returns (uint) {\\n        return _getTCR(_price);\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * New view method to help with getting the data on frontends\\n     */\\n    function getUnreliableTCR() external view returns (uint) {\\n        return _getTCR(priceFeed.lastGoodPrice());\\n    }\\n\\n    function checkRecoveryMode(uint _price) external view returns (bool) {\\n        return _checkRecoveryMode(_price);\\n    }\\n\\n    /**\\n     * HEDGEHOG UPDATES:\\n     * New view method to help with getting the data on frontends\\n     */\\n    function checkUnreliableRecoveryMode() external view returns (bool) {\\n        return _checkRecoveryMode(priceFeed.lastGoodPrice());\\n    }\\n\\n    // Check whether or not the system *would be* in Recovery Mode, given an BaseFeeLMA:WStETH price, and the entire system coll and debt.\\n    function _checkPotentialRecoveryMode(\\n        uint _entireSystemColl,\\n        uint _entireSystemDebt,\\n        uint _price\\n    ) internal view returns (bool) {\\n        uint TCR = LiquityMath._computeCR(\\n            _entireSystemColl,\\n            _entireSystemDebt,\\n            _price\\n        );\\n\\n        return TCR < CCR;\\n    }\\n\\n    // --- Redemption fee functions ---\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * 1) Rename variable in docs (baseRate => redemptionBaseRate)\\n     * 2) decayedRemeptionBaseRate (decayedBaseRate) is now calculated by _calcDecayedRedemptionBaseRate();\\n     * 3) Updating RedemptionBaseRate state variable instead of baseRate\\n     * 4) Emiting RedemptionBaseRateUpdated instead of BaseRateUpdates();\\n     * 5) Now updates time only of redemeption operation instead of both redemption and borrow\\n     *\\n     * This function has two impacts on the redemptionBaseRate state variable:\\n     * 1) decays the redemptionBaseRate based on time passed since last redemption or BaseFeeLMA borrowing operation.\\n     * then,\\n     * 2) increases the redemptionBaseRate based on the amount redeemed, as a proportion of totall collateral in the system.\\n     * total collateral taken into the account is a sum of default and active pools collaterals\\n     */\\n    function _updateRedemptionBaseRateFromRedemption(\\n        uint _WStETHDrawn\\n    ) internal returns (uint) {\\n        uint decayedRedemptionBaseRate = _calcDecayedRedemptionBaseRate();\\n        // Hedgehog updates: Now calculating what part of total collateral is getting withdrawn from the\\n        // system\\n\\n        // HEDGEHOG UPDATES: Calculation the fraction now as a ratio of Collateral that is about to get redeemed and a sum of collateral in active & default pools.\\n\\n        uint redeemedBaseFeeLMAFraction = _WStETHDrawn\\n            .mul(DECIMAL_PRECISION)\\n            .div(activePool.getWStETH() + defaultPool.getWStETH());\\n\\n        // Hedgehog Updates: Remove division by BETA\\n        uint newBaseRate = decayedRedemptionBaseRate.add(\\n            redeemedBaseFeeLMAFraction\\n        );\\n\\n        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\\n        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above\\n        // Hedgehog Updates: Remove assertion check to make sure first redemption does not revert after the bootstrapping period if more then 10^18 WstETH was transfer into the contract\\n        // assert(newBaseRate > 0); // Base rate is always non-zero after redemption\\n\\n        // HEDGEHOG UPDATES: succesful redemption now updates only the redemption base rate. Redemption base rate update also received a new event.\\n        // Update the baseRate state variable\\n        redemptionBaseRate = newBaseRate;\\n        emit RedemptionBaseRateUpdated(newBaseRate);\\n\\n        _updateLastRedemptionTime();\\n        return newBaseRate;\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * 1) Now passing redemptionBaseRate instead of combined baseRate\\n     */\\n    function getRedemptionRate() public view returns (uint) {\\n        return _calcRedemptionRate(redemptionBaseRate);\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * Now accepts a new param: redemptionColl as we can't get that amount from value anymore since of ERC20 transition\\n     */\\n    function getRedemptionRateWithDecay() public view returns (uint) {\\n        return _calcRedemptionRate(_calcDecayedRedemptionBaseRate());\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * Redemption Rate formula now is: RedFloor + RedBaseRate*MinuteDecayFactorMinutes + RedemptionETH/TotalColl\\n     * 1) Rename param name (_baseRate => _redemptionBaseRate)\\n     * 2) Now redeemed collateral divided by total collateral in active & defaul pools is added to the sum of redemption floor and redeem base rate\\n     */\\n    function _calcRedemptionRate(\\n        uint _redemptionBaseRate\\n    ) internal view returns (uint) {\\n        return\\n            LiquityMath._min(\\n                REDEMPTION_FEE_FLOOR.add(_redemptionBaseRate),\\n                DECIMAL_PRECISION // cap at a maximum of 100%\\n            );\\n    }\\n\\n    function _getRedemptionFee(uint _WStETHDrawn) internal view returns (uint) {\\n        return _calcRedemptionFee(getRedemptionRate(), _WStETHDrawn);\\n    }\\n\\n    function getRedemptionFeeWithDecay(\\n        uint _WStETHDrawn\\n    ) external view returns (uint) {\\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _WStETHDrawn);\\n    }\\n\\n    function _calcRedemptionFee(\\n        uint _redemptionRate,\\n        uint _WStETHDrawn\\n    ) internal pure returns (uint) {\\n        uint redemptionFee = _redemptionRate.mul(_WStETHDrawn).div(\\n            DECIMAL_PRECISION\\n        );\\n\\n        // Hedgehog Updates: check if fee is too big is now performed at the redeemCollateral function\\n\\n        return redemptionFee;\\n    }\\n\\n    // --- Borrowing fee functions ---\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * 1) Now passing borrowBaseRate instead of combined baseRate\\n     */\\n    function getBorrowingRate(\\n        uint _issuedBaseFeeLMA\\n    ) public view returns (uint) {\\n        return _calcBorrowingRate(borrowBaseRate, _issuedBaseFeeLMA);\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * 1) Now passing _calcDecayedBorrowBaseRate instead of _calcDecayedBaseRate function to calculate the decayed borrowBaseRate\\n     * TODO: Write test\\n     */\\n    function getBorrowingRateWithDecay(\\n        uint _issuedBaseFeeLMA\\n    ) public view returns (uint) {\\n        return\\n            _calcBorrowingRate(_calcDecayedBorrowBaseRate(), _issuedBaseFeeLMA);\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * Now full dynamic fees formula is as follows: RedRate = RedFloor + RedBaseRate*MinuteDecayFactorMinutes + RedemptionETH / Total Collateral in the system\\n     * 1) Rename param name (_baseRate => _borrowBaseRate)\\n     * 2) If BFE total supply is 0, returning fee floor\\n     * 3) Now adding issued bfe amount divided by total supply of the asset to the sum of borrow floor and decayed borrowedBaseRate\\n     */\\n    function _calcBorrowingRate(\\n        uint _borrowBaseRate,\\n        uint _issuedBaseFeeLMA\\n    ) internal view returns (uint) {\\n        uint256 supply = baseFeeLMAToken.totalSupply();\\n        // Checking if there are tokens in supply, otherwise return 1 to avoid division by zero\\n        if (supply == 0) {\\n            return BORROWING_FEE_FLOOR;\\n        }\\n\\n        return\\n            LiquityMath._min(\\n                BORROWING_FEE_FLOOR.add(_borrowBaseRate).add(\\n                    _issuedBaseFeeLMA.mul(DECIMAL_PRECISION).div(supply)\\n                ),\\n                MAX_BORROWING_FEE\\n            );\\n    }\\n\\n    // HEDGEHOG UPDATES: Now retuns also a calculated base rate along with a borrowing fee\\n    function getBorrowingFee(\\n        uint _BaseFeeLMADebt\\n    ) external view returns (uint, uint) {\\n        uint baseRate = getBorrowingRate(_BaseFeeLMADebt);\\n        return (_calcBorrowingFee(baseRate, _BaseFeeLMADebt), baseRate);\\n    }\\n\\n    function getBorrowingFeeWithDecay(\\n        uint _BaseFeeLMADebt\\n    ) external view returns (uint) {\\n        return\\n            _calcBorrowingFee(\\n                getBorrowingRateWithDecay(_BaseFeeLMADebt),\\n                _BaseFeeLMADebt\\n            );\\n    }\\n\\n    function _calcBorrowingFee(\\n        uint _borrowingRate,\\n        uint _BaseFeeLMADebt\\n    ) internal pure returns (uint) {\\n        return _borrowingRate.mul(_BaseFeeLMADebt).div(DECIMAL_PRECISION);\\n    }\\n\\n    // HEDGEHOG UPDATES: New function to updtae borrowBaseRate during borrowing op on BorrowersOperations contract\\n    function updateBaseRateFromBorrowing(uint _newBaseRate) external {\\n        require(\\n            msg.sender == borrowerOperationsAddress,\\n            \\\"TroveManager: Only Borrower operations may call\\\"\\n        );\\n        if (_newBaseRate >= BORROWING_FEE_FLOOR) {\\n            borrowBaseRate = _newBaseRate - BORROWING_FEE_FLOOR;\\n        } else {\\n            borrowBaseRate = 0;\\n        }\\n\\n        emit BorrowBaseRateUpdated(_newBaseRate);\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * 1) Now updates borrowBaseRate instead of baseRate used by both redemption and minting functions\\n     * 2) Emit BorrowBaseRateUpdated instead of BaseRateUpdated\\n     * 3) Now updates time only of borrow operation instead of both redemption and borrow\\n     * 4) Update doc variable name baseRate => borrowBaseRate\\n     */\\n    // Updates the borrowBaseRate state variable based on time elapsed since the last redemption or BaseFeeLMA borrowing operation.\\n    function decayBaseRateFromBorrowing() external {\\n        _requireCallerIsBorrowerOperations();\\n        uint decayedBaseRate = _calcDecayedBorrowBaseRate();\\n        assert(decayedBaseRate <= DECIMAL_PRECISION); // The baseRate can decay to 0\\n        // HEDGEHOG LOGIC CHANGES: Updating a unique borrowing base rate instead of just \\\"baseRate\\\"\\n        borrowBaseRate = decayedBaseRate;\\n\\n        _updateLastBorrowTime();\\n    }\\n\\n    // --- Internal fee functions ---\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * removed _updateLastFeeOpTime\\n     * New function _updateLastRedemptionTime simmilar to _updateLastFeeOpTime, that sets lastRedemptionTime and emits respective event.\\n     */\\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\\n    function _updateLastRedemptionTime() internal {\\n        uint timePassed = block.timestamp.sub(lastRedemptionTime);\\n\\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\\n            lastRedemptionTime = block.timestamp;\\n            emit LastRedemptionTimeUpdated(block.timestamp);\\n        }\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * removed _updateLastFeeOpTime\\n     * New function _updateLastBorrowTime simmilar to _updateLastFeeOpTime, that sets lastBorrowTime and emits respective event.\\n     */\\n    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\\n    function _updateLastBorrowTime() internal {\\n        uint timePassed = block.timestamp.sub(lastBorrowTime);\\n\\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\\n            lastBorrowTime = block.timestamp;\\n            emit LastBorrowTimeUpdated(block.timestamp);\\n        }\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * New function simmilar to _calcDecayedBaseRate. However used particularly for redemptionBaseRate calculation\\n     */\\n    function _calcDecayedRedemptionBaseRate() internal view returns (uint) {\\n        uint minutesPassed = _minutesPassedSinceLastRedemption();\\n\\n        uint decayFactor = LiquityMath._decPow(\\n            MINUTE_DECAY_REDEMPTION_FACTOR,\\n            minutesPassed\\n        );\\n        return redemptionBaseRate.mul(decayFactor).div(DECIMAL_PRECISION);\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * New function simmilar to _calcDecayedBaseRate. However used particularly for borrowBaseRate calculation\\n     */\\n    function _calcDecayedBorrowBaseRate() internal view returns (uint) {\\n        uint minutesPassed = _minutesPassedSinceLastBorrow();\\n        uint decayFactor = LiquityMath._decPow(\\n            MINUTE_DECAY_BORROWING_FACTOR,\\n            minutesPassed\\n        );\\n\\n        return borrowBaseRate.mul(decayFactor).div(DECIMAL_PRECISION);\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * removed _minutesPassedSinceLastFeeOp\\n     * New function _minutesPassedSinceLastRedemption simmilar to _minutesPassedSinceLastFeeOp, that returns amount of minutes since last registered redemption\\n     */\\n    function _minutesPassedSinceLastRedemption() internal view returns (uint) {\\n        return\\n            (block.timestamp.sub(lastRedemptionTime)).div(\\n                SECONDS_IN_ONE_MINUTE\\n            );\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * removed _minutesPassedSinceLastFeeOp\\n     * New function _minutesPassedSinceLastBorrow simmilar to _minutesPassedSinceLastFeeOp, that returns amount of minutes since last registered borrow\\n     */\\n    function _minutesPassedSinceLastBorrow() internal view returns (uint) {\\n        return (block.timestamp.sub(lastBorrowTime)).div(SECONDS_IN_ONE_MINUTE);\\n    }\\n\\n    // --- 'require' wrapper functions ---\\n\\n    function _requireCallerIsBorrowerOperations() internal view {\\n        require(\\n            msg.sender == borrowerOperationsAddress,\\n            \\\"TroveManager: Caller is not the BorrowerOperations contract\\\"\\n        );\\n    }\\n\\n    function _requireTroveIsActive(address _borrower) internal view {\\n        require(\\n            Troves[_borrower].status == Status.active,\\n            \\\"TroveManager: Trove does not exist or is closed\\\"\\n        );\\n    }\\n\\n    function _requireBaseFeeLMABalanceCoversRedemption(\\n        IBaseFeeLMAToken _baseFeeLMAToken,\\n        address _redeemer,\\n        uint _amount\\n    ) internal view {\\n        require(\\n            _baseFeeLMAToken.balanceOf(_redeemer) >= _amount,\\n            \\\"TroveManager: Requested redemption amount must be <= user's BaseFeeLMA token balance\\\"\\n        );\\n    }\\n\\n    function _requireMoreThanOneTroveInSystem(\\n        uint TroveOwnersArrayLength\\n    ) internal view {\\n        require(\\n            TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1,\\n            \\\"TroveManager: Only one trove in the system\\\"\\n        );\\n    }\\n\\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\\n        require(_amount > 0, \\\"TroveManager: Amount must be greater than zero\\\");\\n    }\\n\\n    function _requireTCRoverMCR(uint _price) internal view {\\n        require(\\n            _getTCR(_price) >= MCR,\\n            \\\"TroveManager: Cannot redeem when TCR < MCR\\\"\\n        );\\n    }\\n\\n    function _requireAfterBootstrapPeriod() internal view {\\n        require(\\n            block.timestamp >= SYSTEM_DEPLOYMENT_TIME.add(BOOTSTRAP_PERIOD),\\n            \\\"TroveManager: Redemptions are not allowed during bootstrap phase\\\"\\n        );\\n    }\\n\\n    function _requireValidMaxFeePercentage(\\n        uint _maxFeePercentage\\n    ) internal pure {\\n        require(\\n            _maxFeePercentage >= REDEMPTION_FEE_FLOOR &&\\n                _maxFeePercentage <= DECIMAL_PRECISION,\\n            \\\"Max fee percentage must be between 0.5% and 100%\\\"\\n        );\\n    }\\n\\n    // --- Trove property getters ---\\n\\n    function getTroveStatus(address _borrower) external view returns (uint) {\\n        return uint(Troves[_borrower].status);\\n    }\\n\\n    function getTroveStake(address _borrower) external view returns (uint) {\\n        return Troves[_borrower].stake;\\n    }\\n\\n    function getTroveDebt(address _borrower) external view returns (uint) {\\n        return Troves[_borrower].debt;\\n    }\\n\\n    function getTroveColl(address _borrower) external view returns (uint) {\\n        return Troves[_borrower].coll;\\n    }\\n\\n    // Hedgehog Updates: New function that returns last block update number of a trove. This block is checked at the start of adjust, close and open functions.\\n    function getTroveUpdateBlock(\\n        address _borrower\\n    ) external view returns (uint) {\\n        return Troves[_borrower].lastBlockUpdated;\\n    }\\n\\n    // --- Trove property setters, called by BorrowerOperations ---\\n\\n    function setTroveStatus(address _borrower, uint _num) external {\\n        _requireCallerIsBorrowerOperations();\\n        Troves[_borrower].status = Status(_num);\\n    }\\n\\n    // Hedgehog Updates: New function that stores block update into a trove. This block is checked at the start of adjust, close and open functions.\\n    function setTroveLastUpdatedBlock(address _borrower) external {\\n        _requireCallerIsBorrowerOperations();\\n        Troves[_borrower].lastBlockUpdated = block.number;\\n    }\\n\\n    function increaseTroveColl(\\n        address _borrower,\\n        uint _collIncrease\\n    ) external returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\\n        Troves[_borrower].coll = newColl;\\n        return newColl;\\n    }\\n\\n    function decreaseTroveColl(\\n        address _borrower,\\n        uint _collDecrease\\n    ) external returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\\n        Troves[_borrower].coll = newColl;\\n        return newColl;\\n    }\\n\\n    function increaseTroveDebt(\\n        address _borrower,\\n        uint _debtIncrease\\n    ) external returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\\n        Troves[_borrower].debt = newDebt;\\n        return newDebt;\\n    }\\n\\n    function decreaseTroveDebt(\\n        address _borrower,\\n        uint _debtDecrease\\n    ) external returns (uint) {\\n        _requireCallerIsBorrowerOperations();\\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\\n        Troves[_borrower].debt = newDebt;\\n        return newDebt;\\n    }\\n\\n    /*\\n     * HEDGEHOG UPDATES:\\n     * New frontend helper function easing up the calculation of a baseFeeLma price coming from an oracle for a trove with given coll and debt to become eligble for liquidation\\n     */\\n    function getNormalLiquidationPrice(\\n        uint256 _coll,\\n        uint256 _debt\\n    ) external pure returns (uint256) {\\n        uint256 price = LiquityMath._findPriceBelowMCR(\\n            _coll,\\n            _debt,\\n            HedgehogBase.MCR\\n        );\\n        return price;\\n    }\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 100\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
      "solcInputHash": "43b4e2078427505e7ee73083be665943",
      "transactionHash": "0x58617f0fb60e5c1a79ece0634eb0a88428c7f51440efeeb648b74c2501343b72",
      "args": []
    },
    "decoded": {
      "from": "0x20CCd22C0Cb18F6fbEDCC08aC93E9787c1e98a89",
      "gasPrice": "4939351580",
      "maxFeePerGas": "4939351580",
      "maxPriorityFeePerGas": "1500000000",
      "gasLimit": "1063539",
      "to": null,
      "value": "0",
      "nonce": 304,
      "data": "0x608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6111a58061007e6000396000f3fe608060405234801561001057600080fd5b50600436106100d55760003560e01c806386800a961161008757806386800a96146101635780638da5cb5b1461016b57806390107afe1461017c578063a20baee61461018f578063a3f4df7e1461019e578063c8e07115146101d3578063f2fde38b146101e6578063f56f48f2146101f957600080fd5b80630490be83146100da5780630fdb11cf146100f65780631be5c92f146100fe578063200d2ed21461010657806345079cb414610120578063715018a61461012e578063836efd3114610138575b600080fd5b6100e360035481565b6040519081526020015b60405180910390f35b6100e3610201565b6100e3601281565b6004546101139060ff1681565b6040516100ed9190610e91565b6100e366b1a2bc2ec5000081565b61013661066a565b005b60025461014b906001600160a01b031681565b6040516001600160a01b0390911681526020016100ed565b6100e360b081565b6000546001600160a01b031661014b565b61013661018a366004610ed0565b61067e565b6100e3670de0b6b3a764000081565b6101c660405180604001604052806009815260200168141c9a58d95199595960ba1b81525081565b6040516100ed9190610f03565b60015461014b906001600160a01b031681565b6101366101f4366004610f51565b6107a3565b6100e3604581565b600080600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610257573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061027b9190610f6c565b90506000610287610821565b9050600061029882604001516108c4565b905060006102a461097f565b905060006102b582604001516109f3565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561030c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103309190610f6c565b905060006004805460ff169081111561034b5761034b610e7b565b036104545761035a8585610a17565b156103bc5761036883610a3a565b15610385576103776002610a8a565b600354965050505050505090565b61038e83610ae7565b1561039d576103776001610a8a565b6103a76001610a8a565b6103b18382610b0b565b965050505050505090565b6103c585610ae7565b15610408576103d383610a3a565b156103e2576103776004610a8a565b6103ec6003610a8a565b6103f583610ae7565b156103a757600354965050505050505090565b610413858588610b2a565b156104325761042183610a3a565b806103685750610368838383610b2a565b61043b83610a3a565b1561044a5761044a6004610a8a565b6103b18587610b0b565b60016004805460ff169081111561046d5761046d610e7b565b036104dc5761047f8585858985610ba9565b1561048e5761044a6000610a8a565b61049783610a3a565b156104a6576103776002610a8a565b6104af83610ae7565b156104c257600354965050505050505090565b6104cd838383610b2a565b156103a7576103776002610a8a565b60026004805460ff16908111156104f5576104f5610e7b565b03610516576105078585858985610ba9565b156103775761044a6000610a8a565b60036004805460ff169081111561052f5761052f610e7b565b036105da5761053e8585610a17565b156105655761054c83610a3a565b1561055b576103776002610a8a565b6103ec6001610a8a565b61056e85610ae7565b1561058b5761057c83610a3a565b156103ec576103776004610a8a565b61059483610a3a565b156105a35761044a6004610a8a565b6105ac83610ae7565b156105bf57600354965050505050505090565b6105cb85848884610c07565b1561039d5761044a6000610a8a565b6004805460ff16818111156105f1576105f1610e7b565b03610661576106008585610a17565b1561060f576103776002610a8a565b61061885610ae7565b1561062b57600354965050505050505090565b6106388585858985610ba9565b156106475761044a6000610a8a565b610652858588610b2a565b1561044a576103776002610a8a565b50505050505090565b610672610c90565b61067c6000610cea565b565b610686610c90565b600180546001600160a01b038481166001600160a01b03199283161790925560028054928416929091169190911790556004805460ff1916905560006106ca610821565b905060006106db82604001516108c4565b90506106e78282610a17565b806106f657506106f682610ae7565b156107145760405163062a774160e51b815260040160405180910390fd5b61079482600160009054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561076b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078f9190610f6c565b610b0b565b5061079d61066a565b50505050565b6107ab610c90565b6001600160a01b0381166108155760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61081e81610cea565b50565b610829610e5b565b600160009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b60015b61089f5790565b506001600160501b0390931660408501525082526001600160401b0316602082015290565b6108cc610e5b565b600180546001600160a01b031690639a6fc8f5906108ea908561100c565b6040516001600160e01b031960e084901b1681526001600160501b03909116600482015260240160a060405180830381865afa92505050801561094a575060408051601f3d908101601f1916820190925261094791810190610fa6565b60015b61095357919050565b506001600160501b0390931660408501525082526001600160401b03166020820152919050565b919050565b610987610e5b565b600260009054906101000a90046001600160a01b03166001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa925050508015610898575060408051601f3d908101601f1916820190925261089591810190610fa6565b6109fb610e5b565b6002546001600160a01b0316639a6fc8f56108ea60018561100c565b6000610a2283610d3a565b80610a315750610a3182610d3a565b90505b92915050565b600081602001516001600160401b031660001480610a6457504382602001516001600160401b0316115b15610a7157506001919050565b8151600003610a8257506001919050565b506000919050565b6004805482919060ff191660018383811115610aa857610aa8610e7b565b02179055507f5c57579a8214fe4f710c1c56fa829f045b9fa6d225a744225a30c32188064d4e81604051610adc9190610e91565b60405180910390a150565b6000604582602001516001600160401b031643610b049190611033565b1192915050565b600080610b1f84600001518460ff16610d9d565b9050610a3181610e00565b600080610b3e85600001518460ff16610d9d565b90506000610b5385600001518560ff16610d9d565b90506000610b618383610e35565b90506000610b6f8484610e4b565b90506000610b7d8383611033565b905060006103e8610b8f60b085611046565b610b99919061105d565b9091119998505050505050505050565b6000610bb484610a3a565b80610bc35750610bc384610ae7565b80610bd35750610bd38686610a17565b80610be25750610be286610ae7565b15610bef57506000610bfe565b610bfb86858585610c07565b90505b95945050505050565b600080610c1b86600001518560ff16610d9d565b90506000610c3086600001518560ff16610d9d565b90506000610c3e8284610e35565b90506000610c4c8385610e4b565b9050600082670de0b6b3a7640000610c648285611033565b610c6e9190611046565b610c78919061105d565b66b1a2bc2ec5000010159a9950505050505050505050565b6000546001600160a01b0316331461067c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161080c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600081604001516001600160501b0316600003610d5957506001919050565b60208201516001600160401b03161580610d7f57504382602001516001600160401b0316115b15610d8c57506001919050565b8151600012610a8257506001919050565b60008060128310610dcf57610db3601284611033565b610dbe90600a611163565b610dc8908561105d565b9050610a31565b6012831015610a3157610de3836012611033565b610dee90600a611163565b610df89085611046565b949350505050565b60038190556040518181527f4d29de21de555af78a62fc82dd4bc05e9ae5b0660a37f04729527e0f22780cd390602001610adc565b6000818310610e445781610a31565b5090919050565b600081831015610e445781610a31565b604080516060810182526000808252602082018190529181019190915290565b634e487b7160e01b600052602160045260246000fd5b6020810160058310610eb357634e487b7160e01b600052602160045260246000fd5b91905290565b80356001600160a01b038116811461097a57600080fd5b60008060408385031215610ee357600080fd5b610eec83610eb9565b9150610efa60208401610eb9565b90509250929050565b600060208083528351808285015260005b81811015610f3057858101830151858201604001528201610f14565b506000604082860101526040601f19601f8301168501019250505092915050565b600060208284031215610f6357600080fd5b610a3182610eb9565b600060208284031215610f7e57600080fd5b815160ff81168114610a3157600080fd5b80516001600160501b038116811461097a57600080fd5b600080600080600060a08688031215610fbe57600080fd5b610fc786610f8f565b9450602086015193506040860151925060608601519150610fea60808701610f8f565b90509295509295909350565b634e487b7160e01b600052601160045260246000fd5b6001600160501b0382811682821603908082111561102c5761102c610ff6565b5092915050565b81810381811115610a3457610a34610ff6565b8082028115828204841417610a3457610a34610ff6565b60008261107a57634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156110ba5781600019048211156110a0576110a0610ff6565b808516156110ad57918102915b93841c9390800290611084565b509250929050565b6000826110d157506001610a34565b816110de57506000610a34565b81600181146110f457600281146110fe5761111a565b6001915050610a34565b60ff84111561110f5761110f610ff6565b50506001821b610a34565b5060208310610133831016604e8410600b841016171561113d575081810a610a34565b611147838361107f565b806000190482111561115b5761115b610ff6565b029392505050565b6000610a3183836110c256fea264697066735822122001009bba11d0396e6ace2f028614dc7f72a0d919338e760a544930daa4b324f064736f6c63430008130033",
      "r": "0x8245b12abea9edee548bce988906ef00a517f214751c83438f0347c45f9c862b",
      "s": "0x491759b7df2014d5815c2033e45cbea1dfdecdf73d05ce0545b3f961b67b3cb9",
      "v": 1,
      "chainId": 11155111
    }
  }
}